#include "stdafx.h"

#include "RenderSystemDX11Hooks.h"

#include "CampathDrawer.h"
#include "ReShadeAdvancedfx.h"
#include "WrpConsole.h"
#include "CamIO.h"
#include "MirvFix.h"

#include "RenderCommands.h"
#include "StreamSettings.h"

#include "../shared/AfxDetours.h"
#include "../shared/binutils.h"
#include "../shared/Captures.h"
#include "../shared/FileTools.h"
#include "../shared/ImageBufferPoolThreadSafe.h"
#include "../shared/ImageTransformer.h"
#include "../shared/RecordingSettings.h"
#include "../shared/RefCountedThreadSafe.h"
#include "../shared/StringTools.h"
#include "../shared/CamIO.h"
#include "../shared/ConsolePrinter.h"

#include "../deps/release/prop/cs2/sdk_src/public/cdll_int.h"
#include "../deps/release/prop/cs2/sdk_src/public/icvar.h"
#include "../deps/release/prop/cs2/sdk_src/public/tier1/iconvar.h"

#include "../shaders/build/afx_depth_vs_5_0.h" // autogenerated
#include "../shaders/build/afx_depth_ps_5_0.h" // autogenerated

#include <d3d11.h>
#define _XM_NO_INTRINSICS_
#include <DirectXMath.h>

#include <set>
#include <map>
#include <queue>
#include <list>
#include <mutex>
#include <shared_mutex>
#include <condition_variable>
#include <atomic>
#include <thread>
#include <functional>

#include <dxgi.h>
#include <dxgi1_4.h>

extern advancedfx::CThreadPool * g_pThreadPool;
extern advancedfx::CImageBufferPoolThreadSafe * g_pImageBufferPoolThreadSafe;

extern SOURCESDK::CS2::ISource2EngineToClient * g_pEngineToClient;
extern SOURCESDK::CS2::ICvar * SOURCESDK::CS2::g_pCVar;

CRenderCommands g_RenderCommands;

bool g_bEnableReShade = true;
bool g_bReShadeCompositeSmoke = true;
bool g_bCompositeSmoke = false;

class CAfxCpuTexture
: public advancedfx::CRefCountedThreadSafe
, public advancedfx::ICapture
, public advancedfx::IImageBuffer
{
public:
    virtual void AddRef() override {
        advancedfx::CRefCountedThreadSafe::AddRef();
    }

    virtual void Release() override {
        advancedfx::CRefCountedThreadSafe::Release();
    }

    virtual const advancedfx::CImageFormat * GetImageBufferFormat() const {
        return &m_ImageFormat;
    }

    virtual const void * GetImageBufferData() const {
        return m_MappedResource.pData;
    }

	virtual const IImageBuffer* GetBuffer() const {
        return this;
    }

    CAfxCpuTexture(ID3D11Device * pDevice)
    : m_pDevice(pDevice)
    {
        m_pDevice->AddRef();
        m_MappedResource.pData = nullptr;
        m_Condition.notify_one();
    }

    void GpuCopyResource(ID3D11DeviceContext * pContext, ID3D11Texture2D * pTexture) {
        if(m_pCpuTexture == nullptr && pTexture) {
            D3D11_TEXTURE2D_DESC desc;
            pTexture->GetDesc(&desc);
            bool bMultiSampled = 1 < desc.SampleDesc.Count;
            desc.BindFlags = 0;
            desc.MiscFlags = 0;
            desc.MipLevels = 1;
            desc.SampleDesc.Count = 1;
            desc.SampleDesc.Quality = 0;
            advancedfx::ImageFormat format = advancedfx::ImageFormat::Unkown;
            switch(desc.Format) {
            case DXGI_FORMAT_R8G8B8A8_TYPELESS:
            case DXGI_FORMAT_R8G8B8A8_UNORM:
            case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
            case DXGI_FORMAT_R8G8B8A8_UINT:
            case DXGI_FORMAT_R8G8B8A8_SNORM:
            case DXGI_FORMAT_R8G8B8A8_SINT:
               format = advancedfx::ImageFormat::RGBA;
               desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
               break;
            default:
                advancedfx::Warning("AFXERROR: GpuCopyResource - unspported DXGI_FORMAT: %i\n",desc.Format);
            }
            if(bMultiSampled) {
                desc.Usage = D3D11_USAGE_DEFAULT;
                desc.CPUAccessFlags = 0;
                m_pDevice->CreateTexture2D(&desc, nullptr, &m_pResolveTexture);
            }
            desc.Usage = D3D11_USAGE_STAGING;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
            m_ImageFormat = advancedfx::CImageFormat(format, desc.Width, desc.Height);
            m_Format = desc.Format;
            m_pDevice->CreateTexture2D(&desc, nullptr, &m_pCpuTexture);
        }

        if(m_pCpuTexture && pTexture) {
            if(m_pResolveTexture) {
                pContext->ResolveSubresource(m_pResolveTexture, 0, pTexture, 0, m_Format);
                pContext->CopyResource(m_pCpuTexture, m_pResolveTexture);
            } else {
                pContext->CopyResource(m_pCpuTexture, pTexture);
            }
        }
    }

    void CpuSignalDone() {
        std::unique_lock<std::mutex> lock(m_Mutex);
        m_bCpuDone = true;
        m_Condition.notify_one();
    }     

    class advancedfx::IImageBuffer * CpuBeginAccess(ID3D11DeviceContext * pContext) {
        m_MappedResource.pData = nullptr;
        if(m_pCpuTexture) {
            if(SUCCEEDED(pContext->Map(m_pCpuTexture, 0, D3D11_MAP_READ , 0, &m_MappedResource))) {
                m_ImageFormat = advancedfx::CImageFormat(m_ImageFormat.Format, m_ImageFormat.Width, m_ImageFormat.Height, m_MappedResource.RowPitch);
                return this;
            }
        }
        return nullptr;
    }

    void IfAcccessedWaitForCpuAndEndAccess(ID3D11DeviceContext * pContext) {        
        if(m_MappedResource.pData) {
            WaitForCpu();
            pContext->Unmap(m_pCpuTexture, 0);    
            m_MappedResource.pData = nullptr;        
        }
    }

protected:
    virtual ~CAfxCpuTexture() {
        if(m_pCpuTexture) {
            m_pCpuTexture->Release();
        }
        if(m_pResolveTexture){
            m_pResolveTexture->Release();
        }
        m_pDevice->Release();
    }

private:
    ID3D11Device * m_pDevice;
    ID3D11Texture2D * m_pCpuTexture = nullptr;
    ID3D11Texture2D * m_pResolveTexture = nullptr;
    DXGI_FORMAT m_Format = DXGI_FORMAT_UNKNOWN;
    std::mutex m_Mutex;
    std::condition_variable m_Condition;
    bool m_bCpuDone = false;
    advancedfx::CImageFormat m_ImageFormat;
    D3D11_MAPPED_SUBRESOURCE m_MappedResource;


    void WaitForCpu() {
        std::unique_lock<std::mutex> lock(m_Mutex);
        m_Condition.wait(lock, [this] { return m_bCpuDone; });
        m_bCpuDone = false;
    }
};

class CAfxCapture {
public:
    CAfxCapture(class advancedfx::COutVideoStreamCreator* pOutVideoStreamCreator, bool wantsAlpha)
     : m_pOutVideoStreamCreator(pOutVideoStreamCreator)
     , m_WantsAlpha (wantsAlpha)
    {
        m_pOutVideoStreamCreator->AddRef();
        m_ProcessingThread = std::thread(&CAfxCapture::ProcessingThreadFunc, this);
    }

    void Finish(ID3D11DeviceContext * pDeviceContext) {
        while(m_CpuTextures[0] || m_CpuTextures[1]) {
            if(m_CpuTextures[m_Index]) {
                m_CpuTextures[m_Index]->IfAcccessedWaitForCpuAndEndAccess(pDeviceContext);
                m_CpuTextures[m_Index]->Release();
                m_CpuTextures[m_Index] = nullptr;
            }
            m_Index = (m_Index + 1) % 2;
        }
    }

    ~CAfxCapture() {
        {
            std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
            m_ShutDown = true;
            m_ProcessingThreadCv.notify_one();
        }
        m_ProcessingThread.join();
        if(m_CpuTextures[0]) {
            m_CpuTextures[0]->Release();
        }
        if(m_CpuTextures[1]) {
            m_CpuTextures[1]->Release();
        }
    }

    void OnBeforeGpuPresent(ID3D11DeviceContext * pDeviceContext, ID3D11Texture2D * pTexture) {
        if(m_CpuTextures[m_Index] == nullptr) {
            ID3D11Device * pDevice = nullptr;
            pDeviceContext->GetDevice(&pDevice);
            if(pDevice) {
                auto pCpuTexture = new CAfxCpuTexture(pDevice);
                pCpuTexture->AddRef();
                m_CpuTextures[m_Index] = pCpuTexture;
                pDevice->Release();
            }
        } else {
            m_CpuTextures[m_Index]->IfAcccessedWaitForCpuAndEndAccess(pDeviceContext);
        }
        m_CpuTextures[m_Index]->GpuCopyResource(pDeviceContext, pTexture);
    }

    void OnAfterGpuPresent(ID3D11DeviceContext * pDeviceContext) {
        m_Index = (m_Index + 1) % 2;
        if(m_CpuTextures[m_Index]) {
            m_CpuTextures[m_Index]->CpuBeginAccess(pDeviceContext);
            StartProcess(0,m_CpuTextures[m_Index]);
        }
    }

private:

    void StartProcess(size_t index, CAfxCpuTexture * pCpuTexture) {
        std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
        if(index == 0) {
            m_In.push_back(new CBuffers(m_Streams_size));
        }
        (*m_In.rbegin())->SetAt(index, pCpuTexture);
        if (index + 1  >= m_Streams_size) {
            m_ProcessingThreadCv.notify_one();
        }
    }

    size_t m_Index = 0;
    CAfxCpuTexture * m_CpuTextures[2]={nullptr,nullptr};

    const size_t m_Streams_size = 1;
    class advancedfx::COutVideoStreamCreator* m_pOutVideoStreamCreator;
	advancedfx::COutVideoStream* m_OutVideoStream = nullptr;

    bool m_WantsAlpha;

	class CBuffers {
	public:
		CBuffers(size_t size) : m_Buffers(size) {
		}

		size_t GetSize() const {
			return m_Buffers.size();
		}

		class CAfxCpuTexture * GetAt(size_t index) const {
			return m_Buffers[index];
		}

		void SetAt(size_t index, class CAfxCpuTexture * value) {
			m_Buffers[index] = value;
		}

	private:
		std::vector<class CAfxCpuTexture *> m_Buffers;
	};

	std::mutex m_ProcessingThreadMutex;
	std::condition_variable m_ProcessingThreadCv;
	std::thread m_ProcessingThread;
	bool m_ShutDown = false;

	std::list<class CBuffers*> m_In;

	void ProcessingThreadFunc() {
		std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
		while (!m_ShutDown || !m_In.empty()) {
			if (!m_In.empty()) {
				class CBuffers* buffers = m_In.front();
				if(buffers->GetSize() >= m_Streams_size) {
					class CBuffers* task = buffers;
					m_In.pop_front();
					lock.unlock();

                    size_t taskSize = task->GetSize();
                    for(size_t i=0; i < taskSize; i++) {
                        auto pTexture = task->GetAt(i);
                        if(pTexture) {
                            advancedfx::ICapture* capture = pTexture;
                            switch(pTexture->GetImageBufferFormat()->Format) {
                            case advancedfx::ImageFormat::RGBA:
                                if(m_WantsAlpha) {
                                    capture = advancedfx::ImageTransformer::RgbaToBgra(g_pThreadPool,g_pImageBufferPoolThreadSafe,pTexture);
                                } else {
                                    capture = advancedfx::ImageTransformer::RgbaToBgr(g_pThreadPool,g_pImageBufferPoolThreadSafe,pTexture);
                                }
                                break;
                            default:
                                capture->AddRef();
                                break;
                            }
                            if (capture) {
                                if (const advancedfx::IImageBuffer* buffer = capture->GetBuffer()) {                            
                                    if (m_OutVideoStream == nullptr) {
                                        m_OutVideoStream = m_pOutVideoStreamCreator->CreateOutVideoStream(*buffer->GetImageBufferFormat());
                                        if (nullptr == m_OutVideoStream)
                                        {
                                            advancedfx::Warning("AFXERROR: Failed to create image stream for screen recording.\n");
                                        }
                                        else
                                        {
                                            m_OutVideoStream->AddRef();
                                        }
                                    }
                                    if (nullptr != m_OutVideoStream && !m_OutVideoStream->SupplyImageBuffer(buffer))
                                    {
                                        advancedfx::Warning("AFXERROR: Failed writing image for screen recording.\n");
                                    }
                                }
                                else {
                                   advancedfx::Warning("AFXERROR: Could not get capture buffer for screen recording.\n");
                                }
                                capture->Release();
                                capture = nullptr; 
                            }                               
                            pTexture->CpuSignalDone();
                        }
                    }

					delete task;
					task = nullptr;
					lock.lock();
				} else {
					m_ProcessingThreadCv.wait(lock);
				}
			} else {
				m_ProcessingThreadCv.wait(lock);
			}		
        }
        if(m_OutVideoStream) m_OutVideoStream->Release();
        m_pOutVideoStreamCreator->Release();
	}
};

D3D11_VIEWPORT g_ViewPort;

class CProjectionMatrix {
public:
    CProjectionMatrix() {
        m_ProjectionMatrix.m[0][0] = 1; m_ProjectionMatrix.m[0][1] = 0; m_ProjectionMatrix.m[0][2] = 0; m_ProjectionMatrix.m[0][3] = 0;
        m_ProjectionMatrix.m[1][0] = 0; m_ProjectionMatrix.m[1][1] = 1; m_ProjectionMatrix.m[1][2] = 0; m_ProjectionMatrix.m[1][3] = 0;
        m_ProjectionMatrix.m[2][0] = 0; m_ProjectionMatrix.m[2][1] = 0; m_ProjectionMatrix.m[2][2] = 1; m_ProjectionMatrix.m[2][3] = 0;
        m_ProjectionMatrix.m[3][0] = 0; m_ProjectionMatrix.m[3][1] = 0; m_ProjectionMatrix.m[3][2] = 0; m_ProjectionMatrix.m[3][3] = 1;
    }

    void Get(SOURCESDK::VMatrix & projectionMatrix) {
        memcpy(projectionMatrix.m, m_ProjectionMatrix.m, sizeof(projectionMatrix.m));
    }

    void Set(const SOURCESDK::VMatrix & projectionMatrix) {
        memcpy(m_ProjectionMatrix.m, projectionMatrix.m, sizeof(m_ProjectionMatrix.m));
    }

private:
    SOURCESDK::VMatrix m_ProjectionMatrix;
} g_EngineThread_ProjectionMatrix,g_RenderThread_ProjectionMatrix;



class CDepthCompositor {
public:
    enum DepthTextureType_e {
        DepthTextureType_R32F = 0,
        DepthTextureType_RGB = 1,
        DepthTextureTypeCount = 2
    };

    void OnTargetBegin(ID3D11Device * pDevice, ID3D11Texture2D * pTexture) {
        if(pDevice && pTexture) {
            pDevice->AddRef();    
            m_pDevice = pDevice;
            pTexture->GetDesc(&m_DeviceTextureDesc);
            m_HasSmokeDepth = false;
            for(int i=0;i<DepthTextureTypeCount;i++) m_HasNormalDepth[i] = false;

            m_pDevice->CreateDeferredContext(0, &m_DeviceContext);

            {
                D3D11_DEPTH_STENCIL_DESC depthStencilDesc{
                    FALSE, // DepthEnable;
                    D3D11_DEPTH_WRITE_MASK_ZERO, // DepthWriteMask
                    D3D11_COMPARISON_ALWAYS, // DepthFunc
                    FALSE, // StencilEnable
                    D3D11_DEFAULT_STENCIL_WRITE_MASK, // StencilReadMask
                    D3D11_DEFAULT_STENCIL_READ_MASK, // StencilWriteMask
                    { D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // FrontFace
                    { D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // BackFace
                };
                m_pDevice->CreateDepthStencilState(&depthStencilDesc, &m_DepthStencilState);
            }

            {
                D3D11_RASTERIZER_DESC rasterizerDesc{
                    D3D11_FILL_SOLID, // FillMode
                    D3D11_CULL_NONE, // CullMode
                    TRUE, // FrontCounterClockwise
                    0, // DepthBias
                    0, // DepthBiasClamp
                    0, // SlopeScaledDepthBias
                    FALSE, // DepthClipEnable
                    FALSE, // ScissorEnable
                    TRUE, // MultisampleEnable
                    FALSE // AntialiasedLineEnable	
                };

                m_pDevice->CreateRasterizerState(&rasterizerDesc, &m_RasterizerState);
            }

            {
                D3D11_BLEND_DESC blendDesc{
                    FALSE, // AlphaToCoverageEnable
                    FALSE, // IndependentBlendEnable
                    // D3D11_RENDER_TARGET_BLEND_DESC
                    {
                        {
                            FALSE, // BlendEnable
                            D3D11_BLEND_SRC_ALPHA, // SrcBlend,
                            D3D11_BLEND_INV_SRC_ALPHA, // DstBlend
                            D3D11_BLEND_OP_ADD, // BlendOp
                            D3D11_BLEND_SRC_ALPHA, // SrcBlendAlpha,
                            D3D11_BLEND_INV_SRC_ALPHA, // DestBlendAlpha
                            D3D11_BLEND_OP_ADD, // BlendOpAlpha
                            D3D11_COLOR_WRITE_ENABLE_ALL // RenderTargetWriteMask
                        }
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                    }
                };
                m_pDevice->CreateBlendState(&blendDesc, &m_BlendState);
            }

            {
                D3D11_BUFFER_DESC cbDesc;
                cbDesc.ByteWidth = sizeof(CS_CONSTANT_BUFFER);
                cbDesc.Usage = D3D11_USAGE_DYNAMIC;
                cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
                cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
                cbDesc.MiscFlags = 0;
                cbDesc.StructureByteStride = 0;

                m_pDevice->CreateBuffer(
                    &cbDesc, NULL, &m_ConstantBuffer
                );
            }

            if(Vertex* pVertexData = (Vertex*)malloc(sizeof(Vertex) * 4))
            {
                pVertexData[0].x = -1; pVertexData[0].y = 1;
                pVertexData[1].x = 1; pVertexData[1].y = 1;
                pVertexData[2].x = -1; pVertexData[2].y = -1;
                pVertexData[3].x = 1; pVertexData[3].y = -1;

                D3D11_SUBRESOURCE_DATA subResourceData{
                    pVertexData,
                    sizeof(Vertex) * 4,
                    0
                };

                D3D11_BUFFER_DESC cbDesc;
                cbDesc.ByteWidth = 4 * sizeof(Vertex);
                cbDesc.Usage = D3D11_USAGE_IMMUTABLE;
                cbDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
                cbDesc.CPUAccessFlags = 0;
                cbDesc.MiscFlags = 0;
                cbDesc.StructureByteStride = 0;

                if (!SUCCEEDED(m_pDevice->CreateBuffer(
                    &cbDesc, &subResourceData, &m_VertexBuffer
                ))) {
                    if (m_VertexBuffer) m_VertexBuffer->Release();
                    m_VertexBuffer = nullptr;
                }

                free(pVertexData);
            }

            {
                size_t size;
                void* so = LoadFromAcsShaderFileInMemory(L"afx_depth_vs_5_0.acs", ShaderCombo_afx_depth_vs_5_0::GetCombo(), size);
                if (so) {
                    m_pDevice->CreateVertexShader(so, size, NULL, &m_VertexShader);
                }
                if (so) free(so);
            }
        }
    }

    void OnTargetEnd() {
        if (m_VertexBuffer) {
            m_VertexBuffer->Release();
            m_VertexBuffer = nullptr;
        }

        if (m_VertexShader) {
            m_VertexShader->Release();
            m_VertexShader = nullptr;
        }

        while (!m_DepthShaderCombos.empty()) {
            auto it = m_DepthShaderCombos.begin();
            it->second->Release();
            m_DepthShaderCombos.erase(it);
        }

        if (m_BlendState) {
            m_BlendState->Release();
            m_BlendState = nullptr;
        }

        if (m_RasterizerState) {
            m_RasterizerState->Release();
            m_RasterizerState = nullptr;
        }

        if (m_DepthStencilState) {
            m_DepthStencilState->Release();
            m_DepthStencilState = nullptr;
        }

        if (m_ConstantBuffer) {
            m_ConstantBuffer->Release();
            m_ConstantBuffer = nullptr;
        }

        if (m_DeviceContext) {
            m_DeviceContext->Release();
            m_DeviceContext = nullptr;
        }

        if (m_pSmokeDepthTextureSrv) {
            m_pSmokeDepthTextureSrv->Release();
            m_pSmokeDepthTextureSrv = nullptr;
        }

        if(m_pSmokeDepthTexture) {
            m_pSmokeDepthTexture->Release();
            m_pSmokeDepthTexture = nullptr;
        }

        if (m_pNormalDepthTextureSrv) {
            m_pNormalDepthTextureSrv->Release();
            m_pNormalDepthTextureSrv = nullptr;
        }

        if (m_pNormalDepthTexture) {
            m_pNormalDepthTexture->Release();
            m_pNormalDepthTexture = nullptr;
        }

        for(int i=0; i<DepthTextureTypeCount;i++) {
            if (m_pDepthTextureRtv[i]) {
                m_pDepthTextureRtv[i]->Release();
                m_pDepthTextureRtv[i] = nullptr;
            }
        }

        for(int i=0; i<DepthTextureTypeCount;i++) {
            if (m_pDepthTexture[i]) {
                m_pDepthTexture[i]->Release();
                m_pDepthTexture[i] = nullptr;
            }
        }

        if(m_pDevice) {
            m_pDevice->Release();
            m_pDevice = nullptr;
        }
    }

    void CaptureSmokeDepth(ID3D11DeviceContext * pContext, ID3D11DepthStencilView * pDepthStencilView) {
        if (!HasCoreDeps() || pContext == nullptr || pDepthStencilView == nullptr) return;

        D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
        pDepthStencilView->GetDesc(&depthStencilViewDesc);

        if(D3D11_DSV_DIMENSION_TEXTURE2D == depthStencilViewDesc.ViewDimension
            //|| D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension // usally this is not the case for smoke buffer           
        ) {
            ID3D11Resource * pResource = nullptr;
            pDepthStencilView->GetResource(&pResource);
            if(pResource) {
                ID3D11Texture2D * pTexture = nullptr;
                pResource->QueryInterface(__uuidof(ID3D11Texture2D), (void**)&pTexture);
                if(pTexture) {
                    /*UINT dataSize = 0;
                    if (SUCCEEDED(pTexture->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, nullptr))) {
                        isSmokeTexture = true;
                        if (0 < dataSize) {
                            if (char* debugName = (char*)malloc(dataSize + 1)) {
                                if (SUCCEEDED(pTexture->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, debugName))) {
                                    debugName[dataSize] = 0;
                                    advancedfx::Message("AFXD3DDEBUG: %s\n", debugName);
                                }
                                free(debugName);
                            }
                        }
                    }*/

                    D3D11_TEXTURE2D_DESC smokeDepthTextureDesc;
                    pTexture->GetDesc(&smokeDepthTextureDesc);

                    if (nullptr != m_pSmokeDepthTexture) {
                        // Check if the texture properties changed in a relevant way that needs updating.
                        if (m_SmokeDepthTextureDesc.Width != smokeDepthTextureDesc.Width
                            || m_SmokeDepthTextureDesc.Height != smokeDepthTextureDesc.Height
                            || m_SmokeDepthTextureDesc.MipLevels != smokeDepthTextureDesc.MipLevels
                            || m_SmokeDepthTextureDesc.Format != smokeDepthTextureDesc.Format
                            || m_SmokeDepthTextureDesc.SampleDesc.Count != smokeDepthTextureDesc.SampleDesc.Count
                            || m_SmokeDepthTextureDesc.SampleDesc.Quality != smokeDepthTextureDesc.SampleDesc.Quality
                            ) {
                            m_pSmokeDepthTexture->Release();
                            m_pSmokeDepthTexture = nullptr;
                        }
                    }

                    if (nullptr == m_pSmokeDepthTexture) {
                        m_SmokeDepthTextureDesc = smokeDepthTextureDesc; // Usally DXGI_FORMAT_R24G8_TYPELESS to expect here.
                        smokeDepthTextureDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;
                        smokeDepthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
                        smokeDepthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
                        smokeDepthTextureDesc.CPUAccessFlags = 0;
                        smokeDepthTextureDesc.MiscFlags = 0;
                        D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc = {};
                        srvbuffer_desc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
                        srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
                        srvbuffer_desc.Texture2D.MipLevels = 1;
                        srvbuffer_desc.Texture2D.MostDetailedMip = 0;
                        m_pDevice->CreateTexture2D(&smokeDepthTextureDesc, nullptr, &m_pSmokeDepthTexture);
                        if (m_pSmokeDepthTexture) {
                            if (m_pSmokeDepthTextureSrv) {
                                m_pSmokeDepthTextureSrv->Release();
                                m_pSmokeDepthTextureSrv = nullptr;
                            }
                            m_pDevice->CreateShaderResourceView(m_pSmokeDepthTexture, &srvbuffer_desc, &m_pSmokeDepthTextureSrv);
                        }
                    }

                    if(m_pSmokeDepthTexture)
                    {
                        UINT numViewPorts = 1;
                        pContext->RSGetViewports(&numViewPorts, &m_SmokeViewPort);

                        ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                        ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                        pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                        }

                        pContext->CopyResource(m_pSmokeDepthTexture, pTexture);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                        }

                        if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();

                        m_HasSmokeDepth = true;
                    }
                    
                    pTexture->Release();
                }

                pResource->Release();
            }
        }
    }

    void CaptureNormalDepth(ID3D11DeviceContext * pContext, ID3D11DepthStencilView * pDepthStencilView,
        bool compositeSmoke,
        DepthTextureType_e depthTextureType,
        ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_e afxDepthMode,
        ShaderCombo_afx_depth_ps_5_0::AFXD24_e afxD24,
        float outZNear = 0.0f,
        float outZFar = 0.0f
    ) {
        if (!HasCoreDeps() || pContext == nullptr || pDepthStencilView == nullptr) return;

        EnsureDepthTexture(depthTextureType);

        if(m_pDepthTexture[depthTextureType] == nullptr || m_pDepthTextureRtv[depthTextureType] == nullptr) return;

        D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
        pDepthStencilView->GetDesc(&depthStencilViewDesc);

        if (D3D11_DSV_DIMENSION_TEXTURE2D == depthStencilViewDesc.ViewDimension
            || D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension    
            ) {
            ID3D11Resource* pResource = nullptr;
            pDepthStencilView->GetResource(&pResource);
            if (pResource) {
                ID3D11Texture2D* pTexture = nullptr;
                pResource->QueryInterface(__uuidof(ID3D11Texture2D), (void**)&pTexture);
                if (pTexture) {
                    D3D11_TEXTURE2D_DESC normalDepthTextureDesc;
                    pTexture->GetDesc(&normalDepthTextureDesc);

                    if (nullptr != m_pNormalDepthTexture) {
                        // Check if the texture properties changed in a relevant way that needs updating.
                        if (m_NormalDepthTextureDesc.Width != normalDepthTextureDesc.Width
                            || m_NormalDepthTextureDesc.Height != normalDepthTextureDesc.Height
                            || m_NormalDepthTextureDesc.MipLevels != normalDepthTextureDesc.MipLevels
                            || m_NormalDepthTextureDesc.Format != normalDepthTextureDesc.Format
                            || m_NormalDepthTextureDesc.SampleDesc.Count != normalDepthTextureDesc.SampleDesc.Count
                            || m_NormalDepthTextureDesc.SampleDesc.Quality != normalDepthTextureDesc.SampleDesc.Quality
                            ) {
                            m_pNormalDepthTexture->Release();
                            m_pNormalDepthTexture = nullptr;
                        }
                    }

                    if (nullptr == m_pNormalDepthTexture) {
                        m_NormalDepthTextureDesc = normalDepthTextureDesc; // Usally DXGI_FORMAT_R24G8_TYPELESS to expect here.
                        normalDepthTextureDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;
                        normalDepthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
                        normalDepthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
                        normalDepthTextureDesc.CPUAccessFlags = 0;
                        normalDepthTextureDesc.MiscFlags = 0;
                        D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc = {};
                        srvbuffer_desc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
                        srvbuffer_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension ? D3D11_SRV_DIMENSION_TEXTURE2DMS : D3D11_SRV_DIMENSION_TEXTURE2D;
                        srvbuffer_desc.Texture2D.MipLevels = normalDepthTextureDesc.MipLevels;
                        srvbuffer_desc.Texture2D.MostDetailedMip = 0;
                        m_pDevice->CreateTexture2D(&normalDepthTextureDesc, nullptr, &m_pNormalDepthTexture);
                        if (m_pNormalDepthTexture) {
                            if (m_pNormalDepthTextureSrv) {
                                m_pNormalDepthTextureSrv->Release();
                                m_pNormalDepthTextureSrv = nullptr;
                            }
                            m_pDevice->CreateShaderResourceView(m_pNormalDepthTexture, &srvbuffer_desc, &m_pNormalDepthTextureSrv);
                        }
                    }

                    if (m_pNormalDepthTexture)
                    {
                        UINT numViewPorts = 1;
                        pContext->RSGetViewports(&numViewPorts, &m_NormalViewPort);

                        ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                        ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                        pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                        }

                        pContext->CopyResource(m_pNormalDepthTexture, pTexture);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                        }

                        if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();
                    }

                    if (m_pDepthTextureRtv[depthTextureType] && m_pNormalDepthTextureSrv)
                    {
                        m_DeviceContext->OMSetRenderTargets(1, &m_pDepthTextureRtv[depthTextureType], nullptr);
                        m_DeviceContext->OMSetBlendState(m_BlendState, NULL, 0xffffffff);                        

                        UINT numViewPorts = 1;
                        m_DeviceContext->RSSetViewports(1, &m_NormalViewPort);

                        SOURCESDK::VMatrix projectionMatrix;
                        g_RenderThread_ProjectionMatrix.Get(projectionMatrix);

                        double M[4][4] = {
                            projectionMatrix.m[0][0], projectionMatrix.m[0][1], projectionMatrix.m[0][2],  projectionMatrix.m[0][3],
                            projectionMatrix.m[1][0], projectionMatrix.m[1][1], projectionMatrix.m[1][2],  projectionMatrix.m[1][3],
                            projectionMatrix.m[2][0], projectionMatrix.m[2][1], projectionMatrix.m[2][2],  projectionMatrix.m[2][3],
                            projectionMatrix.m[3][0], projectionMatrix.m[3][1], projectionMatrix.m[3][2],  projectionMatrix.m[3][3]
                        };

                        double b0[4] = { 1, 0, 0, 0 };
                        double b1[4] = { 0, 1, 0, 0 };
                        double b2[4] = { 0, 0, 1, 0 };
                        double b3[4] = { 0, 0, 0, 1 };

                        unsigned char P[4];
                        unsigned char Q[4];

                        double L[4][4];
                        double U[4][4];

                        FLOAT newMatrix[4][4];
                        FLOAT zNear = g_ViewPort.MinDepth;
                        FLOAT zFar = g_ViewPort.MaxDepth;
                        FLOAT zNormalNear = projectionMatrix.m[2][3] / projectionMatrix.m[2][2];
                        FLOAT zNormalFar = projectionMatrix.m[2][3] / (projectionMatrix.m[2][2] + 1);

                        if (LUdecomposition(M, P, Q, L, U))
                        {
                            double inv0[4] = { 1,0,0,0 };
                            double inv1[4] = { 0,1,0,0 };
                            double inv2[4] = { 0,0,1,0 };
                            double inv3[4] = { 0,0,0,1 };

                            SolveWithLU(L, U, P, Q, b0, inv0);
                            SolveWithLU(L, U, P, Q, b1, inv1);
                            SolveWithLU(L, U, P, Q, b2, inv2);
                            SolveWithLU(L, U, P, Q, b3, inv3);

                            // Transposed for DirectX:
                            newMatrix[0][0] = (FLOAT)inv0[0]; newMatrix[0][1] = (FLOAT)inv0[1]; newMatrix[0][2] = (FLOAT)inv0[2]; newMatrix[0][3] = (FLOAT)inv0[3];
                            newMatrix[1][0] = (FLOAT)inv1[0]; newMatrix[1][1] = (FLOAT)inv1[1]; newMatrix[1][2] = (FLOAT)inv1[2]; newMatrix[1][3] = (FLOAT)inv1[3];
                            newMatrix[2][0] = (FLOAT)inv2[0]; newMatrix[2][1] = (FLOAT)inv2[1]; newMatrix[2][2] = (FLOAT)inv2[2]; newMatrix[2][3] = (FLOAT)inv2[3];
                            newMatrix[3][0] = (FLOAT)inv3[0]; newMatrix[3][1] = (FLOAT)inv3[1]; newMatrix[3][2] = (FLOAT)inv3[2]; newMatrix[3][3] = (FLOAT)inv3[3];
                        }
                        else {
                            newMatrix[0][0] = 1; newMatrix[0][1] = 0; newMatrix[0][2] = 0; newMatrix[0][3] = 0;
                            newMatrix[1][0] = 0; newMatrix[1][1] = 1; newMatrix[1][2] = 0; newMatrix[1][3] = 0;
                            newMatrix[2][0] = 0; newMatrix[2][1] = 0; newMatrix[2][2] = 1; newMatrix[2][3] = 0;
                            newMatrix[3][0] = 0; newMatrix[3][1] = 0; newMatrix[3][2] = 0; newMatrix[3][3] = 1;
                        }

                        int skyBoxScale = 16;
                        FLOAT zSkyNear = 2.0f * skyBoxScale;
                        FLOAT zSkyFar = (float)(1.732050807569 * 2 * 16384 * skyBoxScale);

                        if(0.0f == outZNear && outZFar == outZNear) {
                            outZNear = zNormalNear;
                            outZFar = zNormalFar;
                        }

                        CS_CONSTANT_BUFFER constant_buffer = {
                            zNormalNear,
                            zNormalFar,
                            outZNear,
                            outZFar,
                            zNear,
                            zFar,
                            zSkyNear,
                            zSkyFar,
                            (int)g_ViewPort.Width,
                            (int)g_ViewPort.Height,
                            (int)m_DeviceTextureDesc.Width,
                            (int)m_DeviceTextureDesc.Height,
                            {
                                newMatrix[0][0], newMatrix[0][1], newMatrix[0][2], newMatrix[0][3],
                                newMatrix[1][0], newMatrix[1][1], newMatrix[1][2], newMatrix[1][3],
                                newMatrix[2][0], newMatrix[2][1], newMatrix[2][2], newMatrix[2][3],
                                newMatrix[3][0], newMatrix[3][1], newMatrix[3][2], newMatrix[3][3]
                            }
                        };
                        {
                            D3D11_MAPPED_SUBRESOURCE mappedResource;
                            if (SUCCEEDED(m_DeviceContext->Map(m_ConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource))) {
                                memcpy(mappedResource.pData, &constant_buffer, sizeof(constant_buffer));
                                m_DeviceContext->Unmap(m_ConstantBuffer, 0);
                            }
                        }
                        m_DeviceContext->PSSetConstantBuffers(0, 1, &m_ConstantBuffer);

                        bool multisampled = 1 < m_NormalDepthTextureDesc.SampleDesc.Count;
                        compositeSmoke = compositeSmoke && m_HasSmokeDepth && m_pSmokeDepthTextureSrv;

                        int shaderCombo = ShaderCombo_afx_depth_ps_5_0::GetCombo(
                            multisampled ? ShaderCombo_afx_depth_ps_5_0::AFXMS_1 : ShaderCombo_afx_depth_ps_5_0::AFXMS_0,
                            compositeSmoke ? ShaderCombo_afx_depth_ps_5_0::AFXSMOKE_1 : ShaderCombo_afx_depth_ps_5_0::AFXSMOKE_0,
                            afxDepthMode,
                            afxD24
                        );

                        ID3D11PixelShader * pPixelShader = nullptr;
                        auto it = m_DepthShaderCombos.find(shaderCombo);
                        if (it != m_DepthShaderCombos.end())
                            pPixelShader = it->second;
                        else {
                            size_t size;
                            void* so = LoadFromAcsShaderFileInMemory(L"afx_depth_ps_5_0.acs", shaderCombo, size);

                            if (so) {
                                m_pDevice->CreatePixelShader(so, size, NULL, &pPixelShader);
                            }
                            if (so) free(so);

                            m_DepthShaderCombos[shaderCombo] = pPixelShader;
                        }
                        if (pPixelShader) {
                            m_DeviceContext->PSSetShaderResources(0, 1, &m_pNormalDepthTextureSrv);
                            if(compositeSmoke) m_DeviceContext->PSSetShaderResources(1, 1, &m_pSmokeDepthTextureSrv);

                            m_DeviceContext->VSSetShader(m_VertexShader, nullptr, 0);
                            m_DeviceContext->PSSetShader(pPixelShader, nullptr, 0);

                            UINT stride = sizeof(Vertex);
                            UINT offset = 0;
                            m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

                            UINT startVertex = 0;
                            // Draw quad:
                            m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
                            m_DeviceContext->Draw(4, startVertex);

                            m_HasNormalDepth[depthTextureType] = true;
                        }

                        //

                        ID3D11CommandList* pCommandList = nullptr;
                        m_DeviceContext->FinishCommandList(FALSE, &pCommandList);
                        if (pCommandList) {
                            pContext->ExecuteCommandList(pCommandList,
                                TRUE // RestoreContextState has quite some performance impact on TRUE, let's try FALSE first
                            );
                            pCommandList->Release();
                        }
                    }

                    pTexture->Release();
                }

                pResource->Release();
            }
        }
    }

    ID3D11Texture2D * GetDepthTexture(DepthTextureType_e depthTextureType) {
        if (m_HasNormalDepth[depthTextureType]) {
            if (m_pDepthTexture[depthTextureType]) m_pDepthTexture[depthTextureType]->AddRef();
            return m_pDepthTexture[depthTextureType];
        }
        return nullptr;
    }

    void OnPresent() {
        m_HasSmokeDepth = false;
        for(int i=0;i<DepthTextureTypeCount;i++) m_HasNormalDepth[i] = false;
    }

private:
    ID3D11Device * m_pDevice = nullptr;
    D3D11_TEXTURE2D_DESC m_DeviceTextureDesc = {};
    ID3D11Texture2D * m_pSmokeDepthTexture = nullptr;
    ID3D11ShaderResourceView* m_pSmokeDepthTextureSrv = nullptr;
    D3D11_TEXTURE2D_DESC m_SmokeDepthTextureDesc = {};
    D3D11_VIEWPORT m_SmokeViewPort = {};
    bool m_HasSmokeDepth = false;
    ID3D11ShaderResourceView* m_pNormalDepthTextureSrv = nullptr;
    ID3D11Texture2D* m_pNormalDepthTexture = nullptr;
    D3D11_TEXTURE2D_DESC m_NormalDepthTextureDesc = {};

    ID3D11Texture2D* m_pDepthTexture[2] = {nullptr,nullptr};
    ID3D11RenderTargetView* m_pDepthTextureRtv[2] = {nullptr,nullptr};
    D3D11_VIEWPORT m_NormalViewPort = {};
    bool m_HasNormalDepth[2] = {false,false};

    ID3D11DeviceContext* m_DeviceContext = nullptr;

    struct CS_CONSTANT_BUFFER {
        float cZNear;
        float cZFar;
        float cOutNear;
        float cOutFar;
        float cNormalFar;
        float unused_c1y;
        float cSkyNear;
        float cSkyFar;
        int cViewportWidth;
        int cViewportHeight;
        int cWidth;
        int cHeight;
        DirectX::XMFLOAT4X4 invViewProj;
    };
    ID3D11Buffer* m_ConstantBuffer = nullptr;

    std::map<int, ID3D11PixelShader*> m_DepthShaderCombos;

    ID3D11VertexShader* m_VertexShader = nullptr;

    struct Vertex
    {
        FLOAT x, y, z;
    };
    ID3D11Buffer* m_VertexBuffer = nullptr;

    ID3D11DepthStencilState* m_DepthStencilState = nullptr;

    ID3D11RasterizerState* m_RasterizerState = nullptr;

    ID3D11BlendState* m_BlendState = nullptr;

    bool HasCoreDeps() {
        return m_pDevice && m_DeviceContext && m_ConstantBuffer && m_VertexBuffer && m_VertexShader && m_DepthStencilState && m_RasterizerState && m_BlendState;
    }

    void EnsureDepthTexture(DepthTextureType_e depthTextureType) {
        if(nullptr == m_pDevice) return;
        if(nullptr == m_pDepthTexture[depthTextureType]) {
            D3D11_TEXTURE2D_DESC depthTextureDesc;
            depthTextureDesc.Width = m_DeviceTextureDesc.Width;
            depthTextureDesc.Height = m_DeviceTextureDesc.Height;
            depthTextureDesc.MipLevels = 1;
            depthTextureDesc.ArraySize = 1;
            depthTextureDesc.Format = depthTextureType == DepthTextureType_R32F ? DXGI_FORMAT_R32_FLOAT : DXGI_FORMAT_R8G8B8A8_UNORM;
            depthTextureDesc.SampleDesc.Count = 1;
            depthTextureDesc.SampleDesc.Quality = 0;
            depthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
            depthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
            depthTextureDesc.CPUAccessFlags = 0;
            depthTextureDesc.MiscFlags = 0;
            m_pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &m_pDepthTexture[depthTextureType]);

            D3D11_RENDER_TARGET_VIEW_DESC rtvbuffer_desc = {};
            rtvbuffer_desc.Format = depthTextureType == DepthTextureType_R32F ? DXGI_FORMAT_R32_FLOAT : DXGI_FORMAT_R8G8B8A8_UNORM;
            rtvbuffer_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
            rtvbuffer_desc.Texture2D.MipSlice = 0;
            if (m_pDepthTexture[depthTextureType]) {
                m_pDevice->CreateRenderTargetView(m_pDepthTexture[depthTextureType], &rtvbuffer_desc, &m_pDepthTextureRtv[depthTextureType]);
            }
        }
    }
} g_DepthCompositor;


IDXGISwapChain * g_pSwapChain = nullptr;
ID3D11Device * g_pDevice = nullptr;
ID3D11DeviceContext * g_pImmediateContext = nullptr;
ID3D11DeviceContext * g_pOtherContext = nullptr;
ID3D11RenderTargetView* g_pRTView = nullptr;
int g_iDraw = 0;
bool g_bInOwnDraw = false;
ID3D11Resource* g_pMainRenderTargetResource = nullptr;
bool g_bDetectSmoke = false;
bool g_bDetectSmoke2 = false;
bool g_bDetectedSmoke = false;
bool g_bDetectedSmoke2 = false;
ID3D11DepthStencilView* g_pSmokeDepthStencilView = nullptr;

enum class ViewPass_e {
    None = 0,
    BeforeGameOverlay = 1
};

struct ViewPasses_s {
public:
    std::queue<ViewPass_e> Queue;
};

extern void ErrorBox(char const * messageText);

class CAfxShaderResourceViews {
public:
    static ID3D11ShaderResourceView* GetView(ID3D11Resource* pResource) {
        std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_Resource2View.find(pResource);
        if (result != m_Resource2View.end())
            return result->second;
        return nullptr;
    }

    static ID3D11Resource* GetResource(ID3D11ShaderResourceView* pView) {
        std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_View2Resource.find(pView);
        if (result != m_View2Resource.end())
            return result->second;
        return nullptr;
    }


    static void Hook(ID3D11Resource* pResource, ID3D11ShaderResourceView* pShaderResourceView) {
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
            if (m_View2Resource.find(pShaderResourceView) != m_View2Resource.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        if (!m_View2Resource.emplace(pShaderResourceView, pResource).second) return;
        m_Resource2View.emplace(pResource, pShaderResourceView);
        HookVtable(pShaderResourceView);
    }

    static void Clear() {
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        m_Resource2View.clear();
        m_View2Resource.clear();
    }

private:
    static std::shared_timed_mutex m_SharedMutex;
    static std::map<ID3D11Resource*, ID3D11ShaderResourceView*> m_Resource2View;
    static std::map<ID3D11ShaderResourceView*, ID3D11Resource*> m_View2Resource;

    typedef ULONG(STDMETHODCALLTYPE* Release_t)(IUnknown* pThis);

    static std::shared_timed_mutex m_VtableSharedMutex;
    static std::map<Release_t, Release_t> m_VtableHooks;

    static void OnDelete(IUnknown* pThis) {
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
            if (m_View2Resource.find(static_cast<ID3D11ShaderResourceView*>(pThis)) == m_View2Resource.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_View2Resource.find(static_cast<ID3D11ShaderResourceView*>(pThis));
        if (result == m_View2Resource.end()) return;
        m_Resource2View.erase(result->second);
        m_View2Resource.erase(result);
    }

    static ULONG STDMETHODCALLTYPE NewRelease(IUnknown* pThis) {
        void** vtable = *(void***)pThis;
        Release_t pRelease = (Release_t)vtable[2];
        ULONG result;
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
            result = m_VtableHooks.find(pRelease)->second(pThis);
        }
        if (0 == result) {
            OnDelete(pThis);
        }
        return result;
    }

    static void HookVtable(IUnknown* pUnknown) {
        void** vtable = *(void***)pUnknown;
        Release_t pRelease = (Release_t)vtable[2];
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
            if (m_VtableHooks.find(pRelease) != m_VtableHooks.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
        if (m_VtableHooks.find(pRelease) != m_VtableHooks.end()) return;

        Release_t oldRelease = pRelease;
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)pRelease, NewRelease);
        if (NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("CAfxShaderResourceViews::HookVtable Failed hooking on IUnknown.");
        } else m_VtableHooks.emplace(oldRelease, pRelease);
    }
};

std::shared_timed_mutex CAfxShaderResourceViews::m_SharedMutex;
std::map<ID3D11Resource*, ID3D11ShaderResourceView*> CAfxShaderResourceViews::m_Resource2View;
std::map<ID3D11ShaderResourceView*, ID3D11Resource*> CAfxShaderResourceViews::m_View2Resource;
std::shared_timed_mutex CAfxShaderResourceViews::m_VtableSharedMutex;
std::map<CAfxShaderResourceViews::Release_t, CAfxShaderResourceViews::Release_t> CAfxShaderResourceViews::m_VtableHooks;

typedef HRESULT (STDMETHODCALLTYPE * CreateShaderResourceView_t)(ID3D11Device* This,
    /* [annotation] */
    _In_  ID3D11Resource* pResource,
    /* [annotation] */
    _In_opt_  const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
    /* [annotation] */
    _COM_Outptr_opt_  ID3D11ShaderResourceView** ppSRView);

CreateShaderResourceView_t g_Old_CreateShaderResourceView = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateShaderResourceView(ID3D11Device* This,
    /* [annotation] */
    _In_  ID3D11Resource* pResource,
    /* [annotation] */
    _In_opt_  const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
    /* [annotation] */
    _COM_Outptr_opt_  ID3D11ShaderResourceView** ppSRView) {
    HRESULT result = g_Old_CreateShaderResourceView(This, pResource, pDesc, ppSRView);

    if (SUCCEEDED(result) && pResource && pDesc && ppSRView && *ppSRView) {
        CAfxShaderResourceViews::Hook(pResource, *ppSRView);
    }

    return result;
}

typedef HRESULT (STDMETHODCALLTYPE * CreateRenderTargetView_t)( ID3D11Device * This,
            /* [annotation] */ 
            _In_  ID3D11Resource *pResource,
            /* [annotation] */ 
            _In_opt_  const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,
            /* [annotation] */ 
            _COM_Outptr_opt_  ID3D11RenderTargetView **ppRTView);

CreateRenderTargetView_t g_Old_CreateRenderTargetView = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateRenderTargetView(  ID3D11Device * This,
            /* [annotation] */ 
            _In_  ID3D11Resource *pResource,
            /* [annotation] */ 
            _In_opt_  const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,
            /* [annotation] */ 
            _COM_Outptr_opt_  ID3D11RenderTargetView **ppRTView) {
    
    HRESULT result = g_Old_CreateRenderTargetView(This, pResource, pDesc, ppRTView);

    if (SUCCEEDED(result) && ppRTView && *ppRTView
    &&g_pSwapChain // can be nullptr e.g. when people forget to "disable service" on FACEIT anti cheat.
    ) {
        ID3D11Texture2D * pTexture = nullptr;
        HRESULT result2 = g_pSwapChain->GetBuffer(0,__uuidof(ID3D11Texture2D), (void**)&pTexture);
        if(SUCCEEDED(result2)) {
            if(pResource == pTexture/* && (g_pDevice == nullptr || This != g_pDevice)*/) {
                if(g_pDevice) {
                    g_DepthCompositor.OnTargetEnd();
                    CAfxShaderResourceViews::Clear();
                    g_CampathDrawer.EndDevice();
                    g_pDevice->Release();
                    g_pDevice = nullptr;
                }
                g_DepthCompositor.OnTargetBegin(This, pTexture);
                g_iDraw = 0;
                g_pRTView = *ppRTView;
                g_pMainRenderTargetResource = nullptr;
                g_pDevice = This;
                g_pDevice->AddRef();
                g_CampathDrawer.BeginDevice(This);
            }
            pTexture->Release();
        }
    }

    return result;
}

typedef void (STDMETHODCALLTYPE * ClearDepthStencilView_t)( ID3D11DeviceContext * This, 
    /* [annotation] */ 
    _In_  ID3D11DepthStencilView *pDepthStencilView,
    /* [annotation] */ 
    _In_  UINT ClearFlags,
    /* [annotation] */ 
    _In_  FLOAT Depth,
    /* [annotation] */ 
    _In_  UINT8 Stencil);

ClearDepthStencilView_t g_Old_ClearDepthStencilView = nullptr;

ID3D11RenderTargetView * g_pCurrentRenderTargetView = nullptr;
ID3D11DepthStencilView * g_pCurrentDepthStencilView = nullptr;

void STDMETHODCALLTYPE New_ClearDepthStencilView( ID3D11DeviceContext * This, 
    _In_  ID3D11DepthStencilView *pDepthStencilView,
    /* [annotation] */ 
    _In_  UINT ClearFlags,
    /* [annotation] */ 
    _In_  FLOAT Depth,
    /* [annotation] */ 
    _In_  UINT8 Stencil) {

    if (This == g_pImmediateContext && g_bInOwnDraw == false) {

        /*if (g_bDetectedSmoke && pDepthStencilView == g_pSmokeDepthStencilView) {
            g_bDetectedSmoke = false;
            ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
            ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
            g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

            if (pDepthStencilView && pDepthStencilView == pCurrentDepthStencilView)
                g_pImmediateContext->OMSetRenderTargets(0, nullptr, nullptr);

            g_DepthCompositor.CaptureSmokeDepth(g_pImmediateContext, g_pSmokeDepthStencilView);

            if (pDepthStencilView && pDepthStencilView == pCurrentDepthStencilView)
                g_pImmediateContext->OMSetRenderTargets(0, nullptr, pCurrentDepthStencilView);

            if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();
        }*/
    }

    g_Old_ClearDepthStencilView(This, pDepthStencilView, ClearFlags, Depth, Stencil);
}

typedef void (STDMETHODCALLTYPE * ResolveSubresource_t)( ID3D11DeviceContext * This,
    /* [annotation] */ 
    _In_  ID3D11Resource *pDstResource,
    /* [annotation] */ 
    _In_  UINT DstSubresource,
    /* [annotation] */ 
    _In_  ID3D11Resource *pSrcResource,
    /* [annotation] */ 
    _In_  UINT SrcSubresource,
    /* [annotation] */ 
    _In_  DXGI_FORMAT Format);

ResolveSubresource_t g_Old_ResolveSubresource = nullptr;

void STDMETHODCALLTYPE New_ResolveSubresource( ID3D11DeviceContext * This,
    /* [annotation] */ 
    _In_  ID3D11Resource *pDstResource,
    /* [annotation] */ 
    _In_  UINT DstSubresource,
    /* [annotation] */ 
    _In_  ID3D11Resource *pSrcResource,
    /* [annotation] */ 
    _In_  UINT SrcSubresource,
    /* [annotation] */ 
    _In_  DXGI_FORMAT Format) {

    if(This == g_pImmediateContext && g_bInOwnDraw == false) {
        g_pMainRenderTargetResource = pSrcResource;
    }

    g_Old_ResolveSubresource(This, pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);
 }


typedef void (STDMETHODCALLTYPE * OMSetRenderTargets_t)( ID3D11DeviceContext * This,
            /* [annotation] */ 
            _In_range_( 0, D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT )  UINT NumViews,
            /* [annotation] */ 
            _In_reads_opt_(NumViews)  ID3D11RenderTargetView *const *ppRenderTargetViews,
            /* [annotation] */ 
            _In_opt_  ID3D11DepthStencilView *pDepthStencilView);

OMSetRenderTargets_t g_Old_OMSetRenderTargets = nullptr;

void STDMETHODCALLTYPE New_OMSetRenderTargets( ID3D11DeviceContext * This,
            /* [annotation] */ 
            _In_range_( 0, D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT )  UINT NumViews,
            /* [annotation] */ 
            _In_reads_opt_(NumViews)  ID3D11RenderTargetView *const *ppRenderTargetViews,
            /* [annotation] */ 
            _In_opt_  ID3D11DepthStencilView *pDepthStencilView) {       
    if (!g_bInOwnDraw && This->GetType() == D3D11_DEVICE_CONTEXT_IMMEDIATE) {
        if (NumViews >= 1) {
            if (g_iDraw == 0 && pDepthStencilView && ppRenderTargetViews && ppRenderTargetViews[0]) {
                g_iDraw = 2;
                g_pImmediateContext = This;
                g_pCurrentDepthStencilView = pDepthStencilView;
                g_pCurrentRenderTargetView = ppRenderTargetViews[0];
            }
            else if (g_iDraw == 2 && pDepthStencilView == nullptr && ppRenderTargetViews && ppRenderTargetViews[0] && ppRenderTargetViews[0] == g_pCurrentRenderTargetView) {
                g_iDraw = 3;

                g_bInOwnDraw = true;

                UINT numViewPorts = 1;
                g_pImmediateContext->RSGetViewports(&numViewPorts, &g_ViewPort);

                g_CampathDrawer.OnRenderThread_Draw(g_pImmediateContext, &g_ViewPort, g_pCurrentRenderTargetView, g_pCurrentDepthStencilView);

                g_bInOwnDraw = false;
            }
        }
        if (g_bDetectSmoke && pDepthStencilView) {
            g_bDetectedSmoke = true;
            g_bDetectSmoke = false;
        }
        if (g_bDetectSmoke2 && pDepthStencilView) {
            static int count;
            if (!g_bDetectedSmoke2) {
                g_bDetectedSmoke2 = true;
                count = 0;
            }
            //advancedfx::Message("Smoke: %i\n", count);
            if (4 == count) {
                g_pSmokeDepthStencilView = pDepthStencilView;
            }
            count++;
        }
    }

    g_Old_OMSetRenderTargets(This, NumViews, ppRenderTargetViews, pDepthStencilView);
}

class IRenderThreadCallback abstract {
public:
    virtual void OnCallback(void) abstract = 0;
};

class CAfxRenderCallbackSetupViewPlayer0 : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackSetupViewPlayer0()
    {
    }

    virtual void OnCallback(void) {
        g_RenderCommands.RenderThread_BeginFrame(g_pImmediateContext);
        delete this;
    }
private:
};


class CAfxRenderCallbackBeforeDetectSmoke : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackBeforeDetectSmoke()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = true;
        }
        delete this;
    }
private:
};

class CAfxRenderCallbackAfterDetectSmoke : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackAfterDetectSmoke()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = false;
        }
        delete this;
    }
private:
};


class CAfxRenderCallbackBeforeMaybeDrawSmoke : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackBeforeMaybeDrawSmoke()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            if (g_bDetectedSmoke) {
                g_bDetectedSmoke = false;
                g_bDetectSmoke2 = true;
                g_bDetectedSmoke2 = false;
                g_pSmokeDepthStencilView = nullptr;
            }
        }
        delete this;
    }
private:
};

class CAfxRenderCallbackAfterMaybeSmokeDrawn : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackAfterMaybeSmokeDrawn()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            if (g_bDetectedSmoke2 && g_pSmokeDepthStencilView && (
                g_ReShadeAdvancedfx.IsConnected() && g_bEnableReShade && g_bReShadeCompositeSmoke
                || g_bCompositeSmoke
            )) {
                ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                if (pCurrentDepthStencilView == g_pSmokeDepthStencilView) {
                    g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                }

                g_DepthCompositor.CaptureSmokeDepth(g_pImmediateContext, g_pSmokeDepthStencilView);

                if (pCurrentDepthStencilView == g_pSmokeDepthStencilView) {
                    g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                }

                if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();

                g_pSmokeDepthStencilView = nullptr;
            }
            g_bDetectSmoke2 = false;
            g_bDetectedSmoke2 = false;
        }
        delete this;
    }
private:
};

class CAfxRenderCallbackBeforeUi : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackBeforeUi()
    {

    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            
            g_bDetectSmoke = false;

            if (g_ReShadeAdvancedfx.IsConnected() && g_bEnableReShade) {
                g_DepthCompositor.CaptureNormalDepth(g_pImmediateContext, g_pCurrentDepthStencilView,
                    g_bReShadeCompositeSmoke,
                    CDepthCompositor::DepthTextureType_R32F,
                    ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_0,
                    ShaderCombo_afx_depth_ps_5_0::AFXD24_0,
                    0.0f,
                    0.0f
                );

                ID3D11RenderTargetView* pRenderTargetViews[1] = {nullptr};
                ID3D11DepthStencilView* pDepthStencilView = nullptr;
                g_pImmediateContext->OMGetRenderTargets(1, &pRenderTargetViews[0], &pDepthStencilView);

                ID3D11Resource* pRenderTargetViewResource = nullptr;
                //ID3D11Resource* pDepthStencilResource = nullptr;
                if (pRenderTargetViews[0]) pRenderTargetViews[0]->GetResource(&pRenderTargetViewResource);
                //if (g_pCurrentDepthStencilView) g_pCurrentDepthStencilView->GetResource(&pDepthStencilResource);

                if (ID3D11Resource* pResource = g_DepthCompositor.GetDepthTexture(CDepthCompositor::DepthTextureType_R32F)) {
                    g_bInOwnDraw = true;
                    g_ReShadeAdvancedfx.AdvancedfxRenderEffects(pRenderTargetViewResource, pResource);
                    g_bInOwnDraw = false;
                    pResource->Release();
                }

                //if (pDepthStencilResource) pDepthStencilResource->Release();
                if (pRenderTargetViewResource) pRenderTargetViewResource->Release();

                if (pDepthStencilView) pDepthStencilView->Release();
                if (pRenderTargetViews[0]) pRenderTargetViews[0]->Release();
            }

            if(auto pRenderPassCommands = g_RenderCommands.RenderThread_GetCommands())
            {
                if(!pRenderPassCommands->BeforeUi.Empty() || !pRenderPassCommands->BeforeUi2.Empty()) {

                    ID3D11RenderTargetView* pRenderTargetViews[1] = {nullptr};
                    g_pImmediateContext->OMGetRenderTargets(1, &pRenderTargetViews[0], nullptr);

                    
                    if (pRenderTargetViews[0]) {
                        if(!pRenderPassCommands->BeforeUi.Empty()) {
                            ID3D11Resource* pRenderTargetViewResource = nullptr;
                            pRenderTargetViews[0]->GetResource(&pRenderTargetViewResource);
                            if(pRenderTargetViewResource) {
                                ID3D11Texture2D * pTexture = nullptr;
                                if(SUCCEEDED(pRenderTargetViewResource->QueryInterface(__uuidof(ID3D11Texture2D),(void**)&pTexture))){
                                    if(pTexture) {
                                        pRenderPassCommands->OnBeforeUi(pTexture);               
                                        pTexture->Release();
                                    }
                                }
                                pRenderTargetViewResource->Release();
                            }
                        }
                        if(!pRenderPassCommands->BeforeUi2.Empty()) {
                            pRenderPassCommands->OnBeforeUi2(pRenderTargetViews[0]); 
                        }

                        pRenderTargetViews[0]->Release();
                    }
                }
            }            
        }
        delete this;
    }
private:
};


typedef void (STDMETHODCALLTYPE * PSSetShaderResources_t)(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1)  UINT StartSlot,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot)  UINT NumViews,
    /* [annotation] */
    _In_reads_opt_(NumViews)  ID3D11ShaderResourceView* const* ppShaderResourceViews);

PSSetShaderResources_t g_Old_PSSetShaderResources = nullptr;

void STDMETHODCALLTYPE New_PSSetShaderResources(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1)  UINT StartSlot,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot)  UINT NumViews,
    /* [annotation] */
    _In_reads_opt_(NumViews)  ID3D11ShaderResourceView* const* ppShaderResourceViews) {

    /*if (This == g_pImmediateContext && g_iDraw == 6 && NumViews >= 1 && ppShaderResourceViews && ppShaderResourceViews[0]) {
        g_iDraw = 6;
        auto pResource = CAfxShaderResourceViews::GetResource(ppShaderResourceViews[0]);
        if (pResource) {
            if (g_ReShadeAdvancedfx.IsConnected() && g_bEnableReShade) {
                ID3D11Resource* pDepthStencilResource = nullptr;
                if (g_pCurrentDepthStencilView) g_pCurrentDepthStencilView->GetResource(&pDepthStencilResource);
                g_bInOwnDraw = true;
                g_ReShadeAdvancedfx.AdvancedfxRenderEffects(pResource, pDepthStencilResource);
                g_bInOwnDraw = false;
                if (pDepthStencilResource) pDepthStencilResource->Release();
            }
        }
    }*/

    return g_Old_PSSetShaderResources(This, StartSlot, NumViews, ppShaderResourceViews);
}

typedef void (STDMETHODCALLTYPE *PSSetShader_t)(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_opt_  ID3D11PixelShader* pPixelShader,
    /* [annotation] */
    _In_reads_opt_(NumClassInstances)  ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances);

PSSetShader_t g_Old_PSSetShader = nullptr;


void STDMETHODCALLTYPE New_PSSetShader(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_opt_  ID3D11PixelShader* pPixelShader,
    /* [annotation] */
    _In_reads_opt_(NumClassInstances)  ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances) {

    /*if (This == g_pImmediateContext) {
        if (g_iDraw == 5 && pPixelShader && nullptr == ppClassInstances && NumClassInstances == 0) {
            const char* pKey = "post_process.vfx_ps";
            const size_t keyLen = 19;
            char buffer[19];
            UINT dataSize = keyLen;
            if (SUCCEEDED(pPixelShader->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, &buffer))
                && dataSize == keyLen) {
                size_t i = 0;
                while (true) {
                    if (pKey[i] != buffer[i]) break;
                    i++;
                    if (i == keyLen) {
                        g_iDraw++;
                        break;
                    }
                }
            }
        }
    }*/

    g_Old_PSSetShader(This, pPixelShader, ppClassInstances, NumClassInstances);
}

void Hook_Context(ID3D11DeviceContext * pDeviceContext) {
    static void **last_vtable = nullptr;
    void **vtable = *(void***)pDeviceContext;

    // (We can not use vtable detours here, becuse something writes them back after we did that.)

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    if(last_vtable) {
        DetourDetach(&(PVOID&)g_Old_PSSetShaderResources, New_PSSetShaderResources);
        DetourDetach(&(PVOID&)g_Old_PSSetShader, New_PSSetShader);
        DetourDetach(&(PVOID&)g_Old_OMSetRenderTargets, New_OMSetRenderTargets);
        DetourDetach(&(PVOID&)g_Old_ClearDepthStencilView, New_ClearDepthStencilView);
        DetourDetach(&(PVOID&)g_Old_ResolveSubresource, New_ResolveSubresource);
        if(NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("Failed detaching on ID1D11RenderContext.");
        }
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
    }
    g_Old_PSSetShaderResources = (PSSetShaderResources_t)vtable[8];
    g_Old_PSSetShader = (PSSetShader_t)vtable[9];
    g_Old_OMSetRenderTargets = (OMSetRenderTargets_t)vtable[33];
    g_Old_ClearDepthStencilView = (ClearDepthStencilView_t)vtable[53];
    g_Old_ResolveSubresource = (ResolveSubresource_t)vtable[57];
    DetourAttach(&(PVOID&)g_Old_PSSetShaderResources, New_PSSetShaderResources);
    DetourAttach(&(PVOID&)g_Old_PSSetShader, New_PSSetShader);
    DetourAttach(&(PVOID&)g_Old_OMSetRenderTargets, New_OMSetRenderTargets);
    DetourAttach(&(PVOID&)g_Old_ClearDepthStencilView, New_ClearDepthStencilView);
    DetourAttach(&(PVOID&)g_Old_ResolveSubresource, New_ResolveSubresource);
    if(NO_ERROR != DetourTransactionCommit()) {
        ErrorBox("Failed attaching on ID1D11RenderContext.");
    }

    last_vtable = vtable;   
}

typedef HRESULT(WINAPI* D3D11CreateDevice_t)(IDXGIAdapter*,D3D_DRIVER_TYPE,HMODULE,UINT,const D3D_FEATURE_LEVEL*,UINT,UINT,ID3D11Device**,D3D_FEATURE_LEVEL*,ID3D11DeviceContext**);
D3D11CreateDevice_t g_Old_D3D11CreateDevice = nullptr;

HRESULT WINAPI New_D3D11CreateDevice(
    IDXGIAdapter *pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL *pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    ID3D11Device **ppDevice,
    D3D_FEATURE_LEVEL *pFeatureLevel,
    ID3D11DeviceContext **ppImmediateContext
    ) {

#ifdef _DEBUG
    //Flags = Flags | D3D11_CREATE_DEVICE_DEBUG;
#endif
    HRESULT result = g_Old_D3D11CreateDevice(
        pAdapter, DriverType, Software, Flags, pFeatureLevels, FeatureLevels, SDKVersion, ppDevice, pFeatureLevel, ppImmediateContext);

    if(SUCCEEDED(result) && ppDevice && *ppDevice) {
        static void **last_vtable = nullptr;
        void **vtable = *(void***)*ppDevice;
        // (We can not use vtable detours here, becuse something writes them back after we New_CreateRenderTargetViewdid that.)
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        if(last_vtable) {
            DetourDetach(&(PVOID&)g_Old_CreateShaderResourceView, New_CreateShaderResourceView);
            DetourDetach(&(PVOID&)g_Old_CreateRenderTargetView, New_CreateRenderTargetView);
            if(NO_ERROR != DetourTransactionCommit()) {
                ErrorBox("Failed detaching in D3D11CreateDevice.");
            }
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
        }
        g_Old_CreateShaderResourceView = (CreateShaderResourceView_t)vtable[7];
        g_Old_CreateRenderTargetView = (CreateRenderTargetView_t)vtable[9];
        DetourAttach(&(PVOID&)g_Old_CreateShaderResourceView, New_CreateShaderResourceView);
        DetourAttach(&(PVOID&)g_Old_CreateRenderTargetView, New_CreateRenderTargetView);
        if(NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("Failed attaching in D3D11CreateDevice.");
        }
        last_vtable = vtable;

        ID3D11DeviceContext * pContext = nullptr;
        (*ppDevice)->GetImmediateContext(&pContext);
        if(pContext) {
            Hook_Context(pContext);
            pContext->Release();
        }
    }

    return result;
}

typedef HRESULT (STDMETHODCALLTYPE * Present_t)( void * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags);

Present_t g_OldPresent = nullptr;

HRESULT STDMETHODCALLTYPE New_Present( void * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags) {
 
    g_bInOwnDraw = true;

    g_CampathDrawer.OnRenderThread_Present();

    if (g_ReShadeAdvancedfx.IsConnected() && !g_ReShadeAdvancedfx.HasRendered()) {
        g_ReShadeAdvancedfx.AdvancedfxRenderEffects(nullptr, nullptr);
    }

    if(auto pRenderPassCommands = g_RenderCommands.RenderThread_GetCommands())
    {
        if(!pRenderPassCommands->BeforePresent.Empty()) {
            ID3D11Texture2D * pTexture = nullptr;
            if(g_pSwapChain) g_pSwapChain->GetBuffer(0,__uuidof(ID3D11Texture2D), (void**)&pTexture);            
            pRenderPassCommands->OnBeforePresent(pTexture);
            if(pTexture) pTexture->Release();
        }
    }

    HRESULT result = g_OldPresent(This, SyncInterval, Flags);

    if(auto pRenderPassCommands = g_RenderCommands.RenderThread_GetCommands()) {
        pRenderPassCommands->OnAfterPresent();
        pRenderPassCommands->OnAfterPresentOrContextLossReliable();
    }

    g_RenderCommands.RenderThread_EndFrame(g_pImmediateContext);

	g_ReShadeAdvancedfx.ResetHasRendered();

    g_DepthCompositor.OnPresent();

    g_bInOwnDraw = false;

    g_iDraw = 0;

    return result;
}


typedef HRESULT (STDMETHODCALLTYPE * CreateSwapChain_t)( void * This,
            /* [annotation][in] */ 
            _In_  IUnknown *pDevice,
            /* [annotation][in] */ 
            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
            /* [annotation][out] */ 
            _COM_Outptr_  IDXGISwapChain **ppSwapChain);

CreateSwapChain_t g_OldCreateSwapChain = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateSwapChain( void * This,
            /* [annotation][in] */ 
            _In_  IUnknown *pDevice,
            /* [annotation][in] */ 
            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
            /* [annotation][out] */ 
            _COM_Outptr_  IDXGISwapChain **ppSwapChain) {
    HRESULT result = g_OldCreateSwapChain(This, pDevice, pDesc, ppSwapChain);

    if(SUCCEEDED(result) && ppSwapChain && *ppSwapChain) {
        g_pSwapChain = *ppSwapChain;
        if(nullptr == g_OldPresent) {
            void **vtable = *(void***)*ppSwapChain;
            g_OldPresent = (Present_t)vtable[8];
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
            DetourAttach(&(PVOID&)g_OldPresent, New_Present);
            if(NO_ERROR != DetourTransactionCommit()) ErrorBox("Failed to detour IDXGISwapChain::Present.");
        }
    }

    return result;
}

HRESULT WINAPI New_CreateDXGIFactory(REFIID riid, _COM_Outptr_ void **ppFactory);
HRESULT WINAPI New_CreateDXGIFactory1(REFIID riid, _COM_Outptr_ void **ppFactory);

CAfxImportFuncHook<HRESULT(WINAPI*)(REFIID riid, _COM_Outptr_ void **ppFactory)> g_Import_rendersystemdx11_dxgi_CreateDXGIFactory("CreateDXGIFactory", &New_CreateDXGIFactory);
CAfxImportFuncHook<HRESULT(WINAPI*)(REFIID riid, _COM_Outptr_ void **ppFactory)> g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1("CreateDXGIFactory1", &New_CreateDXGIFactory1);

CAfxImportDllHook g_Import_rendersystemdx11_dxgi("dxgi.dll", CAfxImportDllHooks({
	&g_Import_rendersystemdx11_dxgi_CreateDXGIFactory,
    &g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1
    }));

HRESULT WINAPI New_CreateDXGIFactory(REFIID riid, _COM_Outptr_ void **ppFactory) {
    HRESULT result = g_Import_rendersystemdx11_dxgi_CreateDXGIFactory.GetTrueFuncValue()(riid, ppFactory);

    if(SUCCEEDED(result) && ppFactory && *ppFactory
        && ( __uuidof(IDXGIFactory4) == riid || __uuidof(IDXGIFactory) == riid )
        && nullptr == g_OldCreateSwapChain) {
            void **vtable = *(void***)*ppFactory;
            AfxDetourPtr(&(vtable[10]),New_CreateSwapChain,(PVOID*)&g_OldCreateSwapChain);
        }
        
    return result;
}

HRESULT WINAPI New_CreateDXGIFactory1(REFIID riid, _COM_Outptr_ void **ppFactory) {
    HRESULT result = g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1.GetTrueFuncValue()(riid, ppFactory);

    if(SUCCEEDED(result) && ppFactory && *ppFactory
        && ( __uuidof(IDXGIFactory4) == riid || __uuidof(IDXGIFactory) == riid )
        && nullptr == g_OldCreateSwapChain) {
            void **vtable = *(void***)*ppFactory;
            AfxDetourPtr(&(vtable[10]),New_CreateSwapChain,(PVOID*)&g_OldCreateSwapChain);
        }
        
    return result;
}

typedef bool (__fastcall * CRenderDeviceBase_Present_t)(
    void * This, void * Rdx, void * R8d, void * R9d, void * Stack0, void * Stack1, void * Stack2, void * Stack3, void * Stack4);

CRenderDeviceBase_Present_t g_Old_CRenderDeviceBase_Present = nullptr;


CAfxCapture * g_ActiveCapture = nullptr;


bool __fastcall New_CRenderDeviceBase_Present(
    void * This, void * Rdx, void * R8d, void * R9d, void * Stack0, void * Stack1, void * Stack2, void * Stack3, void * Stack4);

std::string g_ViewName("Player 0");
std::string g_ViewPass("GameOverlay");

struct {
    std::shared_timed_mutex m_Mutex;
    std::map<DWORD, ViewPasses_s> m_ThreadToViewPasses;
} g_RenderLayer;

typedef void (__fastcall * Unk_SceneSystem_RenderLayer_t)(void * pThisCSceneSystem,void * param_2,void * pCSceneLayer);
Unk_SceneSystem_RenderLayer_t g_Old_Unk_SceneSystem_RenderLayer = nullptr;
void __fastcall New_Unk_SceneSystem_RenderLayer(void * pThisCSceneSystem,void * param_2,void * pCSceneLayer) {

    int iWaitEventId = *(int*)((unsigned char*)pThisCSceneSystem + 0x30);
    int iLayersLeft = *(int*)((unsigned char*)pThisCSceneSystem+0x48);
    bool bWillSubmitDisplayLists = 2 == iLayersLeft;
    void * pCSceneView = *(void**)((unsigned char *)pCSceneLayer+0x6d0);
    auto fnGetViewLayerName = (const char * (__fastcall *)(void * This))(*(void***)pCSceneView)[0];
    const char * pszViewName = fnGetViewLayerName(pCSceneView);
    const char* pszViewPass = (const char*)pCSceneLayer + 0x4a0;
    unsigned int flags = *(unsigned int *)((unsigned char*)pCSceneLayer + 0x48);
    bool bDepthPassNotShadedPass = 0 != (flags & 0x1000000);
    bool bFullSortNotBatchSort = 0 != (flags & 0x1);

    ViewPass_e viewPass = ViewPass_e::None;
    if(0 == strcmp(pszViewPass, g_ViewPass.c_str()) && 0 == strcmp(pszViewName, g_ViewName.c_str()) && bFullSortNotBatchSort && !bDepthPassNotShadedPass) {
        viewPass = ViewPass_e::BeforeGameOverlay;
    }

    DWORD currentThreadId = 0;
    {
        std::unique_lock<std::shared_timed_mutex> lock(g_RenderLayer.m_Mutex);
        g_RenderLayer.m_ThreadToViewPasses[currentThreadId].Queue.push(viewPass);
    }

    g_Old_Unk_SceneSystem_RenderLayer(pThisCSceneSystem, param_2, pCSceneLayer);
}
/*typedef void(__fastcall* Unk_SceneSystem_SubmitLayers_t)(void* pThisCSceneSystem, void* param_2);
Unk_SceneSystem_SubmitLayers_t g_Old_Unk_SceneSystem_SubmitLayers = nullptr;
void __fastcall New_Unk_SceneSystem_SubmitLayers(void * pThisCSceneSystem,void * param_2) {
    int iBeforeGameOverlayPassCount = -1;
    int passCount = -1;
    {
        std::shared_lock<std::shared_timed_mutex> lock(g_CurrentLayer.m_Mutex);
        auto it = g_CurrentLayer.m_WaitEventIdToViewPasses.find(iWaitEventId);
        if (it != g_CurrentLayer.m_WaitEventIdToViewPasses.end()) {
            auto & viewPasses = it->second;
            while(!viewPasses.Queue.empty()) {
                passCount++;
                if(viewPasses.Queue.front() == ViewPass_e::BeforeGameOverlay) iBeforeGameOverlayPassCount = passCount;
                viewPasses.Queue.pop();
            }
        }
    }

    DWORD currentThreadId;
    if(iBeforeGameOverlayPassCount != -1) {
        currentThreadId = GetCurrentThreadId();
        std::unique_lock<std::shared_timed_mutex> lock(g_CurrentScene.m_Mutex);
        g_CurrentScene.m_ThreadIdToViewPassCount[currentThreadId] = iBeforeGameOverlayPassCount;
    }

    g_Old_Unk_SceneSystem_SubmitLayers(pThisCSceneSystem,param_2);
}*/

typedef unsigned char* (__fastcall* SceneSystem_CreateRenderContextPtr1_t)(unsigned char * param_1, unsigned char param_2, void* pDevice, void * param_4, const char * fmt, ...);
SceneSystem_CreateRenderContextPtr1_t g_Old_SceneSystem_CreateRenderContextPtr1;

extern CConsolePrinter * g_ConsolePrinter;
extern advancedfx::Con_Printf_t Tier0_Message;

class CRenderSystemConsolePrint : public IRenderThreadCallback {
public:
    CRenderSystemConsolePrint(int nr, const char* fmt, va_list args)
        : m_Nr(nr), m_Fmt(fmt)
    {
        size_t m_Print_MemorySize = 0;
        m_Print_Memory = (char*)malloc(sizeof(char) * 63);
        if (nullptr != m_Print_Memory) m_Print_MemorySize = 63;
        else return;
        int chars = vsnprintf(m_Print_Memory, m_Print_MemorySize, fmt, args);
        if (chars < 0) return;
        if (chars >= m_Print_MemorySize) {
            m_Print_Memory = (char*)realloc(m_Print_Memory, sizeof(char) * (chars + 1));
            if (nullptr != m_Print_Memory) m_Print_MemorySize = chars + 1;
            else return;
            vsnprintf(m_Print_Memory, m_Print_MemorySize, fmt, args);
        }
    }

    virtual void OnCallback(void) {
        advancedfx::Message("AFXDEBUG CreateRenderContextPtr%i(%s):%s\n", m_Nr, m_Fmt, m_Print_Memory ? m_Print_Memory : "");
    }

    int m_Nr;
    const char * m_Fmt;
    char* m_Print_Memory = nullptr;

};
/* Typical print on de_mirage:
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#Player 0/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#ParticleSunShadow0/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM0 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM0 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM1 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM1 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM2 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM2 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM3 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM3 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#Player 0/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupGpuCull):#Player 0/SetupGpuCull
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Clear Color Depth Stencil/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ParticleShadowsCollectParticle/LayerClear
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#Csgo3DSkyboxView/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#Csgo3DSkyboxView/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/StencilClear/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Smoke 1/4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Smoke 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (1)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Translucent 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Smoke 1/4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Smoke 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Translucent 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/WaterEffects/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/EffectsOpaque/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/EffectsBloom (Pass 2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOHud/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOMainMenu/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOLoadingScreen/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOPopups/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#PanoramaEngineConsole/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(SubmitAllDisplayLists):SubmitAllDisplayLists
*/

bool g_bRenderContextDebug = false;

unsigned char * __fastcall New_SceneSystem_CreateRenderContextPtr1(unsigned char * param_1, unsigned char param_2, void* pDevice, void * param_4, const char * fmt, ...) {

    // It would be possible to pass vararg on with asm trampoline, but it seems unused?
    unsigned char * result = g_Old_SceneSystem_CreateRenderContextPtr1(param_1,param_2,pDevice,param_4,"Hooked by HLAE / advancedfx.org, if you happen to actually see this please file a bug report, please!");

    //TODO: string comparison is expensive, consider to check string address instead.

    if(g_bRenderContextDebug) {
        const char * saveFmt = fmt ? fmt : "[nullptr]";

        if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
            auto fnQueueCallback = (void(__fastcall*)(void* pCRenderConStextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
            va_list args;
            va_start(args, fmt);
            fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CRenderSystemConsolePrint(1, saveFmt,args));
            va_end(args);
        }
    }

    if (fmt && 0 == strcmp("#%s/%s/LayerClear", fmt)) {
        va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        const char * pszArg1 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("Player 0",pszArg0) && pszArg1) {
            if (0 == strcmp("ClearSmokeTargets (4)", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeDetectSmoke());
                }
            }
            else if (0 == strcmp("ClearSmokeTargets (2)", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackAfterDetectSmoke());
                }
            }
            else if (0 == strcmp("Translucent Forward (MBOIT(2) Smoke 1/2)", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeMaybeDrawSmoke());
                }
            }
            else if (0 == strcmp("WaterEffects", pszArg1)
                || 0 == strcmp("Decals Translucent Depth", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackAfterMaybeSmokeDrawn());
                }
            }

        }
    }  
    else if(fmt && 0 == strcmp("#%s/SetupLightsAndViewConstants",fmt)) {
        /*va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("Player 0",pszArg0)) {
            if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeUi());
            }
        }*/
        va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("CSGOHud",pszArg0)) {
            if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeUi());
            }
        }
    }


    return result;
}

typedef unsigned char* (__fastcall* SceneSystem_CreateRenderContextPtr2_t)(unsigned char* param_1, unsigned char param_2, void* pDevice, const char * fmt, ...);
SceneSystem_CreateRenderContextPtr2_t g_Old_SceneSystem_CreateRenderContextPtr2 = nullptr;
unsigned char * __fastcall New_SceneSystem_CreateRenderContextPtr2(unsigned char *param_1,unsigned char param_2, void* pDevice, const char * fmt, ...) {

    // It would be possible to pass vararg on with asm trampoline, but it seems unused?
    unsigned char * result = g_Old_SceneSystem_CreateRenderContextPtr2(param_1, param_2,pDevice,"Hooked by HLAE / advancedfx.org, if you happen to actually see this please file a bug report, please!");

    if (fmt && 0 == strcmp(fmt, "#%s/SetupView")) {
        va_list args;
        va_start(args, fmt);
        const char* pszArg0 = va_arg(args, const char*);
        if (pszArg0 && 0 == strcmp("Player 0", pszArg0)) {
            if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackSetupViewPlayer0());
            }
        }
    }

    if(g_bRenderContextDebug) {
        const char * saveFmt = fmt ? fmt : "[nullptr]";

        if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
            auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
            va_list args;
            va_start(args, fmt);
            fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CRenderSystemConsolePrint(2, saveFmt, args));
            va_end(args);
        }
    }

    return result;
}

/*
std::string g_ObjectDesc("<unknown>");

void On_CSceneSystem_RenderQueueElement(void * pCSceneObjectDesc, void * pCRenderContextDx11_SoftwareCommandList) {
           
    auto fnGetSceneObjectName = (const char* (__fastcall*)(void* pCSceneObjectDesc))(*(void***)pCSceneObjectDesc)[0];
    const char * pszSceneObjectName = fnGetSceneObjectName(pCSceneObjectDesc);
    advancedfx::Message("AFX: RenderQueueElement: %s\n",pszSceneObjectName);

    if (0 == strcmp(pszSceneObjectName, g_ObjectDesc.c_str())) {
        auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
        fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeUi());
    }

    // Execute the original function call we detoured:
    auto fnRenderElement = (void(__fastcall*)(void* This, void* pCRenderContextDx11_SoftwareCommandList))(*(void***)pCSceneObjectDesc)[10];
    fnRenderElement(pCSceneObjectDesc, pCRenderContextDx11_SoftwareCommandList);
}
*/
CAfxImportsHook g_Import_rendersystemdx11(CAfxImportsHooks({
	&g_Import_rendersystemdx11_dxgi
    }));

#define STRINGIZE(x) STRINGIZE2(x)
#define STRINGIZE2(x) #x
#define MkErrStr(file,line) "Problem in " file ":" STRINGIZE(line)

void Hook_RenderSystemDX11(void * hModule) {
    static bool firstRun = true;

    if(firstRun) {
        firstRun = false;

        if(g_Import_rendersystemdx11.Apply((HMODULE)hModule)) {
            // We have to detour it in-place, because it can be called from elsewhere:
            if(HMODULE hD3D11Dll = GetModuleHandleA("d3d11.dll")) {
                if(g_Old_D3D11CreateDevice = (D3D11CreateDevice_t)GetProcAddress(hD3D11Dll,"D3D11CreateDevice")) {
                    DetourTransactionBegin();
                    DetourUpdateThread(GetCurrentThread());
                    DetourAttach(&(PVOID&)g_Old_D3D11CreateDevice, New_D3D11CreateDevice);
                    if(NO_ERROR == DetourTransactionCommit()) {
                    } else ErrorBox("Failed to hook D3D11CreateDevice.");
                } else ErrorBox("Failed to get D3D11CreateDevice address.");
            } else ErrorBox("Failed to get d3d11.dll module handle.");
        } else ErrorBox("Failed rendersystemdx11 import hooks.");

        Afx::BinUtils::MemRange textRange = Afx::BinUtils::MemRange::FromEmpty();
        Afx::BinUtils::MemRange dataRange = Afx::BinUtils::MemRange::FromEmpty();
        {
            Afx::BinUtils::ImageSectionsReader sections((HMODULE)hModule);
            if(!sections.Eof()) {
                textRange = sections.GetMemRange();
                sections.Next();
                if(!sections.Eof()){
                    dataRange = sections.GetMemRange();
                }
            }
        }

        // CRenderDeviceBase::Present
        //
        // Function jmps into a function that references string "CRenderDeviceBase::Present(640):".
        if(void ** vtable = (void**)Afx::BinUtils::FindClassVtable((HMODULE)hModule,".?AVCRenderDeviceDx11@@", 0, 0x0)) {
            AfxDetourPtr(&(vtable[16]),New_CRenderDeviceBase_Present,(PVOID*)&g_Old_CRenderDeviceBase_Present);
        } else ErrorBox(MkErrStr(__FILE__, __LINE__));
    }

}

void Hook_SceneSystem(void * hModule) {
    static bool firstRun = true;

    if(firstRun) {
        firstRun = false;

		Afx::BinUtils::ImageSectionsReader sections((HMODULE)hModule);
		Afx::BinUtils::MemRange textRange = sections.GetMemRange();

        // See FUN_1800f1b30 doc/notes_cs2/sc_dump_lists.txt.
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "48 8b c4 4c 89 40 18 48 89 50 10 48 89 48 08 55 53 57 48 8d a8 08 fe ff ff 48 81 ec e0 02 00 00");
            if (!result.IsEmpty()) {
                g_Old_Unk_SceneSystem_RenderLayer = (Unk_SceneSystem_RenderLayer_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_Unk_SceneSystem_RenderLayer, New_Unk_SceneSystem_RenderLayer);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }

        // See FUN_1800f8780 doc/notes_cs2/sc_dump_lists.txt.
        /* {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "48 89 5c 24 10 55 56 57 41 54 41 55 41 56 41 57 48 8d 6c 24 d9 48 81 ec a0 00 00 00 4c 8b fa 48 8b d9 e8 ?? ?? ?? ??");
            if (!result.IsEmpty()) {
                g_Old_Unk_SceneSystem_SubmitLayers = (Unk_SceneSystem_SubmitLayers_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_Unk_SceneSystem_SubmitLayers, New_Unk_SceneSystem_SubmitLayers);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }*/

        // First reference to "WARNING: Trying to create a CRenderContextPtr without a valid context.\n"
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "40 53 56 57 48 83 ec 20 49 8b 00 49 8b d8 48 8b f9 45 33 c0 48 8b cb 49 8b f1 ff 90 e0 01 00 00");
            if (!result.IsEmpty()) {
                g_Old_SceneSystem_CreateRenderContextPtr1 = (SceneSystem_CreateRenderContextPtr1_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_SceneSystem_CreateRenderContextPtr1, New_SceneSystem_CreateRenderContextPtr1);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }

        // See FUN_18004aff0 doc/notes_cs2/sc_dump_lists.txt.
        // Second reference to "WARNING: Trying to create a CRenderContextPtr without a valid context.\n"
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "40 55 53 57 48 8d 6c 24 b9 48 81 ec a0 00 00 00 80 65 3d fe 33 c0 49 8b d8 48 89 45 c7 48 89 45 0f 48 8b f9 89 45 2f 48 8b cb 48 89 45 cf 48 89 45 d7 48 89 45 17 48 89 45 df 48 89 45 e7 48 89 45 1f 48 89 45 33 48 89 45 ef 48 89 45 f7 48 89 45 27 48 89 45 ff 48 89 45 07 66 89 45 3b 49 8b 00 45 33 c0 ff 90 e0 01 00 00");
            if (!result.IsEmpty()) {
                g_Old_SceneSystem_CreateRenderContextPtr2 = (SceneSystem_CreateRenderContextPtr2_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_SceneSystem_CreateRenderContextPtr2, New_SceneSystem_CreateRenderContextPtr2);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }
        

        // See "WE WANT TO DETOUR ABOUT HERE" in FUN_1800f8780 in doc/notes_cs2/sc_dump_lists.txt.
        /*
                             LAB_1800f8a80                                   XREF[1]:     1800f8af7(j)  
       1800f8a80 8b c7           MOV        EAX,EDI
       1800f8a82 48 c1 e8 10     SHR        RAX,0x10
       1800f8a86 48 8d 0c 40     LEA        RCX,[RAX + RAX*0x2]
       1800f8a8a 48 8b 83        MOV        RAX,qword ptr [RBX + 0xb10]
                 10 0b 00 00
       1800f8a91 48 8d 14 c8     LEA        RDX,[RAX + RCX*0x8]
       1800f8a95 0f b7 cf        MOVZX      ECX,DI
       1800f8a98 48 8b 42 08     MOV        RAX,qword ptr [RDX + 0x8]
       1800f8a9c 48 03 c9        ADD        RCX,RCX
// BEGIN DETOUR       
       1800f8a9f 48 8b d6        MOV        RDX,RSI
       1800f8aa2 48 8b 4c        MOV        RCX,qword ptr [RAX + RCX*0x8 + 0x8]
                 c8 08
       1800f8aa7 48 8b 01        MOV        RAX,qword ptr [RCX]
       1800f8aaa ff 50 50        CALL       qword ptr [RAX + 0x50]
// END DETOUR
       1800f8aad 4c 63 8b        MOVSXD     R9,dword ptr [RBX + 0xb08]
                 08 0b 00 00        
        */
        /*{
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "8b c7 48 c1 e8 10 48 8d 0c 40 48 8b 83 10 0b 00 00 48 8d 14 c8 0f b7 cf 48 8b 42 08 48 03 c9 48 8b d6 48 8b 4c c8 08 48 8b 01 ff 50 50 4c 63 8b 08 0b 00 00");
            if (!result.IsEmpty()) {
                MdtMemBlockInfos mbis;
                MdtMemAccessBegin((LPVOID)(result.Start+0x1f), 14, &mbis);

                static LPVOID ptr2 = On_CSceneSystem_RenderQueueElement;
                LPVOID ptrPtr2 = &ptr2;
                size_t pCallAddress3 = result.Start+0x1f+14;
                static LPVOID ptr3 = (LPVOID)pCallAddress3;
                LPVOID ptrPtr3 = &ptr3;
                unsigned char asmCode2[32]={
                    0x48, 0x8b, 0xd6,               // MOV        RDX,RSI
                    0x48, 0x8b, 0x4c, 0xc8, 0x08,   // MOV        RCX,qword ptr [RAX + RCX*0x8 + 0x8]

				    0x48, 0xb8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rax, qword addr
				    0xff, 0x10, // call    qword ptr [rax] // call our function

                    0x48, 0xb8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rax, qword addr
                    0xff, 0x20 // jmp [rax] // back to where to continue
                };
                memcpy(&asmCode2[10], &ptrPtr2, sizeof(LPVOID));
                memcpy(&asmCode2[22], &ptrPtr3, sizeof(LPVOID));

                LPVOID pTrampoline = MdtAllocExecuteableMemory(32);
                memcpy(pTrampoline, asmCode2, 32);

                unsigned char asmCode[14]={
                    0x48, 0xba, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rdx, qword addr
                    0xff, 0x22, // jmp [rdx]
                    0x90, // nop
                    0x90 // nop
                };
                static LPVOID ptr = pTrampoline;
                LPVOID ptrPtr = &ptr;
                memcpy(&asmCode[2], &ptrPtr, sizeof(LPVOID));

                memcpy((LPVOID)(result.Start+0x1f), asmCode, 14);
                MdtMemAccessEnd(&mbis);
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }*/
    }
}

void EndCapture() {
    if(g_ActiveCapture) {
        auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
        {
            auto & queue = pRenderPassCommands.AfterPresentOrContextLossReliable;
            CAfxCapture * capture = g_ActiveCapture;
            queue.Push([capture](IRenderPassCommands* context){
                capture->Finish(context->GetContext());
            }); 
        }
        {
            auto & queue = pRenderPassCommands.FinalizeReliable;
            CAfxCapture * capture = g_ActiveCapture;
            queue.Push([capture](){
                delete capture;
            }); 
        }        
        g_ActiveCapture = nullptr;
    }
}

void CreateCapture(class advancedfx::COutVideoStreamCreator* pOutVideoStreamCreator) {
    EndCapture();
    g_ActiveCapture = new CAfxCapture(pOutVideoStreamCreator, false);
}

advancedfx::CImageBufferPoolThreadSafe g_ImageBufferPool;

SOURCESDK::CS2::ConVarHandle Unlock_smoke_volume_lod_ratio_change() {
    static SOURCESDK::CS2::ConVarHandle firstResult;
    static bool bDone = false;
    if (bDone) return firstResult;
    bDone = true;

    for (size_t i = 0; i < 65536; i++)
    {
        SOURCESDK::CS2::Cvar_s* cvar = SOURCESDK::CS2::g_pCVar->GetCvar(i);
        if (nullptr == cvar) break;
        if(nullptr == cvar->m_pszName || 0 != strcmp("smoke_volume_lod_ratio_change", cvar->m_pszName)) continue;
        cvar->m_nFlags &= ~(SOURCESDK::int64)(SOURCESDK_CS2_FCVAR_HIDDEN);
        firstResult.Set(i);
        break;
    }

    return firstResult;
}

float Update_smoke_volume_lod_ratio_change(float value) {
    SOURCESDK::CS2::CVValue_t oldValue = {};
    oldValue.m_flValue = value;

    auto handle = Unlock_smoke_volume_lod_ratio_change();
    if (handle.IsValid()) {
        if (SOURCESDK::CS2::Cvar_s* smoke_volume_lod_ratio_change = SOURCESDK::CS2::g_pCVar->GetCvar(handle.Get())) {
            if (smoke_volume_lod_ratio_change->m_Value.m_flValue != value) {
                oldValue.m_flValue = smoke_volume_lod_ratio_change->m_Value.m_flValue;                
                smoke_volume_lod_ratio_change->m_Value.m_flValue = value;
                SOURCESDK::CS2::g_pCVar->CallChangeCallback(handle, 0, &(smoke_volume_lod_ratio_change->m_Value), &oldValue);
            }
        }
    }
    
    return oldValue.m_flValue;
}

bool Update_r_csgo_mboit_force_mixed_resolution(bool value) {
    SOURCESDK::CS2::CVValue_t oldValue = {};
    oldValue.m_bValue = value;

    auto handle = SOURCESDK::CS2::g_pCVar->FindConVar("r_csgo_mboit_force_mixed_resolution", false);
    if (handle.IsValid()) {
        if (SOURCESDK::CS2::Cvar_s* r_csgo_mboit_force_mixed_resolution = SOURCESDK::CS2::g_pCVar->GetCvar(handle.Get())) {
            if (r_csgo_mboit_force_mixed_resolution->m_Value.m_bValue != value) {
                oldValue.m_bValue = r_csgo_mboit_force_mixed_resolution->m_Value.m_bValue;
                r_csgo_mboit_force_mixed_resolution->m_Value.m_bValue = value;
                SOURCESDK::CS2::g_pCVar->CallChangeCallback(handle, 0, &(r_csgo_mboit_force_mixed_resolution->m_Value), &oldValue);
            }
        }
    }
    return oldValue.m_bValue;
}

class CAfxStreams : public advancedfx::IRecordStreamSettings {
public:
    bool m_CampathAutoSave = false;
	bool m_CamExport = false;
	bool m_CamExportSet = false;

    bool GetCampathAutosave() { return m_CampathAutoSave; }
    void SetCampathAutosave(bool value) { m_CampathAutoSave = value; }

	bool CamExport_get(void) { return m_CamExport;  }
	void CamExport_set(bool value) { m_CamExport = value;  }

    CAfxStreams() {
        m_RecordScreen = new CRecordScreen(false, advancedfx::CRecordingSettings::GetDefault());        
    }

	void ShutDown(void) {
        if(m_Shutdown) return;
        m_Shutdown = true;
		delete m_RecordScreen;
    }    

    ~CAfxStreams(){
        ShutDown();
    }

    const char* GetRecordName() {
        return m_RecordName.c_str();
    }

    void SetRecordName(const char * value) {
        m_RecordName = value;
    }

    bool GetStartMovieWav() {
        return m_StartMovieWav;
    }

    void SetStartMovieWav(bool value) {
        m_StartMovieWav = value;
    }

    bool GetOverrideFps() {
        return m_OverrideFps;
    }

    void SetOverrideFps(bool value) {
        m_OverrideFps = value;
    }

    float GetOverrideFpsValue() {
        return m_OverrideFpsValue;
    }

    void SetOverrideFpsValue(float value) {
        m_OverrideFpsValue = value;
    }

	virtual bool GetStreamFolder(std::wstring& outFolder) const {
        outFolder = m_TakeDir;
        return true;
    }

    const wchar_t * GetTakeDir(void) const {
        return m_TakeDir.c_str();
    }

	virtual advancedfx::StreamCaptureType GetCaptureType() const {
        return m_StreamCaptureType;
    }

    virtual advancedfx::IImageBufferPool * GetImageBufferPool() const {
        return &g_ImageBufferPool;
    }

    virtual bool GetFormatBmpNotTga() const {        
        return m_FormatBmpAndNotTga;
    }

    void SetFormatBmpNotTga(bool value) {
        m_FormatBmpAndNotTga = value;
    }

    void Console_RecordScreen(advancedfx::ICommandArgs* args);

    void Console_Add(advancedfx::ICommandArgs* args);
    void Console_Edit(advancedfx::ICommandArgs* args);
    void Console_Print();
    void Console_Remove(advancedfx::ICommandArgs* args);

    void RecordStart();
    void RecordEnd();

    bool GetRecording() { return m_Recording; }

    void EngineThread_Prepare() {
        if (m_Recording) {
            if (m_AutoForceFullReSmoke) {
                if (!m_Restore_smoke_volume_lod_ratio_change) {
                    m_Old_smoke_volume_lod_ratio_change = Update_smoke_volume_lod_ratio_change(0.0f);
                    if (m_Old_smoke_volume_lod_ratio_change != 0.0f) m_Restore_smoke_volume_lod_ratio_change = true;
                }
                if (!m_Restore_r_csgo_mboit_force_mixed_resolution) {
                    m_Old_r_csgo_mboit_force_mixed_resolution = Update_r_csgo_mboit_force_mixed_resolution(false);
                    if (m_Old_r_csgo_mboit_force_mixed_resolution != false) m_Restore_r_csgo_mboit_force_mixed_resolution = true;
                }
            }
        }
        else {
            m_AutoForceFullReSmoke = false;
            if (m_Restore_smoke_volume_lod_ratio_change) {
                m_Restore_smoke_volume_lod_ratio_change = false;
                Update_smoke_volume_lod_ratio_change(m_Old_smoke_volume_lod_ratio_change);
            }
            if (m_Restore_r_csgo_mboit_force_mixed_resolution) {
                m_Restore_r_csgo_mboit_force_mixed_resolution = false;
                Update_r_csgo_mboit_force_mixed_resolution(m_Old_r_csgo_mboit_force_mixed_resolution);
            }
        }
    }

    void EngineThread_BeginFrame() {
        if(m_Recording) {
            auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();

            if(g_ActiveCapture) {
                {
                    auto & queue = pRenderPassCommands.BeforePresent;
                    CAfxCapture * capture = g_ActiveCapture;
                    queue.Push([capture](IRenderPassCommands* context, ID3D11Texture2D * pTexture){
                        if(!context->GetSkipFrame()) capture->OnBeforeGpuPresent(context->GetContext(), pTexture);
                    }); 
                }
                {
                    auto & queue = pRenderPassCommands.AfterPresent;
                    CAfxCapture * capture = g_ActiveCapture;
                    queue.Push([capture](IRenderPassCommands* context){
                        if (!context->GetSkipFrame()) capture->OnAfterGpuPresent(context->GetContext());
                    }); 
                }
            }
        }

        for(auto it = m_RecordingStreams.begin(); it != m_RecordingStreams.end(); it++) {
            it->EngineThread_Finish();
        }

        if(!m_RecordingStreams.empty()) {
            // ClearBeforeUI is a globally shared setting currently:
            auto & settings = *m_RecordingStreams.begin();
            float clearColor[4];
            if(settings.WantsClearBeforeUi(clearColor)) {
                float R = clearColor[0];
                float G = clearColor[1];
                float B = clearColor[2];
                float A = clearColor[3];  
                auto & renderPassCommands = g_RenderCommands.EngineThread_GetCommands();              
                renderPassCommands.BeforeUi2.Push([R,G,B,A](IRenderPassCommands* context, ID3D11RenderTargetView * pTarget){
                    float clearColor[4] = {R,G,B,A};
                    context->GetContext()->ClearRenderTargetView(pTarget, clearColor);
                });
            }
        }
    }

private:
    class CStream : public advancedfx::IRecordStreamSettings {
	public:
		CStream(CAfxStreams * streams, const CStreamSettings & settings)
			: m_Streams(streams)
            , m_Settings(settings) {

            m_Capture = new CAfxCapture(m_Settings.Settings->CreateOutVideoStreamCreator(
                *this,
                *this,
                m_Streams->m_StartHostFrameRateValue,
                ""
            ), m_Settings.CaptureType == CStreamSettings::CaptureType_e::Rgba);
		}

		~CStream() {
            auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
            {
                auto & queue = pRenderPassCommands.AfterPresentOrContextLossReliable;
                CAfxCapture * capture = m_Capture;
                queue.Push([capture](IRenderPassCommands* context){
                    capture->Finish(context->GetContext());
                }); 
            }
            {
                auto & queue = pRenderPassCommands.FinalizeReliable;
                CAfxCapture * capture = m_Capture;
                queue.Push([capture](){
                    delete capture;
                }); 
            }            
        }

        virtual bool GetStreamFolder(std::wstring& outFolder) const {
            outFolder = m_Streams->GetTakeDir();
            outFolder.append(L"\\");
            outFolder.append(m_Settings.Name);
            return true;
        }
        
        virtual advancedfx::StreamCaptureType GetCaptureType() const {
            switch(m_Settings.CaptureType) {
            case CStreamSettings::CaptureType_e::Rgb:
                return advancedfx::StreamCaptureType::Normal;
            case CStreamSettings::CaptureType_e::Rgba:
                return advancedfx::StreamCaptureType::Normal;
            case CStreamSettings::CaptureType_e::DepthRgb:
                if(m_Settings.Depth24) {
                    if(m_Settings.DepthZip) {
                        return advancedfx::StreamCaptureType::Depth24ZIP;
                    } else {
                        return advancedfx::StreamCaptureType::Depth24;
                    }
                } else {
                    return advancedfx::StreamCaptureType::Normal;
                }
                break;
            case CStreamSettings::CaptureType_e::DepthF:
                if(m_Settings.DepthZip) {
                    return advancedfx::StreamCaptureType::DepthFZIP;
                } else {
                    return advancedfx::StreamCaptureType::DepthF;
                }                
                break;            
            }
            return advancedfx::StreamCaptureType::Invalid;
        }

        virtual  advancedfx::IImageBufferPool * GetImageBufferPool() const {
            return &g_ImageBufferPool;
        }

        virtual bool GetFormatBmpNotTga() const {
            return m_Streams->GetFormatBmpNotTga();
        }

        void EngineThread_Finish() {
            if(nullptr == m_Capture) return;

            auto & renderPassCommands = g_RenderCommands.EngineThread_GetCommands();
            CAfxCapture * capture = m_Capture;
            CStreamSettings::CaptureType_e captureType = m_Settings.CaptureType;
            bool depthCompositeSmoke = m_Settings.DepthCompositeSmoke;
            bool depth24 = m_Settings.Depth24;
            float depthVal = m_Settings.DepthVal;
            float depthValMax = m_Settings.DepthValMax;
            CStreamSettings::DepthChannels_e depthChannels = m_Settings.DepthChannels;
            CStreamSettings::DepthMode_e depthMode = m_Settings.DepthMode;
            {
                auto &queue = m_Settings.Capture == CStreamSettings::Capture_e::BeforeUi ? renderPassCommands.BeforeUi : renderPassCommands.BeforePresent;
                queue.Push([capture,captureType,depthCompositeSmoke,depth24,depthVal,depthValMax,depthChannels,depthMode](IRenderPassCommands* context, ID3D11Texture2D * pTexture){
                    ID3D11DeviceContext* pDeviceContext = context->GetContext();
                    bool bSkipFrame = context->GetSkipFrame();

                    switch(captureType) {
                    case CStreamSettings::CaptureType_e::DepthRgb:
                    case CStreamSettings::CaptureType_e::DepthF: {
                        ShaderCombo_afx_depth_ps_5_0::AFXD24_e afxD24;
                        switch(depthChannels) {
                        case CStreamSettings::DepthChannels_e::SplitRgb:
                            afxD24 = ShaderCombo_afx_depth_ps_5_0::AFXD24_1;
                            break;
                        case CStreamSettings::DepthChannels_e::Dithered:
                            afxD24 = ShaderCombo_afx_depth_ps_5_0::AFXD24_3;
                            break;
                        case CStreamSettings::DepthChannels_e::Gray:
                        default:
                            afxD24 = ShaderCombo_afx_depth_ps_5_0::AFXD24_0;
                            break;
                        }

                        ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_e afxDepthMode;
                        switch(depthMode) {
                        case CStreamSettings::DepthMode_e::Linear:
                            afxDepthMode = ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_1; 
                            break;
                        case CStreamSettings::DepthMode_e::LogE:
                            afxDepthMode = ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_2; 
                            break;
                        case CStreamSettings::DepthMode_e::PyramidalLinear:
                            afxDepthMode = ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_3; 
                            break;
                        case CStreamSettings::DepthMode_e::PyramidalLogE:
                            afxDepthMode = ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_4; 
                            break;
                        case CStreamSettings::DepthMode_e::Inverse:
                        default:
                                afxDepthMode = ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_0; 
                                break;
                        }

                        g_DepthCompositor.CaptureNormalDepth(pDeviceContext, g_pCurrentDepthStencilView,
                            depthCompositeSmoke,
                            captureType == CStreamSettings::CaptureType_e::DepthF ? CDepthCompositor::DepthTextureType_R32F : CDepthCompositor::DepthTextureType_RGB,
                            afxDepthMode,
                            afxD24,
                            depthVal,
                            depthValMax
                        );
        
                        ID3D11RenderTargetView* pRenderTargetViews[1] = {nullptr};
                        ID3D11DepthStencilView* pDepthStencilView = nullptr;
                        pDeviceContext->OMGetRenderTargets(1, &pRenderTargetViews[0], &pDepthStencilView);
        
                        ID3D11Resource* pRenderTargetViewResource = nullptr;
                        if (pRenderTargetViews[0]) pRenderTargetViews[0]->GetResource(&pRenderTargetViewResource);
        
                        if (ID3D11Texture2D* pTexture = g_DepthCompositor.GetDepthTexture(captureType == CStreamSettings::CaptureType_e::DepthF ? CDepthCompositor::DepthTextureType_R32F : CDepthCompositor::DepthTextureType_RGB)) {
                            if(!bSkipFrame) capture->OnBeforeGpuPresent(pDeviceContext, pTexture);
                            pTexture->Release();
                        }// else capture->OnBeforeGpuPresent(pDeviceContext, nullptr);
        
                        if (pRenderTargetViewResource) pRenderTargetViewResource->Release();
        
                        if (pDepthStencilView) pDepthStencilView->Release();
                        if (pRenderTargetViews[0]) pRenderTargetViews[0]->Release();   
                    } break;
                    default:
                        if(!bSkipFrame) capture->OnBeforeGpuPresent(pDeviceContext, pTexture);
                        break;
                    }                 
                }); 
            }
            {
                auto & queue = renderPassCommands.AfterPresent;
                queue.Push([capture](IRenderPassCommands* context){
                    if(!context->GetSkipFrame()) capture->OnAfterGpuPresent(context->GetContext());
                }); 
            }            
        }

        bool WantsClearBeforeUi(float outColor[4]) {
            if(m_Settings.ClearBeforeUi) {
                outColor[0] = m_Settings.ClearBeforeUiColor.R;
                outColor[1] = m_Settings.ClearBeforeUiColor.G;
                outColor[2] = m_Settings.ClearBeforeUiColor.B;
                outColor[3] = m_Settings.ClearBeforeUiColor.A;
                return true;
            }
            return false;
        }

    private:
        CAfxStreams * m_Streams;
        CStreamSettings m_Settings;
        CAfxCapture * m_Capture;
	};

    std::list<CStream> m_RecordingStreams;

    std::map<std::string, CStreamSettings> m_Streams;

    bool m_Shutdown = false;
    advancedfx::StreamCaptureType m_StreamCaptureType = advancedfx::StreamCaptureType::Normal;
    bool m_FormatBmpAndNotTga = false;
    bool m_StartMovieWav = true;
    bool m_OverrideFps = false;
    float m_OverrideFpsValue = 60.0;
    std::string m_RecordName = "untitled_rec";
    
	class CRecordScreen {
	public:
		bool Enabled;
		advancedfx::CRecordingSettings* Settings;

		CRecordScreen(bool enabled, advancedfx::CRecordingSettings* settings)
			: Enabled(enabled)
			, Settings(settings)
		{
			settings->AddRef();
		}

		CRecordScreen(const CRecordScreen& other)
		: Enabled(other.Enabled)
		, Settings(other.Settings) {
			Settings->AddRef();
		}

		~CRecordScreen() {
			Settings->Release();
		}
	};
	CRecordScreen* m_RecordScreen;

    bool m_Recording = false;
    std::wstring m_TakeDir;
    bool m_StartMovieWavUsed = false;
    float m_StartHostFrameRateValue = 60.0;
    
    bool m_UsedHostFramerRateValue = false;
    float m_OldValue_host_framerate;
    bool m_OldValue_r_always_render_all_windows;
    int m_OldValue_engine_no_focus_sleep;

    bool m_AutoForceFullReSmoke = false;

    bool m_CompositeSmoke = false;

    bool m_Restore_smoke_volume_lod_ratio_change = false;
    float m_Old_smoke_volume_lod_ratio_change = 0.6;

    bool m_Restore_r_csgo_mboit_force_mixed_resolution = false;
    bool m_Old_r_csgo_mboit_force_mixed_resolution = false;

    bool Console_CheckStreamName(char const * value)
    {
        if(StringIsEmpty(value))
        {
            advancedfx::Warning("AFXERROR: Stream name can not be empty.\n");
            return false;
        }
        if(!StringIsAlNum(value))
        {
            advancedfx::Warning("AFXERROR: Stream name must be alphanumeric.\n");
            return false;
        }

        // Check if name is unique:
        if(m_Streams.find(value) != m_Streams.end())
        {
            advancedfx::Warning("AFXERROR: Stream name must be unique, \"%s\" is already in use.\n", value);
            return false;
        }

        return true;
    }
} g_AfxStreams;

bool g_bEngine_Prepared = false;

bool __fastcall New_CRenderDeviceBase_Present(
    void * This, void * Rdx, void * R8d, void * R9d, void * Stack0, void * Stack1, void * Stack2, void * Stack3, void * Stack4) {

    g_CampathDrawer.OnEngineThread_EndFrame();

    g_RenderCommands.EngineThread_BeforePresent();

    bool result = g_Old_CRenderDeviceBase_Present(This, Rdx, R8d, R9d, Stack0, Stack1, Stack2, Stack3, Stack4);

    g_RenderCommands.EngineThread_AfterPresent(result);

    g_bEngine_Prepared = false;

    return result;
}

void CAfxStreams::Console_RecordScreen(advancedfx::ICommandArgs* args) {
	int argC = args->ArgC();
	char const* arg0 = args->ArgV(0);

	if (2 <= argC)
	{
		char const* arg1 = args->ArgV(1);
		if (0 == _stricmp(arg1, "enabled")) {
			if (3 <= argC) {
				m_RecordScreen->Enabled = 0 != atoi(args->ArgV(2));
				return;
			}

			advancedfx::Message(
				"%s enabled 0|1 - Disable (0, default) or enable (1) game screen recording.\n"
				"Current value: %i\n"
				, arg0
				, (m_RecordScreen->Enabled?1:0)
			);
			return;
		}
		if (0 == _stricmp(arg1, "settings")) {
			if (3 <= argC)
			{
				char const* arg2 = args->ArgV(2);

				if (advancedfx::CRecordingSettings* settings = advancedfx::CRecordingSettings::GetByName(arg2))
				{
					settings->AddRef();
					m_RecordScreen->Settings->Release();
					m_RecordScreen->Settings = settings;
				}
				else
				{
					advancedfx::Warning("AFXERROR: There is no recording setting named %s\n", arg2);
				}

				return;
			}

			advancedfx::Message(
				"%s settings <name> - Set recording settings to use from mirv_streams settings.\n"
				"Current value: %s\n"
				, arg0
				, m_RecordScreen->Settings->GetName()
			);

			return;
		}
	}

	advancedfx::Message(
		"%s enabled [...] - Enables / disables screen recording.\n"
		"%s settings [...] - Controls recording settings.\n"
		, arg0
		, arg0
	);
}

void CAfxStreams::Console_Add(advancedfx::ICommandArgs* args) {
	int argC = args->ArgC();
	char const* arg0 = args->ArgV(0);

	if (3 <= argC)
	{
        char const* arg1 = args->ArgV(1);
        char const* arg2 = args->ArgV(2);

        CStreamSettings settings(advancedfx::CRecordingSettings::GetDefault());

        if(0 == _stricmp(arg1,"normal")) {

        } else if(0 == _stricmp(arg1,"depth")) {
            settings.Capture = CStreamSettings::Capture_e::BeforeUi;
            settings.CaptureType = CStreamSettings::CaptureType_e::DepthRgb;
        } else {
            advancedfx::Warning("AFXERROR: \"%s\" is not a valid stream template.\n");
            return;
        }
        
        if(!Console_CheckStreamName(arg2)) return;

        if (!UTF8StringToWideString(arg2, settings.Name))
        {
            advancedfx::Warning("AFXERROR: Could not convert \"%s\" from UTF8 to wide string.\n", arg2);
            return;
        }

        m_Streams.emplace(arg2, settings);
        return;
	}

	advancedfx::Message(
		"%s normal|depth <sUiniqueStreamName> - Adds a stream of given type.\n"
		, arg0
	);
}

void CAfxStreams::Console_Edit(advancedfx::ICommandArgs* args) {
	int argC = args->ArgC();
	char const* arg0 = args->ArgV(0);

    if(2 <= argC) {
        char const* arg1 = args->ArgV(1);

        auto it = m_Streams.find(arg1);

        if(it == m_Streams.end()) {
            advancedfx::Warning("AFXERROR: No stream named \"%s\" exists.\n", arg1);
            return;            
        }

        auto &stream = it->second;

        if(3 <= argC) {
            char const* arg2 = args->ArgV(2);

            if(0 == _stricmp("record", arg2)) {
                if(4 <= argC) {
                    stream.Record = 0 != atoi(args->ArgV(3));
                    return;
                }

                advancedfx::Message(
                    "%s %s record 0|1 - Whether to record (1) or not (0).\n"
                    "Current value: %i\n"
                    , arg0, arg1
                    , stream.Record ? 1 : 0
                );
                return;
            } else if(0 == _stricmp("capture", arg2)) {
                if(4 <= argC) {
                    char const* arg3 = args->ArgV(3);

                    if(0 == _stricmp("beforePresent", arg3)) {
                        stream.Capture = CStreamSettings::Capture_e::BeforePresent;
                        return;
                    } else if(0 == _stricmp("beforeUI", arg3)) {
                        stream.Capture = CStreamSettings::Capture_e::BeforeUi;
                        return;
                    }
                }

                const char * currentValue = "[unkown]";
                switch(stream.Capture) {
                case CStreamSettings::Capture_e::BeforePresent:
                    currentValue ="beforePresent";
                    break;
                    case CStreamSettings::Capture_e::BeforeUi:
                    currentValue ="beforeUi";
                    break;
                }

                advancedfx::Message(
                    "%s %s capture beforePresent|beforeUi\n"
                    "\tbeforePresent - Capture the game presents on screen.\n"
                    "\tbeforeUi - Capture before Panorama UI is drawn.\n"
                    "Current value: %s\n"
                    , arg0, arg1
                    , currentValue
                ); 
                return;                 
            } else if (0 == _stricmp("settings", arg2)) {
                if (4 <= argC)
                {
                    char const* arg3 = args->ArgV(3);
    
                    if (advancedfx::CRecordingSettings* settings = advancedfx::CRecordingSettings::GetByName(arg3))
                    {
                        settings->AddRef();
                        stream.Settings->Release();
                        stream.Settings = settings;
                    }
                    else
                    {
                        advancedfx::Warning("AFXERROR: There is no recording setting named %s\n", arg3);
                    }
    
                    return;
                }
    
                advancedfx::Message(
                    "%s settings <name> - Set recording settings to use from mirv_streams settings.\n"
                    "Current value: %s\n"
                    , arg0
                    , stream.Settings->GetName()
                );
    
                return;
            } else if(0 == _stricmp("captureType", arg2)) {
                if(4 <= argC) {
                    char const* arg3 = args->ArgV(3);

                    if(0 == _stricmp("rgb", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::Rgb;
                        return;
                    } else if(0 == _stricmp("beforeUI", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::Rgba;
                        return;
                    } else if(0 == _stricmp("depthRgb", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::DepthRgb;
                        stream.Depth24 = false;
                        return;
                    } else if(0 == _stricmp("depth24", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::DepthRgb;
                        stream.Depth24 = true;
                        stream.DepthZip = false;
                        return;
                    } else if(0 == _stricmp("depthF", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::DepthF;
                        stream.DepthZip = false;
                        return;
                    } else if(0 == _stricmp("depthFZIP", arg3)) {
                        stream.CaptureType = CStreamSettings::CaptureType_e::DepthF;
                        stream.DepthZip = true;
                        return;
                    }
                }

                const char * currentValue = "[unkown]";
                switch(stream.CaptureType) {
                case CStreamSettings::CaptureType_e::Rgb:
                    currentValue ="rgb";
                    break;
                case CStreamSettings::CaptureType_e::Rgba:
                    currentValue ="rgba";
                    break;
                case CStreamSettings::CaptureType_e::DepthRgb:
                    if(stream.Depth24) {
                        if(stream.DepthZip) {
                            currentValue = "depth24ZIP";
                        } else {
                            currentValue = "depth24";
                        }
                    } else {
                        currentValue = "depthRgb";
                    }
                    break;
                case CStreamSettings::CaptureType_e::DepthF:
                    if(stream.DepthZip) {
                        currentValue = "depthFZIP";
                    } else {
                        currentValue = "depthF";
                    }                
                    break;
                }

                advancedfx::Message(
                    "%s %s captureType rgb|rgba|depthRgb|depth24|depth24ZIP|depthF|depthFZIP\n"
                    "\trgb - 3 channels (RGB).\n"
                    "\tgba - 4 channels (RGBA).\n"
                    "\tdepthRgb - Capture depth with 3 channels (RGB).\n"
                    "\tdepth24 - Capture depth with 3 channels (RGB) and tansform to OpenEXR depth (not recommended).\n"
                    "\tdepth24ZIP - Capture depth with 3 channels (RGB) and tansform to compressed OpenEXR depth (not recommended).\n"
                    "\tdepthF - Capture depth with 1 channel to OpenEXR depth.\n"
                    "\tdepthFZIP - Capture depth with 1 channel to compressed OpenEXR depth.\n"
                    "Current value: %s\n"
                    , arg0, arg1
                    , currentValue
                ); 
                return;            
            } else if(0 == _stricmp("depthCompositeSmoke", arg2)) {
                if(4 <= argC) {
                    stream.DepthCompositeSmoke = 0 != atoi(args->ArgV(3));
                    return;
                }

                advancedfx::Message(
                    "%s %s depthCompositeSmoke 0|1 - Whether to composite smoke depth (1) or not (0).\n"
                    "Current value: %i\n"
                    , arg0, arg1
                    , stream.DepthCompositeSmoke ? 1 : 0
                );
                return;
            } else if(0 == _stricmp("depthVal", arg2)) {
                if(4 <= argC) {
                    stream.DepthVal = atof(args->ArgV(3));
                    return;
                }

                advancedfx::Message(
                    "%s %s depthVal <fValue>\n"
                    "Current value: %f\n"
                    , arg0, arg1
                    , stream.DepthVal
                );
                return;
            } else if(0 == _stricmp("depthValMax", arg2)) {
                if(4 <= argC) {
                    stream.DepthValMax = atof(args->ArgV(3));
                    return;
                }

                advancedfx::Message(
                    "%s %s depthValMax <fValue>\n"
                    "Current value: %f\n"
                    , arg0, arg1
                    , stream.DepthValMax
                );
                return;
            } else if(0 == _stricmp("depthChannels", arg2)) {
                if(4 <= argC) {
                    char const* arg3 = args->ArgV(3);

                    if(0 == _stricmp("gray", arg3)) {
                        stream.DepthChannels = CStreamSettings::DepthChannels_e::Gray;
                        return;
                    } else if(0 == _stricmp("splitRgb", arg3)) {
                        stream.DepthChannels = CStreamSettings::DepthChannels_e::SplitRgb;
                        return;
                    } else if(0 == _stricmp("dithered", arg3)) {
                        stream.DepthChannels = CStreamSettings::DepthChannels_e::Dithered;
                        return;
                    }
                }

                const char * currentValue = "[unkown]";
                switch(stream.DepthChannels) {
                case CStreamSettings::DepthChannels_e::Gray:
                    currentValue ="gray";
                    break;
                case CStreamSettings::DepthChannels_e::SplitRgb:
                    currentValue ="splitRgb";
                    break;
                case CStreamSettings::DepthChannels_e::Dithered:
                    currentValue ="dithered";
                    break;
                }

                advancedfx::Message(
                    "%s %s depthChannels gray|splitRgb|dithered\n"
                    "\tgray - Set all 3 channels (RGB) to the same depth value.\n"
                    "\tsplitRgb - Encode depth into 3 channels (RGB).\n"
                    "\tdithered - Dither the depth value into 3 channels (RGB) (similar to https://ReShade.me DrawDepth, reduces perceived bading effects).\n"
                    "Current value: %s\n"
                    , arg0, arg1
                    , currentValue
                ); 
                return;
            } else if(0 == _stricmp("depthMode", arg2)) {
                if(4 <= argC) {
                    char const* arg3 = args->ArgV(3);

                    if(0 == _stricmp("inverse", arg3)) {
                        stream.DepthMode = CStreamSettings::DepthMode_e::Inverse;
                        return;
                    } else if(0 == _stricmp("linear", arg3)) {
                        stream.DepthMode = CStreamSettings::DepthMode_e::Linear;
                        return;
                    } else if(0 == _stricmp("logE", arg3) || 0 == _stricmp("log", arg3)) {
                        stream.DepthMode = CStreamSettings::DepthMode_e::LogE;
                        return;
                    } else if(0 == _stricmp("pyramidalLinear", arg3)) {
                        stream.DepthMode = CStreamSettings::DepthMode_e::PyramidalLinear;
                        return;
                    } else if(0 == _stricmp("pyramidalLogE", arg3) || 0 == _stricmp("pyramidalLog", arg3)) {
                        stream.DepthMode = CStreamSettings::DepthMode_e::PyramidalLogE;
                        return;
                    }
                }

                const char * currentValue = "[unkown]";
                switch(stream.DepthMode) {
                case CStreamSettings::DepthMode_e::Inverse:
                    currentValue ="inverse";
                    break;
                case CStreamSettings::DepthMode_e::Linear:
                    currentValue ="linear";
                    break;
                case CStreamSettings::DepthMode_e::LogE:
                    currentValue ="logE";
                    break;
                    case CStreamSettings::DepthMode_e::PyramidalLinear:
                    currentValue ="pyramidalLinear";
                    break;
                    case CStreamSettings::DepthMode_e::PyramidalLogE:
                    currentValue ="pyramidalLogE";
                    break;
                }

                advancedfx::Message(
                    "%s %s depthMode inverse|linear|logE|pyramidalLinear|pyramidalLogE\n"
                    "\tinverse - Inversed like the game uses.\n"
                    "\tlinear - Linear depth with spherical correction.\n"
                    "\tlogE - Logarithmic depth with spherical correction.\n"
                    "\tpyramidalLinear - Linear depth without spherical correction.\n"
                    "\tpyramidalLogE - Logarithmic depth without spherical correction.\n"
                    "Current value: %s\n"
                    , arg0, arg1
                    , currentValue
                ); 
                return;
            } else if(0 == _stricmp("clearBeforeUI", arg2)) {
                if(4 <= argC) {
                    if(4 == argC) {
                        if(0 == _stricmp("none", args->ArgV(3))) {
                            bool bChanged = false;
                            for(auto it2=m_Streams.begin();it2!=m_Streams.end();it2++) {
                                bChanged = bChanged || it != it2 && it2->second.ClearBeforeUi != false;
                                it2->second.ClearBeforeUi = false;
                            }
                            if(bChanged) {
                                advancedfx::Warning("AFXWarning: Value is globally shared and has been changed on other streams.\n");
                            }
                            return;
                        }
                    } else if(7 == argC) {
                        bool bChanged = false;
                        float r = atof(args->ArgV(3));
                        float g = atof(args->ArgV(4));
                        float b = atof(args->ArgV(5));
                        float a = atof(args->ArgV(6));
                        for(auto it2=m_Streams.begin();it2!=m_Streams.end();it2++) {
                            bChanged = bChanged || it != it2 && (
                                it2->second.ClearBeforeUiColor.R != r
                                || it2->second.ClearBeforeUiColor.G != g
                                || it2->second.ClearBeforeUiColor.B != b
                                || it2->second.ClearBeforeUiColor.A != a
                            );
                            it2->second.ClearBeforeUiColor.R = r;
                            it2->second.ClearBeforeUiColor.G = g;
                            it2->second.ClearBeforeUiColor.B = b;
                            it2->second.ClearBeforeUiColor.A = a;
                        }
                        if(bChanged) {
                            advancedfx::Warning("AFXWarning: Value is globally shared and has been changed on other streams.\n");
                        }
                        return;
                    }
                }

                advancedfx::Message(
                    "%s %s clearBeforeUI none|(<fRed> <fGreen> <fBlue> <fAlpha>) - Whether not to clear (none, default) or in which color (floating point values in range [0.0, 1.0]).\n"
                    "\tAttention: This value is _currently_ globally shared, changeing it for one stream changes it also for all others.\n"
                    , arg0, arg1
                );
                if(!stream.ClearBeforeUi) advancedfx::Message(
                    "Current value: none\n"
                ); else advancedfx::Message(
                        "Current value: %f %f %f %f\n"
                        , stream.ClearBeforeUiColor.R
                        , stream.ClearBeforeUiColor.G
                        , stream.ClearBeforeUiColor.B
                        , stream.ClearBeforeUiColor.A
                );
                return;
            } else if(0 == _stricmp("autoForceFullResSmoke", arg2)) {
                if(4 <= argC) {
                    bool bValue = 0 != atoi(args->ArgV(3));
                    bool bChanged = false;
                    for(auto it2=m_Streams.begin();it2!=m_Streams.end();it2++) {
                        bChanged = bChanged || it != it2 && it2->second.AutoForceFullResSmoke != bValue;
                        it2->second.AutoForceFullResSmoke = bValue;
                    }
                    if(bChanged) {
                        advancedfx::Warning("AFXWarning: Value is globally shared and has been changed on other streams.\n");
                    }
                    return;
                }

                advancedfx::Message(
                    "%s %s autoForceFullResSmoke 0|1\n"
                    "Current value: %i\n"
                    , arg0, arg1
                    , stream.AutoForceFullResSmoke ? 1 : 0
                );
                return;
            }
        }

        advancedfx::Message(
            "%s %s record [...] - Whether to record.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s capture [...] - When to capture.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s settings [...] - Output settings to use.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s captureType  [...] - The type of capture.\n"
            , arg0, arg1
        );        
        advancedfx::Message(
            "%s %s depthCompositeSmoke [...] - If depth capture wheter or not to composite smoke.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s depthVal [...] - Minimum depth value.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s depthValMax [...] - Maximum depth value.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s depthChannels [...] - How to transform depth into color channels.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s depthMode [...] - How transform the depth view.\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s clearBeforeUI  [...] - If and with what color to clear before Panorama UI. (Globally shared!)\n"
            , arg0, arg1
        );
        advancedfx::Message(
            "%s %s autoForceFullResSmoke [...] - When capturing smoke depth: If to force the engine into full resolution smoke passes (recommended). (Globally shared!)\n"
            , arg0, arg1
        );
        return;
    }

	advancedfx::Message(
		"%s <sUiniqueStreamName> [...] - Edit stream with given name.\n"
		, arg0
	);
}


void CAfxStreams::Console_Print() {
	advancedfx::Message(
		"============================================================\n"
		"name (recording preset)\n"
	);
	std::list<std::map<std::string,CStreamSettings>::iterator> streams[3];
	int index = 0;
	for (auto it = m_Streams.begin(); it != m_Streams.end(); it++)
	{
		if(it->second.Record)
			streams[1].emplace_back(it);
		else
			streams[2].emplace_back(it);
		++index;
	}

	for(int i=0;i<3;i++) {
		if(0 == streams[i].size()) continue;
		advancedfx::Message("\n");
		switch(i) {
		case 0:
            advancedfx::Message("[*] PREVIEWING\n");
			break;
		case 1:
            advancedfx::Message("[R] RECORD ON\n");
			break;
		case 2:
            advancedfx::Message("[-] RECORD OFF\n");
			break;
		}
		for(auto it = streams[i].begin(); it != streams[i].end(); it++) {
			const char * streamName = (*it)->first.c_str();
			const char * settingName = "";
			if(advancedfx::CRecordingSettings * setting =  (*it)->second.Settings) {
				settingName = setting->GetName();
			}
			/*if(i == 0 && streams[i].size() > 1 || it->PreviewSlot > 0) {
				Tier0_Msg("%i: %s (%s) @%i\n", it->Index, streamName, settingName, it->PreviewSlot);
			} else*/ {
				advancedfx::Message("%s (%s)\n", streamName, settingName);
			}
		}
	}

	advancedfx::Message(
		"\n"
		"==== Total streams: %i ====\n",
		index
	);
}

void CAfxStreams::Console_Remove(advancedfx::ICommandArgs* args) {
	int argC = args->ArgC();
	char const* arg0 = args->ArgV(0);

    if(2 <= argC) {
        char const* arg1 = args->ArgV(1);

        auto it = m_Streams.find(arg1);

        if(it == m_Streams.end()) {
            advancedfx::Warning("AFXERROR: No stream named \"%s\" exists.\n", arg1);
            return;            
        }

        m_Streams.erase(it);
    }

	advancedfx::Message(
		"%s <sUiniqueStreamName> [...] - Remove stream with given name.\n"
		, arg0
	);
}

void AfxHookSourceRs_Engine_OnRecordStart(const char * take_folder_path);

extern CamPath g_CamPath;

void CAfxStreams::RecordStart()
{
	RecordEnd();

	advancedfx::Message("Starting recording ... ");
	
	if(UTF8StringToWideString(m_RecordName.c_str(), m_TakeDir)
		&& (m_TakeDir.append(L"\\take"), SuggestTakePath(m_TakeDir.c_str(), 4, m_TakeDir))
		&& CreatePath(m_TakeDir.c_str(), m_TakeDir)
	)
	{
		m_Recording = true;
		m_StartMovieWavUsed = false;

		std::string utf8TakeDir;
		bool utf8TakeDirOk = WideStringToUTF8String(m_TakeDir.c_str(), utf8TakeDir);
        SOURCESDK::CS2::Cvar_s * handle_host_framerate = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("host_framerate", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_engine_no_focus_sleep = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("engine_no_focus_sleep", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_r_always_render_all_windows = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("r_always_render_all_windows", false).Get());
        
        m_UsedHostFramerRateValue = GetOverrideFps();

        if(m_UsedHostFramerRateValue && handle_host_framerate) {
            m_OldValue_host_framerate = handle_host_framerate->m_Value.m_flValue;
            handle_host_framerate->m_Value.m_flValue = GetOverrideFpsValue();
        }

        if(handle_engine_no_focus_sleep) {
            m_OldValue_engine_no_focus_sleep = handle_engine_no_focus_sleep->m_Value.m_i32Value;
            handle_engine_no_focus_sleep->m_Value.m_i32Value = 0;
        }

        if(handle_r_always_render_all_windows) {
            m_OldValue_r_always_render_all_windows = handle_r_always_render_all_windows->m_Value.m_bValue;
            handle_r_always_render_all_windows->m_Value.m_bValue = true;
        }

		float host_framerate = m_OverrideFps ? m_OverrideFpsValue : (handle_host_framerate != nullptr ? handle_host_framerate->m_Value.m_flValue : 0);
		double frameTime;
		if (1.0 <= host_framerate) {
			m_StartHostFrameRateValue = host_framerate;
			frameTime = 1.0 / host_framerate;
		}
		else {
			m_StartHostFrameRateValue = host_framerate ? 1.0f / host_framerate : 0.0f;
			frameTime = host_framerate;
		}

		if (0 == frameTime) {
			advancedfx::Warning("You probably forgot to set host_framerate to the FPS you want to record.\n");
			if (nullptr == handle_host_framerate) {
				advancedfx::Warning("You probably forgot to set mirv_streams record fps to the FPS you want to record.\n");
			}
		}

		if(m_CampathAutoSave && 0 < g_CamPath.GetSize())
		{
			std::wstring campathFileName(m_TakeDir);
			campathFileName.append(L"\\campath.xml");
			if(!g_CamPath.Save(campathFileName.c_str()))
				advancedfx::Warning("Error: Failed saving campath.xml to take folder.\n");
		}        

		if (m_CamExport)
		{
			std::wstring camFileName(m_TakeDir);
			camFileName.append(L"\\cam_main.cam");

			m_CamExportSet = true;
			g_S2CamIO.SetCamExport(new CamExport(camFileName.c_str()));
		}

		if(m_RecordScreen->Enabled) {
			CreateCapture(
				m_RecordScreen->Settings->CreateOutVideoStreamCreator(
					*this,
					*this,
					m_StartHostFrameRateValue,
					""
				)
			);
		}

        m_AutoForceFullReSmoke = false;
        m_CompositeSmoke = false;

        for(auto it = m_Streams.begin(); it != m_Streams.end(); it++) {
            if(!it->second.Record) continue;
            m_CompositeSmoke = m_CompositeSmoke || it->second.WantsSmokeComposite();
            m_AutoForceFullReSmoke = m_AutoForceFullReSmoke || it->second.WantsFullResSmoke();
            m_RecordingStreams.emplace_back(this, it->second);
        }

        if (m_CompositeSmoke) {
            auto& pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
            {
                auto& queue = pRenderPassCommands.BeginReliable;
                queue.Push([](IRenderPassCommands*) {
                    g_bCompositeSmoke = true;
                });
            }
            m_CompositeSmoke = false;
        }

		advancedfx::Message("done.\n");

		advancedfx::Message("Recording to \"%s\".\n", utf8TakeDirOk ? utf8TakeDir.c_str() : "?");

		m_StartMovieWavUsed = m_StartMovieWav;

		if (m_StartMovieWavUsed)
		{
            SOURCESDK::CS2::ConCommandHandle handle_startmovie = SOURCESDK::CS2::g_pCVar->FindCommand( "startmovie", false );
            if(handle_startmovie.IsValid()) {
                const char * pszArgs[3] = {"startmovie",ADVANCEDFX_STARTMOVIE_WAV_KEY,"wav"};
                SOURCESDK::CS2::g_pCVar->DispatchConCommand(handle_startmovie, SOURCESDK::CS2::CCommandContext(SOURCESDK::CS2::CT_FIRST_SPLITSCREEN_CLIENT,0), SOURCESDK::CS2::CCommand(3,pszArgs));
            } else advancedfx::Warning("AFXERROR: startmovie command not found, wav recording not possible.");
		}

        AfxHookSourceRs_Engine_OnRecordStart(utf8TakeDirOk ? utf8TakeDir.c_str() : nullptr);
	}
	else
	{
		advancedfx::Message("FAILED");
		advancedfx::Warning("Error: Failed to create directories for \"%s\".\n", m_RecordName.c_str());
	}

}


void AfxHookSourceRs_Engine_OnRecordEnd();

void CAfxStreams::RecordEnd()
{
	if(m_Recording)
	{
        AfxHookSourceRs_Engine_OnRecordEnd();

		advancedfx::Message("Finishing recording ... ");
		if (m_StartMovieWavUsed)
		{
            SOURCESDK::CS2::ConCommandHandle handle_endmovie = SOURCESDK::CS2::g_pCVar->FindCommand( "endmovie", false );
            if(handle_endmovie.IsValid()) {
                const char * pszArgs[1] = {"endmovie"};
                SOURCESDK::CS2::g_pCVar->DispatchConCommand(handle_endmovie, SOURCESDK::CS2::CCommandContext(SOURCESDK::CS2::CT_FIRST_SPLITSCREEN_CLIENT,0), SOURCESDK::CS2::CCommand(1,pszArgs));
            } else advancedfx::Warning("AFXERROR: endmovie command not found, stopping the wav recording not possible.");

		}

		if(m_CamExportSet) {
			m_CamExportSet = false;
			g_S2CamIO.SetCamExport(nullptr);
		}

        m_RecordingStreams.clear();

        if(m_RecordScreen->Enabled) {
            EndCapture();
        }

        if(m_CompositeSmoke) {
            auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
            {
                auto & queue = pRenderPassCommands.FinalizeReliable;
                queue.Push([](){
                    g_bCompositeSmoke = false;
                }); 
            }
            m_CompositeSmoke = false;
        }

        SOURCESDK::CS2::Cvar_s * handle_host_framerate = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("host_framerate", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_engine_no_focus_sleep = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("engine_no_focus_sleep", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_r_always_render_all_windows = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("r_always_render_all_windows", false).Get());

        if(m_UsedHostFramerRateValue && handle_host_framerate) {
            handle_host_framerate->m_Value.m_flValue = m_OldValue_host_framerate;
        }

        if(handle_engine_no_focus_sleep) {
            handle_engine_no_focus_sleep->m_Value.m_i32Value = m_OldValue_engine_no_focus_sleep;
        }

        if(handle_r_always_render_all_windows) {
            handle_r_always_render_all_windows->m_Value.m_bValue = m_OldValue_r_always_render_all_windows;
        }

    	advancedfx::Message("done.\n");
	}

	m_Recording = false;
}

bool AfxStreams_IsRcording() {
    return g_AfxStreams.GetRecording();
}
const wchar_t * AfxStreams_GetTakeDir() {
    return g_AfxStreams.GetTakeDir();
}

bool g_bEngine_ReShade_Enabled = true;
bool g_bEngine_ReShade_FoceSmokeFullresPass = true;

void RenderSystemDX11_EngineThread_Prepare() {
    if (g_bEngine_Prepared) return;
    g_bEngine_Prepared = true;

    if(g_ReShadeAdvancedfx.IsConnected() && g_bEngine_ReShade_Enabled && g_bEngine_ReShade_FoceSmokeFullresPass) {
        Update_smoke_volume_lod_ratio_change(0.0f);
        Update_r_csgo_mboit_force_mixed_resolution(false);
    }

    g_AfxStreams.EngineThread_Prepare();

    {
        auto& pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
        auto& queue = pRenderPassCommands.BeginReliable;
        SOURCESDK::VMatrix projectionMatrix;
        g_EngineThread_ProjectionMatrix.Get(projectionMatrix);
        queue.Push([projectionMatrix](IRenderPassCommands*) {
            g_RenderThread_ProjectionMatrix.Set(projectionMatrix);
        });
    }

    g_AfxStreams.EngineThread_BeginFrame();

    g_RenderCommands.EngineThread_BeginFrame();
}

void RenderSystemDX11_SupplyProjectionMatrix(const SOURCESDK::VMatrix & projectionMatrix) {
    g_EngineThread_ProjectionMatrix.Set(projectionMatrix);
}

CON_COMMAND(mirv_streams, "Access to streams system.")
{
    int argC = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if(2 <= argC)
    {
        const char * cmd1 = args->ArgV(1);

        if(0 == _stricmp(cmd1, "add")) {
            advancedfx::CSubCommandArgs subArgs(args, 2);
            g_AfxStreams.Console_Add(&subArgs);
            return;
        }
        else if(0 == _stricmp(cmd1, "edit")) {
            advancedfx::CSubCommandArgs subArgs(args, 2);
            g_AfxStreams.Console_Edit(&subArgs);
            return;

        }
        else if(0 == _stricmp(cmd1, "remove")) {
            advancedfx::CSubCommandArgs subArgs(args, 2);
            g_AfxStreams.Console_Remove(&subArgs);
            return;

        }
        else if(0 == _stricmp(cmd1, "print")) {
            g_AfxStreams.Console_Print();
            return;

        }          
        else if(0 == _stricmp(cmd1, "record"))
		{
			if(3 <= argC)
			{
				char const * cmd2 = args->ArgV(2);

				if(!_stricmp(cmd2, "name"))
				{
					if(4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);
						g_AfxStreams.SetRecordName(cmd3);
						return;
					}

					advancedfx::Message(
						"mirv_streams record name <name> - Set record name to <name>.\n"
						"Current value: %s.\n",
						g_AfxStreams.GetRecordName()
					);
					return;
				}
				else
				if(!_stricmp(cmd2, "start"))
				{
					g_AfxStreams.RecordStart();
					return;
				}
				else
				if(!_stricmp(cmd2, "end"))
				{
					g_AfxStreams.RecordEnd();
					return;
				}
				else
				if(!_stricmp(cmd2, "format"))
				{
					if(4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);

                        if(0 == _stricmp(cmd3, "bmp")) g_AfxStreams.SetFormatBmpNotTga(true);
                        else if(0 == _stricmp(cmd3, "tga")) g_AfxStreams.SetFormatBmpNotTga(false);
                        else advancedfx::Warning("Error: Invalid format %s\n.", cmd3);

						return;
					}

					advancedfx::Message(
						"mirv_streams record format tga|bmp - Set record format to tga or bmp.\n"
						"Current value: %s.\n",
						g_AfxStreams.GetFormatBmpNotTga() ? "bmp" : "tga"
					);
					return;
				}
				else if (0 == _stricmp(cmd2, "screen"))
				{
					advancedfx::CSubCommandArgs subArgs(args, 3);

					g_AfxStreams.Console_RecordScreen(&subArgs);
					return;
				}
				else
				if (!_stricmp(cmd2, "startMovieWav"))
				{
					if (4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);
						g_AfxStreams.SetStartMovieWav(0 != atoi(cmd3));
						return;
					}

					advancedfx::Message(
						"mirv_streams record startMovieWav 0|1 - Whether to record WAV audio (1) or not (0).\n"
						"Current value: %s.\n",
						g_AfxStreams.GetStartMovieWav() ? "1" : "0"
					);
					return;
				}
				else if (!_stricmp(cmd2, "fps")) {
					if (4 <= argC)
					{
						char const* cmd3 = args->ArgV(3);
						if (0 == _stricmp(cmd3, "default")) {
							g_AfxStreams.SetOverrideFps(false);
							return;
						}
						else if (!StringIsAlphas(cmd3)) {
							g_AfxStreams.SetOverrideFpsValue((float)atof(cmd3));
							g_AfxStreams.SetOverrideFps(true);
							return;
						}
					}

					advancedfx::Message(
						"mirv_streams record fps default|<fValue>\n"
					);
					if (g_AfxStreams.GetOverrideFps()) {
						advancedfx::Message(
							"Current value: %f\n", g_AfxStreams.GetOverrideFpsValue()
						);
					}
					else {
						advancedfx::Message(
							"Current value: default\n"
						);
					}
					return;
				}
                else if (!_stricmp(cmd2, "campath"))
				{
					char const* cmd3 = args->ArgV(3);
					if (4 <= argC)
    				{
      				    char const * cmd3 = args->ArgV(3);
            			if (!_stricmp("enabled", cmd3))
            			{
              				if (5 <= argC)
             				{
                				char const * cmd4 = args->ArgV(4);
               					g_AfxStreams.SetCampathAutosave(0 != atoi(cmd4));
                				return;
              				}

              				advancedfx::Message(
                				"mirv_streams record campath enabled 0|1 - Disable (0) or enable (1).\n"
                				"Current value: %i\n", g_AfxStreams.GetCampathAutosave() ? 1 : 0
              				);

              				return;
            			} 
       				}		
          			advancedfx::Message(
           				"mirv_streams record campath enabled [...]\n"
          			);
          			return;
				}
				else if (!_stricmp(cmd2, "cam"))
				{
					char const* cmd3 = args->ArgV(3);
					if (4 <= argC)
    				{
      				    char const * cmd3 = args->ArgV(3);
            			if (!_stricmp("enabled", cmd3))
            			{
              				if (5 <= argC)
             				{
                				char const * cmd4 = args->ArgV(4);
               					g_AfxStreams.CamExport_set(0 != atoi(cmd4));
                				return;
              				}

              				advancedfx::Message(
                				"mirv_streams record cam enabled 0|1 - Disable (0) or enable (1).\n"
                				"Current value: %i\n", g_AfxStreams.CamExport_get() ? 1 : 0
              				);

              				return;
            			} 
       				}		
          			advancedfx::Message(
           				"mirv_streams record cam enabled [...]\n"
          			);
          			return;
				}
			}

			advancedfx::Message(
				"mirv_streams record name [...] - Set/get record name.\n"
				"mirv_streams record start - Begin recording.\n"
				"mirv_streams record end - End recording.\n"
				"mirv_streams record format [...] - Set/get file format.\n"
				"mirv_streams record fps [...] - Allows to override input FPS for games where we can not detect it (not needed for CS:GO).\n"
			);
			advancedfx::Message(
				"mirv_streams record screen [...] - Controls capturing the game content drawn to screen right before being presented.\n"
				"mirv_streams record startMovieWav [...] - Controls WAV audio recording.\n"
			);
			advancedfx::Message(
				"mirv_streams record cam [...] - Controls the camera motion data capture output (can be imported with mirv_camio).\n"
                "mirv_streams record campath [...] - Save current campath into take folder (if not empty).\n"
			);
			return;
		}
		else if (0 == _stricmp("settings", cmd1))
		{
			advancedfx::CSubCommandArgs subArgs(args, 2);
			advancedfx::CRecordingSettings::Console(&subArgs);
			return;
		}        
    }

    advancedfx::Message(
		"mirv_streams add [...] - Add a stream.\n"
		"mirv_streams edit [...] - Edit a stream.\n"
		"mirv_streams remove [...] - Edit a stream.\n"
		"mirv_streams print - Print current streams.\n"
	);


	advancedfx::Message(
		"mirv_streams record [...] - Recording control.\n"
	);

	advancedfx::Message(
		"mirv_streams settings [...] - Recording settings.\n"
    );
}

CON_COMMAND(mirv_reshade, "Control ReShade_advancedfx ReShade addon.")
{
    if (!g_ReShadeAdvancedfx.IsConnected()) {
        advancedfx::Warning("AFXERROR: ReShade or ReShade_advancedfx.addon not loaded.\n");
        return;
    }

    int argc = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if (2 <= argc)
    {
        char const* cmd1 = args->ArgV(1);

        if (0 == _stricmp("enabled", cmd1)) {
            if (3 <= argc) {
                bool bDoEnableReShade = 0 != atoi(args->ArgV(2));
                if(g_bEngine_ReShade_Enabled != bDoEnableReShade) {
                    g_bEngine_ReShade_Enabled = bDoEnableReShade;

                    auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
                    {
                        auto & queue = pRenderPassCommands.BeginReliable;
                        queue.Push([bDoEnableReShade](IRenderPassCommands*){
                            g_bEnableReShade = bDoEnableReShade;
                        });
                    }
                }
                return;
            }

            advancedfx::Message(
                "%s enabled 0|1 - Enable / disable reshade addon.\n"
                "Current value: %s\n"
                , cmd0
                , g_bEngine_ReShade_Enabled ? "1" : "0"
            );
            return;
        } else if(0 == _stricmp("depthCompositeSmoke", cmd1)) {
            static bool s_bDepthCompositeSmoke = true;
            if(3 <= argc) {
                bool bNewVal = 0 != atoi(args->ArgV(2));
                if(s_bDepthCompositeSmoke != bNewVal) {
                    s_bDepthCompositeSmoke = bNewVal;
                    auto & pRenderPassCommands = g_RenderCommands.EngineThread_GetCommands();
                    {
                        auto & queue = pRenderPassCommands.BeginReliable;
                        queue.Push([bNewVal](IRenderPassCommands*){
                            g_bReShadeCompositeSmoke = bNewVal;
                        });
                    }                    
                }
                return;
            }

            advancedfx::Message(
                "%sdepthCompositeSmoke 0|1 - Whether to composite smoke depth (1) or not (0).\n"
                "Current value: %i\n"
                , cmd0
                , s_bDepthCompositeSmoke ? 1 : 0
            );
            return;
        } else if(0 == _stricmp("forceFullResSmoke", cmd1)) {
            if(3 <= argc) {
                g_bEngine_ReShade_FoceSmokeFullresPass = 0 != atoi(args->ArgV(2));
                return;
            }

            advancedfx::Message(
                "%s forceFullResSmoke 0|1\n"
                "Current value: %i\n"
                , cmd0
                , g_bEngine_ReShade_FoceSmokeFullresPass ? 1 : 0
            );
            return;
        }
    }

    advancedfx::Message(
        "%s enabled [...].\n"
        , cmd0
    );
    advancedfx::Message(
        "%s depthCompositeSmoke [...].\n"
        , cmd0
    );
    advancedfx::Message(
        "%s forceFullResSmoke [...].\n"
        , cmd0
    );
}

/*CON_COMMAND(__mirv_test_object_desc, "")
{
    if(2<= args->ArgC()) {
        g_ObjectDesc = args->ArgV(1);
    }
}*/

/*CON_COMMAND(__mirv_test_20250125, "")
{
    if(3<= args->ArgC()) {
        g_ViewName = args->ArgV(1);
        g_ViewPass = args->ArgV(2);
    }
}*/

CON_COMMAND(__mirv_debug_scenesystem_rendercontexts, "")
{
    int argc = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if(2 <= argc) {
        g_bRenderContextDebug = 0 != atoi(args->ArgV(1));
        return;
    }

    advancedfx::Message(
        "%s 0|1\n"
        "Current value: %i\n"
        , cmd0, g_bRenderContextDebug ? 1 : 0);
}
