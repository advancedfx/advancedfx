#include "stdafx.h"

//TODO: CS:GO Currently does not do CreateStateBlock (adressed) and BeginStateBlock / EndStateblock during live run, but if it did we would need to address the last two. (It does capture though and we address that).

#include "d3d9Hooks.h"

#include "Gui.h"
#include "SourceInterfaces.h"
#include "CampathDrawer.h"
#include "AfxShaders.h"
#include "MirvPgl.h"
#include "AfxInterop.h"
#include "ReShadeAdvancedfx.h"

#include <shared/AfxDetours.h>

#include <shaders/build/afx_depth_ps20.h> // autogenerated
#include <shaders/build/afx_drawtexture_ps20.h> // autogenerated
#include <shaders/build/afx_pgldraw_ps20.h> // autogenerated

#include <iterator>
#include <stack>
#include <set>
#include <map>
#include <list>

#define AFX_GOLDENRATIO 1.618033988749894848204586834365638

typedef struct __declspec(novtable) Interface_s abstract {} * Interface_t;
typedef void * (__stdcall Interface_s::*InterfaceFn_t) (void *);

#define IFACE_PASSTHROUGH_DECL(iface,method) \
	virtual void __stdcall iface ##method(void);

#define IFACE_PASSTHROUGH_DEF(iface,method,className,ifacePtr) \
	 static InterfaceFn_t fn_ ##iface ##method = (InterfaceFn_t)&iface::method; \
	__declspec(naked) void __stdcall className::iface ##method(void) \
	{ \
		__asm MOV EAX, ifacePtr \
		__asm MOV [ESP+4], EAX \
		__asm MOV EAX, fn_ ##iface ##method \
		__asm JMP EAX \
	}


extern bool g_bD3D9DebugPrint;
bool g_bD3D9DumpVertexShader = false;
bool g_bD3D9DumpPixelShader = false;


struct AfxDirtyTrack
{
	bool m_D3DRS_BLENDOP_Dirty = false;
	bool m_D3DRS_SRCBLEND_Dirty = false;
	bool m_D3DRS_DESTBLEND_Dirty = false;
	bool m_D3DRS_SRGBWRITEENABLE_Dirty = false;
	bool m_D3DRS_COLORWRITEENABLE_Dirty = false;
	bool m_D3DRS_ZWRITEENABLE_Dirty = false;
	bool m_D3DRS_ALPHABLENDENABLE_Dirty = false;
	bool m_OriginalValue_ps_c0_Dirty = false;
	bool m_OriginalValue_ps_c5_Dirty = false;
	bool m_OriginalValue_ps_c12_Dirty = false;
	bool m_OriginalValue_ps_c29_Dirty = false;
	bool m_OriginalValue_ps_c31_Dirty = false;
	bool m_OriginalValue_ps_c1_Dirty = false;
	bool m_OriginalValue_ps_c30_Dirty = false;
	bool m_Original_VertexShader_Dirty = false;
	bool m_Original_PixelShader_Dirty = false;
};

class CAfxHookDirect3DStateBlock9 : public IDirect3DStateBlock9
{
public:
	CAfxHookDirect3DStateBlock9(IDirect3DStateBlock9 * parent, const AfxDirtyTrack & dirtyTrack)
	: CreationCallStack(L"n/a (CAfxHookDirect3DStateBlock9)")
	, m_RefCount(1)
	, m_Parent(parent)
	, m_DirtyTrack(dirtyTrack)
	{
	}

    /*** IUnknown methods ***/

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		return m_Parent->QueryInterface(riid, ppvObj);
	}

    STDMETHOD_(ULONG,AddRef)(THIS)
	{
		++m_RefCount;

		return m_RefCount;
	}

    STDMETHOD_(ULONG,Release)(THIS)
	{
		--m_RefCount;

		if (0 == m_RefCount)
		{
			m_Parent->Release();
			delete this;
			return 0;
		}

		return m_RefCount;
	}

    /*** IDirect3DStateBlock9 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_Parent->GetDevice(ppDevice);
	}

	STDMETHOD(Capture)(THIS);

    STDMETHOD(Apply)(THIS);
    
    //#ifdef D3D_DEBUG_INFO
    LPCWSTR CreationCallStack;
    //#endif

protected:

private:
	ULONG m_RefCount;
	IDirect3DStateBlock9 * m_Parent;
	AfxDirtyTrack m_DirtyTrack;

};

UINT g_Adapter = D3DADAPTER_DEFAULT;

void Shared_Direct3DDevice9_Init(
	UINT adapter,
	HWND hDeviceWindow,
	IDirect3DDevice9 * device
)
{
	g_Adapter = adapter;

#ifdef AFX_MIRV_PGL
	MirvPgl::D3D9_BeginDevice(device);
#endif

	AfxHookSource::Gui::On_Direct3DDevice9_Init(hDeviceWindow, device);

	g_AfxShaders.BeginDevice(device);

	g_CampathDrawer.BeginDevice(device);
}

void Shared_Direct3DDevice9_Shutdown()
{
	g_CampathDrawer.EndDevice();

	g_AfxShaders.EndDevice();

	AfxHookSource::Gui::On_Direct3DDevice9_Shutdown();

#ifdef AFX_MIRV_PGL
	MirvPgl::D3D9_EndDevice();
#endif
}

void Shared_Direct3DDevice9_EndScene()
{
	AfxHookSource::Gui::On_Direct3DDevice9_EndScene();
}

ULONG g_NewDirect3DDevice9_RefCount = 1;
IDirect3DDevice9 * g_OldDirect3DDevice9 = nullptr;
IDirect3DDevice9Ex * g_OldDirect3DDevice9Ex = nullptr;

#if 0

// CAfxDirect3DManaged /////////////////////////////////////////////////////////

template <typename T,typename D>
class CAfxDirect3DManaged : public T
{
public:
	D D3DDebugData;

	static void AfxDeviceLost()
	{
		for (typename Instances_t::iterator it = m_Instances.begin(); it != m_Instances.end(); ++it)
		{
			(*it)->OnAfxDeviceLost();
		}
	}

	CAfxDirect3DManaged()
	{
		m_Instances.insert(this);
	}

	T * AfxGetOrCreateUnmanaged(void)
	{
		return OnAfxGetOrCreateUnmanaged();
	}

protected:
	~CAfxDirect3DManaged()
	{
		m_Instances.erase(this);
	}

	virtual void OnAfxDeviceLost() = 0;

	virtual T * OnAfxGetOrCreateUnmanaged() = 0;

private:
	typedef CAfxDirect3DManaged<T,D> Instance_t;
	typedef std::set<typename Instance_t *> Instances_t;

	static typename Instances_t m_Instances;
};

template <typename T, typename D> typename CAfxDirect3DManaged <T, D> ::Instances_t CAfxDirect3DManaged<T, D>::m_Instances;


// CAfxManagedOffscreenPlainSurface ////////////////////////////////////////////

// {ACEC2927-3FED-48B9-8297-69D60550D242}
DEFINE_GUID(IID_CAfxManagedOffscreenPlainSurface,
	0xacec2927, 0x3fed, 0x48b9, 0x82, 0x97, 0x69, 0xd6, 0x5, 0x50, 0xd2, 0x42);

// {ACEC2927-3FED-48B9-8297-69D60550D242}
static const GUID IID_CAfxManagedOffscreenPlainSurface =
{ 0xacec2927, 0x3fed, 0x48b9, { 0x82, 0x97, 0x69, 0xd6, 0x5, 0x50, 0xd2, 0x42 } };

struct CAfxManagedOffscreenPlainSurface_D3DDebugData
{
	LPCWSTR Name;
	UINT Width;
	UINT Height;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	D3DMULTISAMPLE_TYPE MultiSampleType;
	DWORD MultiSampleQuality;
	DWORD Priority;
	UINT LockCount;
	UINT DCCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedOffscreenPlainSurface : public CAfxDirect3DManaged<IDirect3DSurface9, CAfxManagedOffscreenPlainSurface_D3DDebugData>
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedOffscreenPlainSurface == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();
			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DSurface9 methods ***/

	STDMETHOD(GetContainer)(THIS_ REFIID riid, void** ppContainer)
	{
		return m_pSystemMemPool->GetContainer(riid, ppContainer);
	}

	STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc)
	{
		return m_pSystemMemPool->GetDesc(pDesc);
	}

	STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags)
	{
		if(!(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE)))
			this->AddDirtyRect(pRect);

		return m_pSystemMemPool->LockRect(pLockedRect, pRect, Flags);
	}

	STDMETHOD(UnlockRect)(THIS)
	{
		HRESULT result = m_pSystemMemPool->UnlockRect();

		UpdateUnmanaged();

		return result;
	}

	STDMETHOD(GetDC)(THIS_ HDC *phdc)
	{
		return m_pSystemMemPool->GetDC(phdc);
	}

	STDMETHOD(ReleaseDC)(THIS_ HDC hdc)
	{
		return m_pSystemMemPool->ReleaseDC(hdc);
	}



	CAfxManagedOffscreenPlainSurface(
		UINT Width,
		UINT Height,
		DWORD Usage,
		D3DFORMAT Format,
		D3DPOOL Pool,
		D3DMULTISAMPLE_TYPE MultiSampleType,
		DWORD MultiSampleQuality,
		IDirect3DSurface9 * pSystemMemPool
	)
		: m_pSystemMemPool(pSystemMemPool)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name =L"CAfxManagedOffscreenPlainSurface";
		this->D3DDebugData.Width = Width;
		this->D3DDebugData.Height = Height;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.MultiSampleType = MultiSampleType;
		this->D3DDebugData.MultiSampleQuality = MultiSampleQuality;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.DCCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";

		m_DirtyRect.left = this->D3DDebugData.Width;
		m_DirtyRect.top = this->D3DDebugData.Height;
		m_DirtyRect.right = 0;
		m_DirtyRect.bottom = 0;
	}

	HRESULT AddDirtyRect(const RECT *pDirtyRect)
	{
		if (NULL == pDirtyRect)
		{
			m_DirtyRect.left = 0;
			m_DirtyRect.top = 0;
			m_DirtyRect.right = this->D3DDebugData.Width;
			m_DirtyRect.bottom = this->D3DDebugData.Height;
		}
		else if (!m_Dirty)
		{
			m_DirtyRect = *pDirtyRect;
		}
		else
		{
			m_DirtyRect.left = min(m_DirtyRect.left, pDirtyRect->left);
			m_DirtyRect.top = min(m_DirtyRect.top, pDirtyRect->top);
			m_DirtyRect.right = max(m_DirtyRect.right, pDirtyRect->right);
			m_DirtyRect.bottom = max(m_DirtyRect.bottom, pDirtyRect->bottom);
		}

		m_Dirty = true;

		return D3D_OK;
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			IDirect3DDevice9 * device;
			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				POINT point = { m_DirtyRect.left, m_DirtyRect.top };
				device->UpdateSurface(m_pSystemMemPool, &m_DirtyRect, m_pDefaultPool, &point);

				m_DirtyRect.left = this->D3DDebugData.Width;
				m_DirtyRect.top = this->D3DDebugData.Height;
				m_DirtyRect.right = 0;
				m_DirtyRect.bottom = 0;

				m_Dirty = false;

				device->Release();
			}
		}
	}

	virtual IDirect3DSurface9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				if (SUCCEEDED(device->CreateOffscreenPlainSurface(this->D3DDebugData.Width, this->D3DDebugData.Height, this->D3DDebugData.Format, this->D3DDebugData.Pool, &m_pDefaultPool, nullptr)))
				{
					m_pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());

					m_DirtyRect.left = 0;
					m_DirtyRect.top = 0;
					m_DirtyRect.right = this->D3DDebugData.Width;
					m_DirtyRect.bottom = this->D3DDebugData.Height;

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

private:
	bool m_Dirty;
	RECT m_DirtyRect;
	IDirect3DSurface9 * m_pSystemMemPool;
	IDirect3DSurface9 * m_pDefaultPool;
};


// CAfxManagedChildDirect3DSurface9 ////////////////////////////////////////////

class CAfxManagedChildDirect3DSurface9;

class __declspec(novtable) IAfxManagedTexture abstract
{
public:

	/// <summary>Called by child wrapped surface in order to update after device has been lost.</summary>
	/// <param name="surface">The child surface of this texture.</param>
	/// <returns>The new default pool surface if available.</returns>
	virtual IDirect3DSurface9 * AfxManagedChildDirect3DSurface9_GetDefaultPoolSurface(CAfxManagedChildDirect3DSurface9 * surface) = 0;

	virtual void AfxManagedChildDirect3DSurface9_Updated(CAfxManagedChildDirect3DSurface9 * surface) = 0;
};

// {AFF452F9-B129-4B01-85AC-6D7EFD4F1D9D}
DEFINE_GUID(IID_CAfxManagedChildDirect3DSurface9,
	0xaff452f9, 0xb129, 0x4b01, 0x85, 0xac, 0x6d, 0x7e, 0xfd, 0x4f, 0x1d, 0x9d);

// {AFF452F9-B129-4B01-85AC-6D7EFD4F1D9D}
static const GUID IID_CAfxManagedChildDirect3DSurface9 =
{ 0xaff452f9, 0xb129, 0x4b01, { 0x85, 0xac, 0x6d, 0x7e, 0xfd, 0x4f, 0x1d, 0x9d } };

// {F4196378-526C-4EC2-8847-349CC570C75B}
DEFINE_GUID(IID_CAfxManagedChildDirect3DSurface9_ParentData,
	0xf4196378, 0x526c, 0x4ec2, 0x88, 0x47, 0x34, 0x9c, 0xc5, 0x70, 0xc7, 0x5b);

// {F4196378-526C-4EC2-8847-349CC570C75B}
static const GUID IID_CAfxManagedChildDirect3DSurface9_ParentData =
{ 0xf4196378, 0x526c, 0x4ec2, { 0x88, 0x47, 0x34, 0x9c, 0xc5, 0x70, 0xc7, 0x5b } };

struct CAfxManagedChildDirect3DSurface9_D3DDebugData
{
	LPCWSTR Name;
	UINT Width;
	UINT Height;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	D3DMULTISAMPLE_TYPE MultiSampleType;
	DWORD MultiSampleQuality;
	DWORD Priority;
	UINT LockCount;
	UINT DCCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedChildDirect3DSurface9 : public CAfxDirect3DManaged<IDirect3DSurface9, CAfxManagedChildDirect3DSurface9_D3DDebugData>
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedChildDirect3DSurface9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();
			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DSurface9 methods ***/

	STDMETHOD(GetContainer)(THIS_ REFIID riid, void** ppContainer)
	{
		return m_pSystemMemPool->GetContainer(riid, ppContainer);
	}

	STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc)
	{
		return m_pSystemMemPool->GetDesc(pDesc);
	}

	STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags)
	{
		if (!(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE)))
			this->AddDirtyRect(pRect);

		return m_pSystemMemPool->LockRect(pLockedRect, pRect, Flags);
	}

	STDMETHOD(UnlockRect)(THIS)	
	{
		HRESULT result = m_pSystemMemPool->UnlockRect();

		UpdateUnmanaged();

		m_ParentTexture->AfxManagedChildDirect3DSurface9_Updated(this);

		return result;
	}

	STDMETHOD(GetDC)(THIS_ HDC *phdc)
	{
		return m_pSystemMemPool->GetDC(phdc);
	}

	STDMETHOD(ReleaseDC)(THIS_ HDC hdc)
	{
		return m_pSystemMemPool->ReleaseDC(hdc);
	}

	CAfxManagedChildDirect3DSurface9(
		IAfxManagedTexture * parentTexture,
		UINT Width,
		UINT Height,
		DWORD Usage,
		D3DFORMAT Format,
		D3DPOOL Pool,
		D3DMULTISAMPLE_TYPE MultiSampleType,
		DWORD MultiSampleQuality,
		IDirect3DSurface9 * pSystemMemPool
	)
		: m_ParentTexture(parentTexture)
		, m_pSystemMemPool(pSystemMemPool)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name = L"CAfxManagedChildDirect3DSurface9";
		this->D3DDebugData.Width = Width;
		this->D3DDebugData.Height = Height;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.MultiSampleType = MultiSampleType;
		this->D3DDebugData.MultiSampleQuality = MultiSampleQuality;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.DCCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";

		m_DirtyRect.left = this->D3DDebugData.Width;
		m_DirtyRect.top = this->D3DDebugData.Height;
		m_DirtyRect.right = 0;
		m_DirtyRect.bottom = 0;
	}

	HRESULT AddDirtyRect(const RECT *pDirtyRect)
	{
		if (NULL == pDirtyRect)
		{
			m_DirtyRect.left = 0;
			m_DirtyRect.top = 0;
			m_DirtyRect.right = this->D3DDebugData.Width;
			m_DirtyRect.bottom = this->D3DDebugData.Height;
		}
		else if (!m_Dirty)
		{
			m_DirtyRect = *pDirtyRect;
		}
		else
		{
			m_DirtyRect.left = min(m_DirtyRect.left, pDirtyRect->left);
			m_DirtyRect.top = min(m_DirtyRect.top, pDirtyRect->top);
			m_DirtyRect.right = max(m_DirtyRect.right, pDirtyRect->right);
			m_DirtyRect.bottom = max(m_DirtyRect.bottom, pDirtyRect->bottom);
		}

		m_Dirty = true;

		return D3D_OK;
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			IDirect3DDevice9 * device;
			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				POINT point = { m_DirtyRect.left, m_DirtyRect.top };
				device->UpdateSurface(m_pSystemMemPool, &m_DirtyRect, m_pDefaultPool, &point);

				m_DirtyRect.left = this->D3DDebugData.Width;
				m_DirtyRect.top = this->D3DDebugData.Height;
				m_DirtyRect.right = 0;
				m_DirtyRect.bottom = 0;

				m_Dirty = false;

				device->Release();
			}
		}
	}

	virtual IDirect3DSurface9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			m_pDefaultPool = m_ParentTexture->AfxManagedChildDirect3DSurface9_GetDefaultPoolSurface(this);

			m_DirtyRect.left = this->D3DDebugData.Width;
			m_DirtyRect.top = this->D3DDebugData.Height;
			m_DirtyRect.right = 0;
			m_DirtyRect.bottom = 0;

			m_Dirty = false;
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

private:
	bool m_Dirty;
	RECT m_DirtyRect;
	IAfxManagedTexture * m_ParentTexture;
	IDirect3DSurface9 * m_pSystemMemPool;
	IDirect3DSurface9 * m_pDefaultPool;
};

// CAfxManagedDirect3DTexture9 /////////////////////////////////////////////////

// {4E2FC120-3361-4870-9BAD-5288E4EF74F2}
DEFINE_GUID(IID_CAfxManagedDirect3DTexture9,
	0x4e2fc120, 0x3361, 0x4870, 0x9b, 0xad, 0x52, 0x88, 0xe4, 0xef, 0x74, 0xf2);

// {4E2FC120-3361-4870-9BAD-5288E4EF74F2}
static const GUID IID_CAfxManagedDirect3DTexture9 =
{ 0x4e2fc120, 0x3361, 0x4870, { 0x9b, 0xad, 0x52, 0x88, 0xe4, 0xef, 0x74, 0xf2 } };

struct CAfxManagedDirect3DTexture9_D3DDebugData
{
	LPCWSTR Name;
	UINT Width;
	UINT Height;
	UINT Levels;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	DWORD Priority;
	DWORD LOD;
	D3DTEXTUREFILTERTYPE FilterType;
	UINT LockCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedDirect3DTexture9 : public CAfxDirect3DManaged<IDirect3DTexture9, CAfxManagedDirect3DTexture9_D3DDebugData>, protected IAfxManagedTexture
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedDirect3DTexture9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();
			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DBaseTexture9 methods ***/
	STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) {
		if (m_pDefaultPool) m_pDefaultPool->SetLOD(LODNew);

		return m_pSystemMemPool->SetLOD(LODNew);
	}

	STDMETHOD_(DWORD, GetLOD)(THIS)
	{
		return m_pSystemMemPool->GetLOD();
	}

	STDMETHOD_(DWORD, GetLevelCount)(THIS)
	{
		return m_pSystemMemPool->GetLevelCount();
	}

	STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetAutoGenFilterType(FilterType);

		return m_pSystemMemPool->SetAutoGenFilterType(FilterType);
	}

	STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS)
	{
		return m_pSystemMemPool->GetAutoGenFilterType();
	}

	STDMETHOD_(void, GenerateMipSubLevels)(THIS)
	{
		if (m_pDefaultPool) m_pDefaultPool->GenerateMipSubLevels();

		return m_pSystemMemPool->GenerateMipSubLevels();
	}

	/*** IDirect3DTexture9 methods ***/
	STDMETHOD(GetLevelDesc)(THIS_ UINT Level, D3DSURFACE_DESC *pDesc)
	{
		return m_pSystemMemPool->GetLevelDesc(Level, pDesc);
	}

	STDMETHOD(GetSurfaceLevel)(THIS_ UINT Level, IDirect3DSurface9** ppSurfaceLevel)
	{
		if (!ppSurfaceLevel)
			return D3DERR_INVALIDCALL;

		CAfxManagedChildDirect3DSurface9 * manSurf;

		HRESULT result = this->GetManagedSurface(Level, &manSurf);

		if (SUCCEEDED(result))
		{
			*ppSurfaceLevel = manSurf;
		}

		return result;
	}

	STDMETHOD(LockRect)(THIS_ UINT Level, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags)
	{
		HRESULT result = m_pSystemMemPool->LockRect(Level, pLockedRect, pRect, Flags);

		if (SUCCEEDED(result) && 0 == Level)
		{
			++this->D3DDebugData.LockCount;
			m_Dirty = m_Dirty || !(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE));
		}

		return result;
	}

	STDMETHOD(UnlockRect)(THIS_ UINT Level)
	{
		HRESULT result = m_pSystemMemPool->UnlockRect(Level);

		if (SUCCEEDED(result) && 0 == Level)
		{
			--this->D3DDebugData.LockCount;

			UpdateUnmanaged();
		}

		return result;
	}

	STDMETHOD(AddDirtyRect)(THIS_ CONST RECT* pDirtyRect)
	{
		HRESULT result = m_pSystemMemPool->AddDirtyRect(pDirtyRect);

		if (SUCCEEDED(result))
		{
			m_Dirty = true;

			HRESULT result = D3D_OK;

			int levelCount = min(1, this->GetLevelCount()); // D3D9 only tracks dirty on level 0.

			for (int level = 0; level < levelCount; ++level)
			{
				CAfxManagedChildDirect3DSurface9 * surf;

				HRESULT result = this->GetManagedSurface(level, &surf);

				if (FAILED(result))
				{
					surf->Release();
					return result;
				}

				surf->AddDirtyRect(pDirtyRect);
				surf->Release();
			}
		}

		return result;
	}

	CAfxManagedDirect3DTexture9(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, IDirect3DTexture9 * pSystemMemPoolTexture)
		: m_pSystemMemPool(pSystemMemPoolTexture)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name = L"IAfxManagedDirect3DTexture9";
		this->D3DDebugData.Width = Width;
		this->D3DDebugData.Height = Height;
		this->D3DDebugData.Levels = Levels;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.LOD = 0;
		this->D3DDebugData.FilterType = D3DTEXF_NONE;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			IDirect3DDevice9 * device;
			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				device->UpdateTexture(m_pSystemMemPool, m_pDefaultPool);

				m_Dirty = false;

				device->Release();
			}
		}
	}

	virtual IDirect3DTexture9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				IDirect3DTexture9 * pDefaultPool;
				if (SUCCEEDED(device->CreateTexture(this->D3DDebugData.Width, this->D3DDebugData.Height, this->D3DDebugData.Levels, this->D3DDebugData.Usage, this->D3DDebugData.Format, D3DPOOL_DEFAULT, &pDefaultPool, nullptr)))
				{
					m_pDefaultPool = pDefaultPool;

					pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());
					pDefaultPool->SetLOD(m_pSystemMemPool->GetLOD());
					pDefaultPool->SetAutoGenFilterType(m_pSystemMemPool->GetAutoGenFilterType());

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

	virtual IDirect3DSurface9 * AfxManagedChildDirect3DSurface9_GetDefaultPoolSurface(CAfxManagedChildDirect3DSurface9 * surface)
	{
		UINT level = 0;
		DWORD levelSize = sizeof(level);
		IDirect3DSurface9 * surf = NULL;

		m_pDefaultPool = AfxGetOrCreateUnmanaged();

		if (m_pDefaultPool)
		{
			surface->GetPrivateData(IID_CAfxManagedChildDirect3DSurface9_ParentData, &level, &levelSize);

			if (FAILED(m_pDefaultPool->GetSurfaceLevel(level, &surf)))
			{
				surf = NULL;
			}
		}

		return surf;
	}

	virtual void AfxManagedChildDirect3DSurface9_Updated(CAfxManagedChildDirect3DSurface9 * surface)
	{
		m_Dirty = true;

		UpdateUnmanaged();
	}

private:
	bool m_Dirty;
	IDirect3DTexture9 * m_pSystemMemPool;
	IDirect3DTexture9 * m_pDefaultPool;

	STDMETHOD(GetManagedSurface)(THIS_ UINT Level, CAfxManagedChildDirect3DSurface9 ** pManSurf)
	{
		IDirect3DSurface9 * surf;

		HRESULT result = m_pSystemMemPool->GetSurfaceLevel(Level, &surf);

		if (SUCCEEDED(result) && surf)
		{
			CAfxManagedChildDirect3DSurface9 * manSurf;
			DWORD manSurfSize = sizeof(manSurf);

			if (FAILED(surf->GetPrivateData(IID_CAfxManagedChildDirect3DSurface9, &manSurf, &manSurfSize)))
			{
				manSurf = new CAfxManagedChildDirect3DSurface9(
					this,
					this->D3DDebugData.Width,
					this->D3DDebugData.Height,
					this->D3DDebugData.Usage,
					this->D3DDebugData.Format,
					this->D3DDebugData.Pool,
					D3DMULTISAMPLE_NONE,
					0,
					surf
				);

				if (FAILED(manSurf->SetPrivateData(IID_CAfxManagedChildDirect3DSurface9_ParentData, &Level, sizeof(Level), 0))
					|| FAILED(surf->SetPrivateData(IID_CAfxManagedChildDirect3DSurface9, &manSurf, manSurfSize, 0)))
				{
					manSurf->Release();
					surf->Release();
					return D3DERR_NOTAVAILABLE;
				}
			}
			else
			{
				manSurf->AddRef();
				surf->Release();
			}

			*pManSurf = manSurf;
		}

		return result;
	}
};

// CAfxManagedDirect3DVolumeTexture9 ///////////////////////////////////////////

// {7764F7E0-B5C4-4D33-A98B-3BFC145DEF8C}
DEFINE_GUID(IID_CAfxManagedDirect3DVolumeTexture9,
	0x7764f7e0, 0xb5c4, 0x4d33, 0xa9, 0x8b, 0x3b, 0xfc, 0x14, 0x5d, 0xef, 0x8c);


// {7764F7E0-B5C4-4D33-A98B-3BFC145DEF8C}
static const GUID IID_CAfxManagedDirect3DVolumeTexture9 =
{ 0x7764f7e0, 0xb5c4, 0x4d33, { 0xa9, 0x8b, 0x3b, 0xfc, 0x14, 0x5d, 0xef, 0x8c } };

struct CAfxManagedDirect3DVolumeTexture9_D3DDebugData
{
	LPCWSTR Name;
	UINT Width;
	UINT Height;
	UINT Depth;
	UINT Levels;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	DWORD Priority;
	DWORD LOD;
	D3DTEXTUREFILTERTYPE FilterType;
	UINT LockCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedDirect3DVolumeTexture9 : public CAfxDirect3DManaged<IDirect3DVolumeTexture9, CAfxManagedDirect3DVolumeTexture9_D3DDebugData>
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedDirect3DVolumeTexture9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();

			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DBaseTexture9 methods ***/
	STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) {
		if (m_pDefaultPool) m_pDefaultPool->SetLOD(LODNew);

		return m_pSystemMemPool->SetLOD(LODNew);
	}

	STDMETHOD_(DWORD, GetLOD)(THIS)
	{
		return m_pSystemMemPool->GetLOD();
	}

	STDMETHOD_(DWORD, GetLevelCount)(THIS)
	{
		return m_pSystemMemPool->GetLevelCount();
	}

	STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetAutoGenFilterType(FilterType);

		return m_pSystemMemPool->SetAutoGenFilterType(FilterType);
	}

	STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS)
	{
		return m_pSystemMemPool->GetAutoGenFilterType();
	}

	STDMETHOD_(void, GenerateMipSubLevels)(THIS)
	{
		if (m_pDefaultPool) m_pDefaultPool->GenerateMipSubLevels();

		return m_pSystemMemPool->GenerateMipSubLevels();
	}

	/*** IDirect3DVolumeTexture9 methods ***/
	STDMETHOD(GetLevelDesc)(THIS_ UINT Level, D3DVOLUME_DESC *pDesc)
	{
		return m_pSystemMemPool->GetLevelDesc(Level, pDesc);
	}

	STDMETHOD(GetVolumeLevel)(THIS_ UINT Level, IDirect3DVolume9** ppVolumeLevel)
	{
		// TODO: out interface needs to be tracked for changes as well!

		return m_pSystemMemPool->GetVolumeLevel(Level, ppVolumeLevel);
	}

	STDMETHOD(LockBox)(THIS_ UINT Level, D3DLOCKED_BOX* pLockedVolume, CONST D3DBOX* pBox, DWORD Flags)
	{
		m_Dirty = m_Dirty || !(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE));

		return m_pSystemMemPool->LockBox(Level, pLockedVolume, pBox, Flags);
	}

	STDMETHOD(UnlockBox)(THIS_ UINT Level)
	{
		HRESULT result =  m_pSystemMemPool->UnlockBox(Level);

		UpdateUnmanaged();

		return result;
	}

	STDMETHOD(AddDirtyBox)(THIS_ CONST D3DBOX* pDirtyBox)
	{
		m_Dirty = true;

		return m_pSystemMemPool->AddDirtyBox(pDirtyBox);
	}

	CAfxManagedDirect3DVolumeTexture9(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, IDirect3DVolumeTexture9 * pSystemMemPoolTexture)
		: m_pSystemMemPool(pSystemMemPoolTexture)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name = L"IAfxManagedDirect3DVolumeTexture9";
		this->D3DDebugData.Width = Width;
		this->D3DDebugData.Height = Height;
		this->D3DDebugData.Depth = Depth;
		this->D3DDebugData.Levels = Levels;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.LOD = 0;
		this->D3DDebugData.FilterType = D3DTEXF_NONE;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			IDirect3DDevice9 * device;
			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				device->UpdateTexture(m_pSystemMemPool, m_pDefaultPool);

				m_Dirty = false;

				device->Release();
			}
		}
	}

	virtual IDirect3DVolumeTexture9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				IDirect3DVolumeTexture9 * pDefaultPool;
				if (SUCCEEDED(device->CreateVolumeTexture(this->D3DDebugData.Width, this->D3DDebugData.Height, this->D3DDebugData.Depth, this->D3DDebugData.Levels, this->D3DDebugData.Usage, this->D3DDebugData.Format, D3DPOOL_DEFAULT, &pDefaultPool, nullptr)))
				{
					m_pDefaultPool = pDefaultPool;

					pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());
					pDefaultPool->SetLOD(m_pSystemMemPool->GetLOD());
					pDefaultPool->SetAutoGenFilterType(m_pSystemMemPool->GetAutoGenFilterType());

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

private:
	bool m_Dirty;
	IDirect3DVolumeTexture9 * m_pSystemMemPool;
	IDirect3DVolumeTexture9 * m_pDefaultPool;
};


// CAfxManagedDirect3DCubeTexture9 ///////////////////////////////////////////

// {24AA51E7-9575-49D5-A2DF-AF18CB6CC587}
DEFINE_GUID(IID_CAfxManagedDirect3DCubeTexture9,
	0x24aa51e7, 0x9575, 0x49d5, 0xa2, 0xdf, 0xaf, 0x18, 0xcb, 0x6c, 0xc5, 0x87);

// {24AA51E7-9575-49D5-A2DF-AF18CB6CC587}
static const GUID IID_CAfxManagedDirect3DCubeTexture9 =
{ 0x24aa51e7, 0x9575, 0x49d5, { 0xa2, 0xdf, 0xaf, 0x18, 0xcb, 0x6c, 0xc5, 0x87 } };


struct CAfxManagedDirect3DCubeTexture9_D3DDebugData
{
	LPCWSTR Name;
	UINT Width;
	UINT Height;
	UINT Levels;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	DWORD Priority;
	DWORD LOD;
	D3DTEXTUREFILTERTYPE FilterType;
	UINT LockCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedDirect3DCubeTexture9 : public CAfxDirect3DManaged<IDirect3DCubeTexture9, CAfxManagedDirect3DCubeTexture9_D3DDebugData>, protected IAfxManagedTexture
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedDirect3DCubeTexture9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();

			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DBaseTexture9 methods ***/
	STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) {
		if (m_pDefaultPool) m_pDefaultPool->SetLOD(LODNew);

		return m_pSystemMemPool->SetLOD(LODNew);
	}

	STDMETHOD_(DWORD, GetLOD)(THIS)
	{
		return m_pSystemMemPool->GetLOD();
	}

	STDMETHOD_(DWORD, GetLevelCount)(THIS)
	{
		return m_pSystemMemPool->GetLevelCount();
	}

	STDMETHOD(SetAutoGenFilterType)(THIS_ D3DTEXTUREFILTERTYPE FilterType)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetAutoGenFilterType(FilterType);

		return m_pSystemMemPool->SetAutoGenFilterType(FilterType);
	}

	STDMETHOD_(D3DTEXTUREFILTERTYPE, GetAutoGenFilterType)(THIS)
	{
		return m_pSystemMemPool->GetAutoGenFilterType();
	}

	STDMETHOD_(void, GenerateMipSubLevels)(THIS)
	{
		if (m_pDefaultPool) m_pDefaultPool->GenerateMipSubLevels();

		return m_pSystemMemPool->GenerateMipSubLevels();
	}

	/*** IDirect3DCubeTexture9 methods ***/
	STDMETHOD(GetLevelDesc)(THIS_ UINT Level, D3DSURFACE_DESC *pDesc)
	{
		return m_pSystemMemPool->GetLevelDesc(Level, pDesc);
	}

	STDMETHOD(GetCubeMapSurface)(THIS_ D3DCUBEMAP_FACES FaceType, UINT Level, IDirect3DSurface9** ppCubeMapSurface)
	{
		if (nullptr == ppCubeMapSurface)
			return D3DERR_INVALIDCALL;

		CAfxManagedChildDirect3DSurface9 * surf;
		
		HRESULT result = this->GetManagedSurface(FaceType, Level, &surf);

		if (SUCCEEDED(result))
		{
			*ppCubeMapSurface = surf;
		}

		return result;
	}

	STDMETHOD(LockRect)(THIS_ D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT* pLockedRect, CONST RECT* pRect, DWORD Flags)
	{
		HRESULT result = m_pSystemMemPool->LockRect(FaceType, Level, pLockedRect, pRect, Flags);

		if (SUCCEEDED(result))
		{
			m_Dirty = m_Dirty || !(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE));
		}

		return result;
	}

	STDMETHOD(UnlockRect)(THIS_ D3DCUBEMAP_FACES FaceType, UINT Level)
	{
		HRESULT result = m_pSystemMemPool->UnlockRect(FaceType, Level);

		if (SUCCEEDED(result))
		{
		}

		UpdateUnmanaged();

		return result;
	}

	STDMETHOD(AddDirtyRect)(THIS_ D3DCUBEMAP_FACES FaceType, CONST RECT* pDirtyRect)
	{
		m_Dirty = true;

		HRESULT result = D3D_OK;

		int levelCount = min(1,this->GetLevelCount()); // D3D9 only tracks dirty on level 0.

		for (int level = 0; level < levelCount; ++level)
		{
			CAfxManagedChildDirect3DSurface9 * surf;

			HRESULT result = this->GetManagedSurface(FaceType, level, &surf);

			if (FAILED(result))
			{
				surf->Release();
				return result;
			}

			surf->AddDirtyRect(pDirtyRect);
			surf->Release();
		}

		return result;
	}

	CAfxManagedDirect3DCubeTexture9(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, IDirect3DCubeTexture9 * pSystemMemPoolTexture)
		: m_pSystemMemPool(pSystemMemPoolTexture)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name = L"IAfxManagedDirect3DVolumeTexture9";
		this->D3DDebugData.Width = EdgeLength;
		this->D3DDebugData.Height = EdgeLength;
		this->D3DDebugData.Levels = Levels;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.LOD = 0;
		this->D3DDebugData.FilterType = D3DTEXF_NONE;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			IDirect3DDevice9 * device;
			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				device->UpdateTexture(m_pSystemMemPool, m_pDefaultPool);

				m_Dirty = false;

				device->Release();
			}
		}
	}

	virtual IDirect3DCubeTexture9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				IDirect3DCubeTexture9 * pDefaultPool;
				if (SUCCEEDED(device->CreateCubeTexture(this->D3DDebugData.Width, this->D3DDebugData.Levels, this->D3DDebugData.Usage, this->D3DDebugData.Format, D3DPOOL_DEFAULT, &pDefaultPool, nullptr)))
				{
					m_pDefaultPool = pDefaultPool;

					pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());
					pDefaultPool->SetLOD(m_pSystemMemPool->GetLOD());
					pDefaultPool->SetAutoGenFilterType(m_pSystemMemPool->GetAutoGenFilterType());

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

	virtual IDirect3DSurface9 * AfxManagedChildDirect3DSurface9_GetDefaultPoolSurface(CAfxManagedChildDirect3DSurface9 * surface)
	{
		MyCubeSurfaceInfo myCubeSurfaceInfo = { D3DCUBEMAP_FACE_POSITIVE_X, 0 };
		DWORD myCubeSurfaceInfoSize = sizeof(myCubeSurfaceInfo);
		IDirect3DSurface9 * surf = NULL;

		m_pDefaultPool = AfxGetOrCreateUnmanaged();

		if (m_pDefaultPool)
		{
			surface->GetPrivateData(IID_CAfxManagedChildDirect3DSurface9_ParentData, &myCubeSurfaceInfo, &myCubeSurfaceInfoSize);

			if (FAILED(m_pDefaultPool->GetCubeMapSurface(myCubeSurfaceInfo.FaceType, myCubeSurfaceInfo.Level, &surf)))
			{
				surf = NULL;
			}
		}

		return surf;
	}

	virtual void AfxManagedChildDirect3DSurface9_Updated(CAfxManagedChildDirect3DSurface9 * surface)
	{
		m_Dirty = true;

		UpdateUnmanaged();
	}

private:
	struct MyCubeSurfaceInfo
	{
		D3DCUBEMAP_FACES FaceType;
		UINT Level;
	};

	bool m_Dirty;
	IDirect3DCubeTexture9 * m_pSystemMemPool;
	IDirect3DCubeTexture9 * m_pDefaultPool;

	HRESULT GetManagedSurface(THIS_ D3DCUBEMAP_FACES FaceType, UINT Level, CAfxManagedChildDirect3DSurface9 ** pManagedSurface)
	{
		IDirect3DSurface9 * surface = nullptr;

		HRESULT result = m_pSystemMemPool->GetCubeMapSurface(FaceType, Level, &surface);

		if (SUCCEEDED(result))
		{
			CAfxManagedChildDirect3DSurface9 * manSurf;
			DWORD manSurfSize = sizeof(manSurf);

			if (FAILED(surface->GetPrivateData(IID_CAfxManagedChildDirect3DSurface9, &manSurf, &manSurfSize)))
			{
				manSurf = new CAfxManagedChildDirect3DSurface9(
					this,
					this->D3DDebugData.Width,
					this->D3DDebugData.Height,
					this->D3DDebugData.Usage,
					this->D3DDebugData.Format,
					this->D3DDebugData.Pool,
					D3DMULTISAMPLE_NONE,
					0,
					surface
				);

				MyCubeSurfaceInfo myCubeSurfaceInfo = { FaceType , Level };

				if (
					FAILED(manSurf->SetPrivateData(IID_CAfxManagedChildDirect3DSurface9_ParentData, &myCubeSurfaceInfo, sizeof(myCubeSurfaceInfo), 0))
					|| FAILED(surface->SetPrivateData(IID_CAfxManagedChildDirect3DSurface9, &manSurf, manSurfSize, 0)))
				{
					manSurf->Release();
					surface->Release();
					return D3DERR_NOTAVAILABLE;
				}
			}
			else
			{
				manSurf->AddRef();
				surface->Release();
			}

			*pManagedSurface = manSurf;
		}

		return result;
	}
};

// CAfxManagedDirect3DVertexBuffer9 ///////////////////////////////////////////

// {57CDD386-9136-4E22-B215-77792080A04F}
DEFINE_GUID(IID_CAfxManagedDirect3DVertexBuffer9,
	0x57cdd386, 0x9136, 0x4e22, 0xb2, 0x15, 0x77, 0x79, 0x20, 0x80, 0xa0, 0x4f);

// {57CDD386-9136-4E22-B215-77792080A04F}
static const GUID IID_CAfxManagedDirect3DVertexBuffer9 =
{ 0x57cdd386, 0x9136, 0x4e22, { 0xb2, 0x15, 0x77, 0x79, 0x20, 0x80, 0xa0, 0x4f } };

struct CAfxManagedDirect3DVertexBuffer9_D3DDebugData
{
	LPCWSTR Name;
	UINT Length;
	DWORD Usage;
	DWORD FVF;
	D3DPOOL Pool;
	DWORD Priority;
	UINT LockCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedDirect3DVertexBuffer9 : public CAfxDirect3DManaged<IDirect3DVertexBuffer9, CAfxManagedDirect3DVertexBuffer9_D3DDebugData>
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedDirect3DVertexBuffer9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();

			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DVertexBuffer9 methods ***/
	STDMETHOD(Lock)(THIS_ UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags)
	{
		m_Dirty = m_Dirty || !(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE));

		return m_pSystemMemPool->Lock(OffsetToLock, SizeToLock, ppbData, Flags);
	}

	STDMETHOD(Unlock)(THIS)
	{
		HRESULT result = m_pSystemMemPool->Unlock();

		UpdateUnmanaged();

		return result;
	}

	STDMETHOD(GetDesc)(THIS_ D3DVERTEXBUFFER_DESC *pDesc)
	{
		return m_pSystemMemPool->GetDesc(pDesc);
	}

	CAfxManagedDirect3DVertexBuffer9(UINT Length, DWORD Usage, DWORD FVF, IDirect3DVertexBuffer9 * pSystemMemPool)
		: m_pSystemMemPool(pSystemMemPool)
		, m_Dirty(false)
		, m_pDefaultPool(nullptr)
	{
		this->D3DDebugData.Name = L"IAfxManagedDirect3DVertexBuffer9";
		this->D3DDebugData.Length = Length;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.FVF = FVF;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			void * pSource;
			void * pTarget;

			if (SUCCEEDED(m_pSystemMemPool->Lock(0, this->D3DDebugData.Length, &pSource, D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE | D3DLOCK_NO_DIRTY_UPDATE)))
			{
				if (SUCCEEDED(m_pDefaultPool->Lock(0, this->D3DDebugData.Length, &pTarget, 0)))
				{
					memcpy(pTarget, pSource, this->D3DDebugData.Length);
					m_pDefaultPool->Unlock();

					m_Dirty = false;
				}
				m_pSystemMemPool->Unlock();
			}
		}
	}

	virtual IDirect3DVertexBuffer9 * OnAfxGetOrCreateUnmanaged()
	{
		if (nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				IDirect3DVertexBuffer9 * pDefaultPool;
				if (SUCCEEDED(device->CreateVertexBuffer(this->D3DDebugData.Length, this->D3DDebugData.Usage, this->D3DDebugData.FVF, D3DPOOL_DEFAULT, &pDefaultPool, nullptr)))
				{
					m_pDefaultPool = pDefaultPool;

					pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;

	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

private:
	bool m_Dirty;
	IDirect3DVertexBuffer9 * m_pSystemMemPool;
	IDirect3DVertexBuffer9 * m_pDefaultPool;
};


// CAfxManagedDirect3DIndexBuffer9 ///////////////////////////////////////////

// {B8355D17-E24B-4B62-ABA6-C5625791AEC4}
DEFINE_GUID(IID_CAfxManagedDirect3DIndexBuffer9,
	0xb8355d17, 0xe24b, 0x4b62, 0xab, 0xa6, 0xc5, 0x62, 0x57, 0x91, 0xae, 0xc4);

// {B8355D17-E24B-4B62-ABA6-C5625791AEC4}
static const GUID IID_CAfxManagedDirect3DIndexBuffer9 =
{ 0xb8355d17, 0xe24b, 0x4b62, { 0xab, 0xa6, 0xc5, 0x62, 0x57, 0x91, 0xae, 0xc4 } };

struct CAfxManagedDirect3DIndexBuffer9_D3DDebugData
{
	LPCWSTR Name;
	UINT Length;
	DWORD Usage;
	D3DFORMAT Format;
	D3DPOOL Pool;
	DWORD Priority;
	UINT LockCount;
	LPCWSTR CreationCallStack;
};

class CAfxManagedDirect3DIndexBuffer9 : public CAfxDirect3DManaged<IDirect3DIndexBuffer9, CAfxManagedDirect3DIndexBuffer9_D3DDebugData>
{
public:
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxManagedDirect3DIndexBuffer9 == riid && ppvObj)
		{
			*ppvObj = this;
			return D3D_OK;
		}

		return m_pSystemMemPool->QueryInterface(riid, ppvObj);

	}
	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		return m_pSystemMemPool->AddRef();
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		ULONG result = m_pSystemMemPool->Release();

		if (0 == result)
		{
			if (m_pDefaultPool) m_pDefaultPool->Release();

			delete this;
		}

		return result;
	}

	/*** IDirect3DResource9 methods ***/
	STDMETHOD(GetDevice)(THIS_ IDirect3DDevice9** ppDevice)
	{
		return m_pSystemMemPool->GetDevice(ppDevice);
	}

	STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid, CONST void* pData, DWORD SizeOfData, DWORD Flags)
	{
		return m_pSystemMemPool->SetPrivateData(refguid, pData, SizeOfData, Flags);
	}

	STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid, void* pData, DWORD* pSizeOfData)
	{
		return m_pSystemMemPool->GetPrivateData(refguid, pData, pSizeOfData);
	}

	STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid)
	{
		return m_pSystemMemPool->FreePrivateData(refguid);
	}

	STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew)
	{
		if (m_pDefaultPool) m_pDefaultPool->SetPriority(PriorityNew);

		return m_pSystemMemPool->SetPriority(PriorityNew);
	}

	STDMETHOD_(DWORD, GetPriority)(THIS)
	{
		return m_pSystemMemPool->GetPriority();
	}

	STDMETHOD_(void, PreLoad)(THIS)
	{
		AfxGetOrCreateUnmanaged();
	}

	STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS)
	{
		return m_pSystemMemPool->GetType();
	}

	/*** IDirect3DIndexBuffer9 methods ***/
	STDMETHOD(Lock)(THIS_ UINT OffsetToLock, UINT SizeToLock, void** ppbData, DWORD Flags)
	{
		m_Dirty = m_Dirty || !(Flags & (DWORD)(D3DLOCK_NO_DIRTY_UPDATE));

		return m_pSystemMemPool->Lock(OffsetToLock, SizeToLock, ppbData, Flags);
	}

	STDMETHOD(Unlock)(THIS)
	{
		HRESULT result = m_pSystemMemPool->Unlock();

		UpdateUnmanaged();

		return result;
	}

	STDMETHOD(GetDesc)(THIS_ D3DINDEXBUFFER_DESC *pDesc)
	{
		return m_pSystemMemPool->GetDesc(pDesc);
	}

	CAfxManagedDirect3DIndexBuffer9(UINT Length, DWORD Usage, D3DFORMAT Format, IDirect3DIndexBuffer9 * pSystemMemPool)
		: m_pSystemMemPool(pSystemMemPool)
		, m_pDefaultPool(nullptr)
		, m_Dirty(false)
	{
		this->D3DDebugData.Name = L"IAfxManagedDirect3DIndexBuffer9";
		this->D3DDebugData.Length = Length;
		this->D3DDebugData.Usage = Usage;
		this->D3DDebugData.Format = Format;
		this->D3DDebugData.Pool = D3DPOOL_MANAGED;
		this->D3DDebugData.Priority = 0;
		this->D3DDebugData.LockCount = 0;
		this->D3DDebugData.CreationCallStack = L"n/a";
	}

protected:
	void UpdateUnmanaged()
	{
		if (m_pDefaultPool && m_Dirty)
		{
			void * pSource;
			void * pTarget;

			if (SUCCEEDED(m_pSystemMemPool->Lock(0, this->D3DDebugData.Length, &pSource, D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE | D3DLOCK_NO_DIRTY_UPDATE)))
			{
				if (SUCCEEDED(m_pDefaultPool->Lock(0, this->D3DDebugData.Length, &pTarget, 0)))
				{
					memcpy(pTarget, pSource, this->D3DDebugData.Length);
					m_pDefaultPool->Unlock();

					m_Dirty = false;
				}
				m_pSystemMemPool->Unlock();
			}
		}
	}

	virtual IDirect3DIndexBuffer9 * OnAfxGetOrCreateUnmanaged()
	{
		if(nullptr == m_pDefaultPool)
		{
			IDirect3DDevice9 * device;

			if (SUCCEEDED(m_pSystemMemPool->GetDevice(&device)))
			{
				IDirect3DIndexBuffer9 * pDefaultPool;
				if (SUCCEEDED(device->CreateIndexBuffer(this->D3DDebugData.Length, this->D3DDebugData.Usage, this->D3DDebugData.Format, D3DPOOL_DEFAULT, &pDefaultPool, nullptr)))
				{
					m_pDefaultPool = pDefaultPool;

					pDefaultPool->SetPriority(m_pSystemMemPool->GetPriority());

					m_Dirty = true;
				}

				device->Release();
			}
		}

		UpdateUnmanaged();

		return m_pDefaultPool;
	}

	virtual void OnAfxDeviceLost()
	{
		if (m_pDefaultPool)
		{
			m_pDefaultPool->Release();
			m_pDefaultPool = nullptr;
		}
	}

private:
	bool m_Dirty;
	IDirect3DIndexBuffer9 * m_pSystemMemPool;
	IDirect3DIndexBuffer9 * m_pDefaultPool;

};
#endif

////////////////////////////////////////////////////////////////////////////////

bool g_bSupportsIntz = false;

/// <param name="pFixPresentationParameters">MUST NOT BE NULL</param>
void FixPresentationParementers(D3DPRESENT_PARAMETERS* pFixPresentationParameters)
{
#ifdef AFX_INTEROP
	if (AfxInterop::MainEnabled())
	{
		pFixPresentationParameters->MultiSampleType = D3DMULTISAMPLE_NONE;
		pFixPresentationParameters->MultiSampleQuality = 0;
		pFixPresentationParameters->SwapEffect = D3DSWAPEFFECT_DISCARD;
	}
#endif
}

////////////////////////////////////////////////////////////////////////////////

class CAfxIUnknown : public IUnknown
{
public:
	CAfxIUnknown()
		: m_RefCount(1)
	{
	}

	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (ppvObj)
		{
			if (IID_IUnknown == riid)
			{
				*ppvObj = this;
				return S_OK;
			}

			return E_NOINTERFACE;
		}

		return E_POINTER;
	}

	STDMETHOD_(ULONG, AddRef)(THIS)
	{
		++m_RefCount;

		return m_RefCount;
	}

	STDMETHOD_(ULONG, Release)(THIS)
	{
		--m_RefCount;

		if (0 == m_RefCount)
		{
			AfxReleasing();

			delete this;

			return 0;
		}

		return m_RefCount;
	}

protected:
	virtual void AfxReleasing(void) = 0;

private:
	ULONG m_RefCount;
};


// {2CECCAA9-AD5B-4892-8D32-48FFF205B087}
DEFINE_GUID(IID_CAfxTrackedIUnknown,
	0x2ceccaa9, 0xad5b, 0x4892, 0x8d, 0x32, 0x48, 0xff, 0xf2, 0x5, 0xb0, 0x87);

// {2CECCAA9-AD5B-4892-8D32-48FFF205B087}
static const GUID IID_CAfxTrackedIUnknown =
{ 0x2ceccaa9, 0xad5b, 0x4892, { 0x8d, 0x32, 0x48, 0xff, 0xf2, 0x5, 0xb0, 0x87 } };

class CAfxTrackedIUnknown;

class IAfxIUnknownTracker abstract
{
public:
	virtual void AfxTrackedIUnknown_Releasing(CAfxTrackedIUnknown * tracked) = 0;
};

class CAfxTrackedIUnknown : public CAfxIUnknown
{
public:
	CAfxTrackedIUnknown(
		IAfxIUnknownTracker * tracker
	)
		: m_Tracker(tracker)
	{
	}

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_CAfxTrackedIUnknown == riid)
		{
			*ppvObj = this;
			return S_OK;
		}

		return CAfxIUnknown::QueryInterface(riid, ppvObj);
	}

protected:
	virtual void AfxReleasing(void)
	{
		if (m_Tracker)
		{
			m_Tracker->AfxTrackedIUnknown_Releasing(this);
		}
	}

private:
	ULONG m_RefCount;
	IAfxIUnknownTracker * m_Tracker;
};

template <typename T, bool handleRef = false> class CAfxDirect3DResource9Tracker;

template <typename T>
class CAfxDirect3DResource9Tracker<T, false>
	: protected IAfxIUnknownTracker
{
public:
	CAfxDirect3DResource9Tracker()
		: m_Resource(NULL)
		, m_Tracked(NULL)
	{

	}

	T * Resource_get(void)
	{
		return m_Resource;
	}

	void Resource_set(T* value)
	{
		if (m_Resource != value)
		{
			if (m_Resource)
			{
				if (m_Tracked)
				{
					// This can happen if the resource is referenced elsewhere.
					m_Resource->FreePrivateData(IID_CAfxTrackedIUnknown);
				}
			}

			m_Resource = value;

			if (m_Resource)
			{
				m_Tracked = new CAfxTrackedIUnknown(this);
				m_Resource->SetPrivateData(IID_CAfxTrackedIUnknown, (IUnknown *)m_Tracked, sizeof(IUnknown *), D3DSPD_IUNKNOWN);
				m_Tracked->Release();
			}
		}
	}

	~CAfxDirect3DResource9Tracker()
	{
		this->Resource_set(nullptr);
	}

protected:
	virtual void AfxTrackedIUnknown_Releasing(CAfxTrackedIUnknown * tracked)
	{
		if (m_Tracked == tracked)
		{
			m_Tracked = NULL;
			m_Resource = NULL;
		}
	}

private:
	T * m_Resource;
	CAfxTrackedIUnknown * m_Tracked;
};

template <typename T>
class CAfxDirect3DResource9Tracker<T, true>
	: protected IAfxIUnknownTracker
{
public:
	CAfxDirect3DResource9Tracker()
		: m_Resource(NULL)
		, m_Tracked(NULL)
	{

	}

	T * Resource_get(void)
	{
		return m_Resource;
	}

	void Resource_set(T* value)
	{
		if (m_Resource != value)
		{
			if (m_Resource)
			{
				m_Resource->Release();

				if (m_Tracked)
				{
					// This can happen if the resource is referenced elsewhere
					m_Resource->FreePrivateData(IID_CAfxTrackedIUnknown);
				}
			}

			m_Resource = value;

			if (m_Resource)
			{
				m_Resource->AddRef();

				m_Tracked = new CAfxTrackedIUnknown(this);
				m_Resource->SetPrivateData(IID_CAfxTrackedIUnknown, (IUnknown *)m_Tracked, sizeof(IUnknown *), D3DSPD_IUNKNOWN);
				m_Tracked->Release();
			}
		}
	}

	~CAfxDirect3DResource9Tracker()
	{
		this->Resource_set(nullptr);
	}

protected:
	virtual void AfxTrackedIUnknown_Releasing(CAfxTrackedIUnknown * tracked)
	{
		if (m_Tracked == tracked)
		{
			m_Tracked = NULL;
			m_Resource = NULL;
		}
	}

private:
	T * m_Resource;
	CAfxTrackedIUnknown * m_Tracked;
};

////////////////////////////////////////////////////////////////////////////////

// {1F80D4DE-7F7B-4868-B2DD-23DAD78F7619}
DEFINE_GUID(IID_AfxTrackedSurface,
	0x1f80d4de, 0x7f7b, 0x4868, 0xb2, 0xdd, 0x23, 0xda, 0xd7, 0x8f, 0x76, 0x19);

// {1F80D4DE-7F7B-4868-B2DD-23DAD78F7619}
static const GUID IID_AfxTrackedSurface =
{ 0x1f80d4de, 0x7f7b, 0x4868, { 0xb2, 0xdd, 0x23, 0xda, 0xd7, 0x8f, 0x76, 0x19 } };

class CAfxTrackedSurface
	: public CAfxIUnknown
	, public IAfxInteropSurface
{
public:
	static CAfxTrackedSurface * Get(IDirect3DSurface9 * surface)
	{
		CAfxTrackedSurface * result = NULL;

		if (surface)
		{
			IUnknown * data;
			DWORD size = sizeof(IUnknown *);
			if (SUCCEEDED(surface->GetPrivateData(IID_AfxTrackedSurface, &data, &size)))
			{
				if (FAILED(data->QueryInterface(IID_AfxTrackedSurface, (void **)&result)))
				{
					result = NULL;
				}

				data->Release();
			}
		}

		return result;
	}

	static CAfxTrackedSurface * Track(IDirect3DSurface9 * surface)
	{
		CAfxTrackedSurface * result = Get(surface);

		if (NULL == result && surface)
		{
			result = new CAfxTrackedSurface(surface);
		}

		return result;
	}

	static IDirect3DSurface9 * Replacement(IDirect3DSurface9 * surface)
	{
		CAfxTrackedSurface * tracked = Get(surface);

		if (NULL != tracked)
		{
			if (IDirect3DSurface9 * current = tracked->AfxGetCurrentSurface())
			{
				return current;
			}
		}

		return surface;
	}

	static IDirect3DSurface9 * Original(IDirect3DSurface9 * surface)
	{
		CAfxTrackedSurface * tracked = Get(surface);

		if (NULL != tracked)
		{
			if (IDirect3DSurface9 * original = tracked->AfxGetSurface())
			{
				return original;
			}
		}

		return surface;
	}

	CAfxTrackedSurface(
		IDirect3DSurface9 * surface
	)
		: m_Surface(surface)
	{
		surface->SetPrivateData(IID_AfxTrackedSurface, (IUnknown *)this, sizeof(IUnknown *), D3DSPD_IUNKNOWN);
		this->Release();
	}

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj)
	{
		if (IID_AfxTrackedSurface == riid)
		{
			*ppvObj = this;
			return S_OK;
		}

		return CAfxIUnknown::QueryInterface(riid, ppvObj);
	}

	virtual IDirect3DSurface9 * AfxGetSurface()
	{
		return m_Surface;
	}

	virtual void AfxReplacementEnabled_set(bool value)
	{
		m_ReplacementEnabled = value;
	}

	virtual bool AfdxReplacementEnabled_get()
	{
		return m_ReplacementEnabled;
	}

	virtual void AfxSetReplacement(IDirect3DSurface9 * surface)
	{
		if (IDirect3DSurface9 * old = m_Replacement.Resource_get())
		{
			this->AddRef();
			old->FreePrivateData(IID_AfxTrackedSurface);
		}

		if (surface)
		{
			surface->SetPrivateData(IID_AfxTrackedSurface, (IUnknown *)this, sizeof(IUnknown *), D3DSPD_IUNKNOWN);
			this->Release();
		}

		m_Replacement.Resource_set(surface);
	}

	virtual IDirect3DSurface9 * AfxGetReplacement()
	{
		return m_Replacement.Resource_get();
	}

	virtual void AfxSetDepthSurface(IDirect3DSurface9 * surface)
	{
		if (IDirect3DSurface9 * old = m_DepthSurface.Resource_get())
		{
			this->AddRef();
			old->FreePrivateData(IID_AfxTrackedSurface);
		}

		if (surface)
		{
			surface->SetPrivateData(IID_AfxTrackedSurface, (IUnknown *)this, sizeof(IUnknown *), D3DSPD_IUNKNOWN);
			this->Release();
		}

		m_DepthSurface.Resource_set(surface);
	}

	virtual IDirect3DSurface9 * AfxGetDepthSurface()
	{
		return m_DepthSurface.Resource_get();
	}

	virtual IDirect3DSurface9 * AfxGetCurrentSurface()
	{
		IDirect3DSurface9 * result = NULL;

		if (m_ReplacementEnabled) result = m_Replacement.Resource_get();		
		if (NULL == result) result = m_Surface;

		return result;
	}

protected:
	virtual void AfxReleasing(void)
	{
	}

private:
	bool m_ReplacementEnabled = false;
	IDirect3DSurface9 * m_Surface;
	CAfxDirect3DResource9Tracker<IDirect3DSurface9, true> m_Replacement;
	CAfxDirect3DResource9Tracker<IDirect3DSurface9, true> m_DepthSurface;
};

// NewDirect3DDevice9 //////////////////////////////////////////////////////////

// {67523CB6-FC17-4A06-86FA-909ED9A9EE66}
DEFINE_GUID(IID_AfxIntzTexture ,
	0x67523cb6, 0xfc17, 0x4a06, 0x86, 0xfa, 0x90, 0x9e, 0xd9, 0xa9, 0xee, 0x66);

// {67523CB6-FC17-4A06-86FA-909ED9A9EE66}
static const GUID IID_AfxIntzTexture =
{ 0x67523cb6, 0xfc17, 0x4a06, { 0x86, 0xfa, 0x90, 0x9e, 0xd9, 0xa9, 0xee, 0x66 } };

HRESULT GetAfxIntzTexture(IDirect3DSurface9 * surface, IDirect3DTexture9 ** pOut)
{
	HRESULT hr = S_FALSE;
	bool data;
	DWORD size = sizeof(data);
	IDirect3DTexture9 * texture;

	if (surface && pOut)
	{
		hr = surface->GetContainer(__uuidof(IDirect3DTexture9), (void **)&texture);
		if (SUCCEEDED(hr))
		{
			hr = texture->GetPrivateData(IID_AfxIntzTexture, &data, &size);
			if (SUCCEEDED(hr) && data)
			{
				*pOut = texture;
			}
			else
			{
				texture->Release();
			}
		}
	}

	return hr;
}

struct AFXDRAWDEPTHVERTEX
{
	float    pos[3];
	float    uv[2];
};
#define D3DFVF_AFXDRAWDEPTHVERTEX (D3DFVF_XYZ|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE2(0))

struct AFXDRAWGUIDEVERTEX
{
	float    pos[3];
	DWORD    color;
};
#define D3DFVF_AFXDRAWGUIDEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)


// TODO: Wrap / Unwrap swapchaing (low priority)
struct NewDirect3DDevice9
{
private:
	AfxDirtyTrack m_DirtyTrack;

	DWORD m_D3DRS_BLENDOP = D3DBLENDOP_ADD;
	DWORD m_D3DRS_SRCBLEND = D3DBLEND_ONE;
	DWORD m_D3DRS_DESTBLEND = D3DBLEND_ZERO;
	DWORD m_D3DRS_SRGBWRITEENABLE = FALSE;
	DWORD m_D3DRS_COLORWRITEENABLE = TRUE;
	DWORD m_D3DRS_ZWRITEENABLE = TRUE;
	DWORD m_D3DRS_ALPHABLENDENABLE = FALSE;
	float m_OriginalValue_ps_c0[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c5[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c12[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c29[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c31[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c1[4] = { 0, 0, 0, 0 };
	float m_OriginalValue_ps_c30[4] = { 0, 0, 0, 0 };
	IDirect3DVertexShader9 * m_Original_VertexShader = 0;
	IDirect3DPixelShader9 * m_Original_PixelShader = 0;

	bool m_OverrideDefaultBuffersWithIntz = false;

	IDirect3DStateBlock9* m_InitialState = nullptr;
	IDirect3DStateBlock9* m_CurrentState = nullptr;

	CAfxTrackedSurface * trackedRenderTarget = nullptr;
	CAfxTrackedSurface * trackedDepthStencil = nullptr;

	IDirect3DTexture9* r32fRenderTarget = nullptr;

#ifdef AFX_INTEROP
	IDirect3DQuery9 * waitQuery = nullptr;
#endif


#ifdef AFX_INTEROP
	void ReleaseQueries()
	{
		if (AfxInterop::Enabled())
		{
			if (waitQuery)
			{
				waitQuery->Release();
				waitQuery = nullptr;
			}
		}
	}
#endif

#ifdef AFX_INTEROP
	void CreateQueries()
	{
		if (AfxInterop::Enabled())
		{
			if (FAILED(g_OldDirect3DDevice9->CreateQuery(D3DQUERYTYPE_EVENT, &waitQuery)))
				waitQuery = nullptr;
		}
	}
#endif

public:
	void Init(D3DPRESENT_PARAMETERS* pPresentationParameters)
	{
#ifdef AFX_INTEROP
		CreateQueries();
#endif

		HookInitialBuffers();

		if (NULL != m_InitialState)
		{
			m_InitialState->Release();
			m_InitialState = NULL;
		}
		g_OldDirect3DDevice9->CreateStateBlock(D3DSBT_ALL, &m_InitialState);
		if(m_InitialState) m_InitialState->Capture();
	}

	IDirect3DSurface9* AfxGetRenderTargetSurface()
	{
		if (trackedRenderTarget) return trackedRenderTarget->AfxGetCurrentSurface();
		
		return nullptr;
	}

	bool AfxGetSurfaceDesc(IDirect3DSurface9* surface, D3DSURFACE_DESC * pDesc)
	{
		return SUCCEEDED(surface->GetDesc(pDesc)) ? true : false;
	}

	bool AfxSurfaceLockRect(IDirect3DSurface9* surface, D3DLOCKED_RECT* pLockedRect, const RECT* rect, DWORD flags)
	{
		return SUCCEEDED(surface->LockRect(pLockedRect, rect, flags)) ? true : false;
	}

	bool AfxSurfaceUnlockRect(IDirect3DSurface9* surface)
	{
		return SUCCEEDED(surface->UnlockRect()) ? true : false;
	}

	void HookInitialBuffers()
	{
		{
			IDirect3DSurface9 * renderTarget = NULL;
			if (SUCCEEDED(g_OldDirect3DDevice9->GetRenderTarget(0, &renderTarget)))
			{
				trackedRenderTarget = CAfxTrackedSurface::Track(renderTarget);
				trackedRenderTarget->AddRef();

#ifdef AFX_INTEROP
				if (AfxInterop::MainEnabled())
				{
					AfxInterop::OnCreatedSurface(trackedRenderTarget);
				}
#endif

				renderTarget->Release();
			}
		}

		{
			IDirect3DSurface9 * depthStencil = NULL;
			if (SUCCEEDED(g_OldDirect3DDevice9->GetDepthStencilSurface(&depthStencil)))
			{
				trackedDepthStencil = CAfxTrackedSurface::Track(depthStencil);
				trackedDepthStencil->AddRef();

				depthStencil->Release();
			}
		}
	}

#ifdef AFX_INTEROP
	void AfxWaitForGPU()
	{
		if (waitQuery)
		{
			waitQuery->Issue(D3DISSUE_END);

			while (S_FALSE == waitQuery->GetData(NULL, 0, D3DGETDATA_FLUSH))
				;
		}
	}
#endif

	void AfxOverrideDefaultBuffersWithIntz(bool value, bool noReplacement)
	{
		if (m_OverrideDefaultBuffersWithIntz != value)
		{
			// Update:

			m_OverrideDefaultBuffersWithIntz = value;

			// Base RenderTarget:

			if (true
#ifdef AFX_INTEROP
				&& !AfxInterop::MainEnabled()
#endif
				&& !noReplacement)
			{
				// (Re-)Create replacements:

				if (CAfxTrackedSurface * trackedSurface = trackedRenderTarget)
				{
					if (m_OverrideDefaultBuffersWithIntz)
					{

						if (nullptr == trackedSurface->AfxGetReplacement())
						{
							D3DSURFACE_DESC desc;
							if (SUCCEEDED(trackedSurface->AfxGetSurface()->GetDesc(&desc)))
							{
								IDirect3DTexture9 * texture = NULL;
								if (SUCCEEDED(g_OldDirect3DDevice9->CreateTexture(
									desc.Width,
									desc.Height,
									1,
									D3DUSAGE_RENDERTARGET,
									desc.Format,
									D3DPOOL_DEFAULT,
									&texture,
									NULL)))
								{
									IDirect3DSurface9 * replacement = NULL;

									if (SUCCEEDED(texture->GetSurfaceLevel(0, &replacement)))
									{
										trackedSurface->AfxSetReplacement(replacement);
										replacement->Release();
									}

									texture->Release();
								}
							}
						}

						trackedSurface->AfxReplacementEnabled_set(true);
					}
					else
					{
					trackedSurface->AfxReplacementEnabled_set(false);
					}

					// Update current:

					IDirect3DSurface9* renderTarget;

					if (SUCCEEDED(g_OldDirect3DDevice9->GetRenderTarget(0, &renderTarget)))
					{
						if (CAfxTrackedSurface::Get(renderTarget) == trackedSurface)
						{
							IDirect3DSurface9* replacement = CAfxTrackedSurface::Replacement(renderTarget);

							if (replacement != renderTarget)
							{
								g_OldDirect3DDevice9->SetRenderTarget(0, replacement);
							}
						}

						renderTarget->Release();
					}
				}
			}

			// Base DepthStencil:

			{
			// (Re-)Create replacements:

			if (CAfxTrackedSurface* trackedSurface = trackedDepthStencil)
			{
				if (m_OverrideDefaultBuffersWithIntz)
				{
					if (nullptr == trackedSurface->AfxGetReplacement())
					{
						D3DSURFACE_DESC desc;
						if (SUCCEEDED(trackedSurface->AfxGetSurface()->GetDesc(&desc)))
						{
							IDirect3DTexture9* texture = NULL;

							if (SUCCEEDED(g_OldDirect3DDevice9->CreateTexture(
								desc.Width, desc.Height, 1,
								D3DUSAGE_DEPTHSTENCIL, FOURCC_INTZ,
								D3DPOOL_DEFAULT, &texture,
								NULL)))
							{
								IDirect3DSurface9* replacement = NULL;

								if (SUCCEEDED(texture->GetSurfaceLevel(0, &replacement)))
								{
									trackedSurface->AfxSetReplacement(replacement);
									replacement->Release();
								}

								texture->Release();
							}
						}
					}

					trackedSurface->AfxReplacementEnabled_set(true);
				}
				else
				{
					trackedSurface->AfxReplacementEnabled_set(false);
				}

				// Update current:

				IDirect3DSurface9* depthStencil;

				if (SUCCEEDED(g_OldDirect3DDevice9->GetDepthStencilSurface(&depthStencil)))
				{
					if (CAfxTrackedSurface::Get(depthStencil) == trackedSurface)
					{
						IDirect3DSurface9* replacement = CAfxTrackedSurface::Replacement(depthStencil);

						if (replacement != depthStencil)
						{
							g_OldDirect3DDevice9->SetDepthStencilSurface(replacement);
						}
					}
					depthStencil->Release();
				}
			}
			}
		}
	}


	IDirect3DSurface9* AfxSetRenderTargetR32FDepthTexture() {
		if (CAfxTrackedSurface* trackedSurface = trackedDepthStencil) {
			D3DSURFACE_DESC desc;
			if (SUCCEEDED(trackedSurface->AfxGetSurface()->GetDesc(&desc)))
			{
				bool bCreate = nullptr == r32fRenderTarget;

				if (!bCreate && r32fRenderTarget) {
					D3DSURFACE_DESC desc2;
					if (FAILED(r32fRenderTarget->GetLevelDesc(0, &desc2)) || desc2.Width != desc.Width || desc2.Height != desc.Height) {
						r32fRenderTarget->Release();
						r32fRenderTarget = nullptr;
						bCreate = true;
					}
				}

				if (bCreate && FAILED(g_OldDirect3DDevice9->CreateTexture(
					desc.Width, desc.Height, 1,
					D3DUSAGE_RENDERTARGET,
					D3DFMT_R32F,
					D3DPOOL_DEFAULT, &r32fRenderTarget,
					NULL)))
				{
					r32fRenderTarget = nullptr;
				}

				if (r32fRenderTarget) {
					IDirect3DSurface9* surface = nullptr;
					if (SUCCEEDED(r32fRenderTarget->GetSurfaceLevel(0, &surface))) {
						IDirect3DSurface9* oldRenderTarget = NULL;
						if (SUCCEEDED(g_OldDirect3DDevice9->GetRenderTarget(0, &oldRenderTarget))) {
							if (SUCCEEDED(g_OldDirect3DDevice9->SetRenderTarget(0, surface))) {
								surface->Release();
								return oldRenderTarget;
							}
							if (oldRenderTarget) {
								oldRenderTarget->Release();
								oldRenderTarget = nullptr;
							}
						}
						surface->Release();
					}
				}
			}
		}

		return nullptr;
	}

	void AfxSetRenderTargetR32FDepthTexture_Restore(IDirect3DSurface9* renderTarget) {
		g_OldDirect3DDevice9->SetRenderTarget(0, renderTarget);
		if (renderTarget) {
			renderTarget->Release();
		}
	}

	IDirect3DTexture9* AfxGetR32FDepthTexture() {
		return r32fRenderTarget;
	}


	void AfxDrawDepth(AfxDrawDepthEncode encode, AfxDrawDepthMode mode, bool clip, float depthVal, float depthValMax, int x, int y, int width, int height, float zNear, float zFar, bool drawToScreen, float projectionMatrix[4][4])
	{
		if (!g_bSupportsIntz) return;

		if (!m_OverrideDefaultBuffersWithIntz) return;

		ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_e afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_0;

		switch (mode)
		{
		case AfxDrawDepthMode_Inverse:
			afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_0;
			break;
		case AfxDrawDepthMode_Linear:
			afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_1;
			break;
		case AfxDrawDepthMode_LogE:
			afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_2;
			break;
		case AfxDrawDepthMode_PyramidalLinear:
			afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_3;
			break;
		case AfxDrawDepthMode_PyramidalLogE:
			afxDepthMode = ShaderCombo_afx_depth_ps20::AFXDEPTHMODE_4;
			break;
		}

		ShaderCombo_afx_depth_ps20::AFXD24_e afxEncode = ShaderCombo_afx_depth_ps20::AFXD24_0;

		switch (encode)
		{
		case AfxDrawDepthEncode_Gray:
			afxEncode = ShaderCombo_afx_depth_ps20::AFXD24_0;
			break;
		case AfxDrawDepthEncode_Rgb:
			afxEncode = ShaderCombo_afx_depth_ps20::AFXD24_1;
			break;
		case AfxDrawDepthEncode_Rgba:
			afxEncode = ShaderCombo_afx_depth_ps20::AFXD24_2;
			break;
		}

		IAfxPixelShader * afxPixelShader = g_AfxShaders.GetAcsPixelShader(L"afx_depth_ps20.acs", ShaderCombo_afx_depth_ps20::GetCombo(
			clip ? ShaderCombo_afx_depth_ps20::AFXCLIP_1 : ShaderCombo_afx_depth_ps20::AFXCLIP_0,
			afxDepthMode,
			afxEncode
		));

		IDirect3DPixelShader9 * pixelShader = afxPixelShader->GetPixelShader();

		IDirect3DTexture9 * depthTexture = NULL;
		IDirect3DSurface9 * depthSurface = NULL;

		{
			if (SUCCEEDED(g_OldDirect3DDevice9->GetDepthStencilSurface(&depthSurface)))
			{
				if (IDirect3DSurface9 * depthReplacement = CAfxTrackedSurface::Replacement(depthSurface))
				{
					if (FAILED(depthReplacement->GetContainer(__uuidof(IDirect3DTexture9), (void **)&depthTexture)))
					{
						depthTexture = NULL;
					}
				}				
			}
			else
			{
				depthSurface = NULL;
			}
		}

		if (pixelShader && depthTexture)
		{
			AfxBeginCleanState();

			IDirect3DSurface9 * oldRenderTarget = NULL;

			if (FAILED(g_OldDirect3DDevice9->GetRenderTarget(0, &oldRenderTarget)))
			{
				AfxEndCleanState();
				goto exit;
			}

#ifdef AFX_INTEROP
			if (
				AfxInterop::MainEnabled()
			)
			{
				if (CAfxTrackedSurface * afxTrackedSurface = trackedRenderTarget)
				{
					if (IDirect3DSurface9 * newRenderTarget = afxTrackedSurface->AfxGetDepthSurface())
					{
						g_OldDirect3DDevice9->SetRenderTarget(0, newRenderTarget);
					}
					else
					{
						// Not connected.
						oldRenderTarget->Release();
						AfxEndCleanState();
						goto exit;
					}
				}
			}
#endif
			//
			// Draw

			g_OldDirect3DDevice9->SetFVF(D3DFVF_AFXDRAWDEPTHVERTEX);

			// Setup viewport
			D3DVIEWPORT9 vp;
			vp.X = (DWORD)x;
			vp.Y = (DWORD)y;
			vp.Width = (DWORD)width;
			vp.Height = (DWORD)height;
			vp.MinZ = 0.0f;
			vp.MaxZ = 1.0f;
			g_OldDirect3DDevice9->SetViewport(&vp);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);

			g_OldDirect3DDevice9->SetVertexShader(NULL);
			g_OldDirect3DDevice9->SetPixelShader(pixelShader);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS); // redundant due to ZENABLE
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_SRGBTEXTURE, FALSE);

			// Setup orthographic projection matrix
			{
				const float L = 0.5f + x, R = 0.5f + x + width, T = 0.5f + y, B = 0.5f + y + height;
				D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
				D3DMATRIX mat_projection =
				{
					2.0f / (R - L),   0.0f,         0.0f,  0.0f,
					0.0f,         2.0f / (T - B),   0.0f,  0.0f,
					0.0f,         0.0f,         0.5f,  0.0f,
					(L + R) / (L - R),  (T + B) / (B - T),  0.5f,  1.0f,
				};
				g_OldDirect3DDevice9->SetTransform(D3DTS_WORLD, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_VIEW, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_PROJECTION, &mat_projection);
			}

			// Render:

			// Unbind INTZ depth stencil, so we can use it as texture:
			// not required // g_OldDirect3DDevice9->SetDepthStencilSurface(NULL);

			// Bind depth as texture:
			g_OldDirect3DDevice9->SetTexture(0, depthTexture);

			FLOAT overFac[4] = { zNear, zFar, depthVal, depthValMax };
			g_OldDirect3DDevice9->SetPixelShaderConstantF(5, overFac, 1);

			if (projectionMatrix)
			{
				double M[4][4] = {
					projectionMatrix[0][0], projectionMatrix[0][1], projectionMatrix[0][2],  projectionMatrix[0][3],
					projectionMatrix[1][0], projectionMatrix[1][1], projectionMatrix[1][2],  projectionMatrix[1][3],
					projectionMatrix[2][0], projectionMatrix[2][1], projectionMatrix[2][2],  projectionMatrix[2][3],
					projectionMatrix[3][0], projectionMatrix[3][1], projectionMatrix[3][2],  projectionMatrix[3][3]
				};

				double b0[4] = { 1, 0, 0, 0 };
				double b1[4] = { 0, 1, 0, 0 };
				double b2[4] = { 0, 0, 1, 0 };
				double b3[4] = { 0, 0, 0, 1 };

				unsigned char P[4];
				unsigned char Q[4];

				double L[4][4];
				double U[4][4];

				if (LUdecomposition(M, P, Q, L, U))
				{
					double inv0[4] = { 1,0,0,0 };
					double inv1[4] = { 0,1,0,0 };
					double inv2[4] = { 0,0,1,0 };
					double inv3[4] = { 0,0,0,1 };

					SolveWithLU(L, U, P, Q, b0, inv0);
					SolveWithLU(L, U, P, Q, b1, inv1);
					SolveWithLU(L, U, P, Q, b2, inv2);
					SolveWithLU(L, U, P, Q, b3, inv3);

					// Transposed for DirectX:
					FLOAT newMatrix[4][4] = {
						(FLOAT)inv0[0], (FLOAT)inv0[1], (FLOAT)inv0[2], (FLOAT)inv0[3],
						(FLOAT)inv1[0], (FLOAT)inv1[1], (FLOAT)inv1[2], (FLOAT)inv1[3],
						(FLOAT)inv2[0], (FLOAT)inv2[1], (FLOAT)inv2[2], (FLOAT)inv2[3],
						(FLOAT)inv3[0], (FLOAT)inv3[1], (FLOAT)inv3[2], (FLOAT)inv3[3]
					};

					g_OldDirect3DDevice9->SetPixelShaderConstantF(6, &(newMatrix[0][0]), 4);
				}
			}

			// Draw rectangle:

			AFXDRAWDEPTHVERTEX vertexData[4] = {
				{{0,(float)height,0}, {0,1}},
				{{0,0,0}, {0,0}},
				{{(float)width,(float)height,0}, {1,1}},
				{{(float)width,0,0}, {1,0}},
			};

			g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWDEPTHVERTEX));

			if (drawToScreen)
			{
				if (IDirect3DSurface9 * src = oldRenderTarget)
				{
					if (IDirect3DPixelShader9 * drawTextureShader = g_AfxShaders.GetAcsPixelShader(L"afx_drawtexture_ps20.acs", ShaderCombo_afx_drawtexture_ps20::GetCombo())->GetPixelShader())
					{
						g_OldDirect3DDevice9->SetPixelShader(drawTextureShader);

						IDirect3DTexture9 * srcTex = NULL;
						if (SUCCEEDED(src->GetContainer(__uuidof(IDirect3DTexture9), (void **)&srcTex)))
						{
							g_OldDirect3DDevice9->SetDepthStencilSurface(NULL);
							
							g_OldDirect3DDevice9->SetRenderTarget(0, CAfxTrackedSurface::Original(oldRenderTarget));
							g_OldDirect3DDevice9->SetTexture(0, srcTex);
							g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
							g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

							g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWDEPTHVERTEX));

							srcTex->Release();

							g_OldDirect3DDevice9->SetDepthStencilSurface(depthSurface);
						}
					}
				}
			}

			//
			// Restore old Direct3D9 state:

			g_OldDirect3DDevice9->SetRenderTarget(0, oldRenderTarget);

			if (oldRenderTarget) oldRenderTarget->Release();

			AfxEndCleanState();
		}

	exit:
		if (depthTexture) depthTexture->Release();
		if (depthSurface) depthSurface->Release();
	}

	void AfxDrawGuides(int x, int y, int width, int height, bool phiGrid, bool ruleOfThirds)
	{
		IAfxPixelShader * afxPixelShader = g_AfxShaders.GetAcsPixelShader(L"afx_pgldraw_ps20.acs", ShaderCombo_afx_pgldraw_ps20::GetCombo(
		));

		IDirect3DPixelShader9 * pixelShader = afxPixelShader->GetPixelShader();

		if (pixelShader)
		{
			AfxBeginCleanState();

			//		

			g_OldDirect3DDevice9->SetFVF(D3DFVF_AFXDRAWGUIDEVERTEX);

			// Setup viewport
			D3DVIEWPORT9 vp;
			vp.X = (DWORD)x;
			vp.Y = (DWORD)y;
			vp.Width = (DWORD)width;
			vp.Height = (DWORD)height;
			vp.MinZ = 0.0f;
			vp.MaxZ = 1.0f;
			g_OldDirect3DDevice9->SetViewport(&vp);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);

			g_OldDirect3DDevice9->SetVertexShader(NULL);
			g_OldDirect3DDevice9->SetPixelShader(pixelShader);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS); // redundant due to ZENABLE
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_LIGHTING, FALSE);

			// Setup orthographic projection matrix
			{
				const float L = 0.5f + x, R = 0.5f + x + width, T = 0.5f + y, B = 0.5f + y + height;
				D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
				D3DMATRIX mat_projection =
				{
					2.0f / (R - L),   0.0f,         0.0f,  0.0f,
					0.0f,         2.0f / (T - B),   0.0f,  0.0f,
					0.0f,         0.0f,         0.5f,  0.0f,
					(L + R) / (L - R),  (T + B) / (B - T),  0.5f,  1.0f,
				};
				g_OldDirect3DDevice9->SetTransform(D3DTS_WORLD, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_VIEW, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_PROJECTION, &mat_projection);
			}

			// Render:

			if (phiGrid)
			{
				float invGoldRatio = 1.0f / (float)AFX_GOLDENRATIO;
				float oneMinusInvGoldenRatio = 1.0f - invGoldRatio;

				// Top line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{0,(float)height * oneMinusInvGoldenRatio + 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{0,(float)height * oneMinusInvGoldenRatio - 1.0f ,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width,(float)height * oneMinusInvGoldenRatio + 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width,(float)height * oneMinusInvGoldenRatio - 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Bottom line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{0,(float)height * invGoldRatio + 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{0,(float)height * invGoldRatio - 1.0f ,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width, (float)height * invGoldRatio + 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width, (float)height * invGoldRatio - 1.0f,0}, D3DCOLOR_ARGB(255,255,255,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Left line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{(float)width * oneMinusInvGoldenRatio - 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * oneMinusInvGoldenRatio - 1.0f,0,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * oneMinusInvGoldenRatio + 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * oneMinusInvGoldenRatio + 1.0f,0,0}, D3DCOLOR_ARGB(255,255,255,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Right line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{(float)width * invGoldRatio - 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * invGoldRatio - 1.0f,0,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * invGoldRatio + 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,255,255)},
						{{(float)width * invGoldRatio + 1.0f,0,0}, D3DCOLOR_ARGB(255,255,255,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
			}

			if(ruleOfThirds)
			{
				// Top line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{0,(float)height / 3.0f + 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{0,(float)height / 3.0f - 1.0f ,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width,(float)height / 3.0f + 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width,(float)height / 3.0f - 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Bottom line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{0,2.0f * (float)height / 3.0f + 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{0,2.0f * (float)height / 3.0f - 1.0f ,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width,2.0f * (float)height / 3.0f + 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width,2.0f * (float)height / 3.0f - 1.0f,0}, D3DCOLOR_ARGB(255,255,0,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Left line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{(float)width / 3.0f - 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width / 3.0f - 1.0f,0,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width / 3.0f + 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{(float)width / 3.0f + 1.0f,0,0}, D3DCOLOR_ARGB(255,255,0,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
				// Right line
				{
					AFXDRAWGUIDEVERTEX vertexData[4] = {
						{{2.0f * (float)width / 3.0f - 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{2.0f * (float)width / 3.0f - 1.0f,0,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{2.0f * (float)width / 3.0f + 1.0f,(float)height,0}, D3DCOLOR_ARGB(255,255,0,255)},
						{{2.0f * (float)width / 3.0f + 1.0f,0,0}, D3DCOLOR_ARGB(255,255,0,255)},
					};

					g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWGUIDEVERTEX));
				}
			}
			
			//

			AfxEndCleanState();
		}
	}

	void AfxDrawRect(IDirect3DTexture9* texture, int x, int y, int width, int height, float x0, float y0, float x1, float y1)
	{
		IAfxPixelShader* afxPixelShader = g_AfxShaders.GetAcsPixelShader(L"afx_drawtexture_ps20.acs", ShaderCombo_afx_pgldraw_ps20::GetCombo(
		));

		IDirect3DPixelShader9* pixelShader = afxPixelShader->GetPixelShader();

		if (pixelShader)
		{		
			AfxBeginCleanState();

			//

			g_OldDirect3DDevice9->SetFVF(D3DFVF_AFXDRAWDEPTHVERTEX);

			// Setup viewport
			D3DVIEWPORT9 vp;
			vp.X = (DWORD)x;
			vp.Y = (DWORD)y;
			vp.Width = (DWORD)width;
			vp.Height = (DWORD)height;
			vp.MinZ = 0.0f;
			vp.MaxZ = 1.0f;
			g_OldDirect3DDevice9->SetViewport(&vp);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);

			g_OldDirect3DDevice9->SetVertexShader(NULL);
			g_OldDirect3DDevice9->SetPixelShader(pixelShader);

			g_OldDirect3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS); // redundant due to ZENABLE
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_LIGHTING, FALSE);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
			g_OldDirect3DDevice9->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			g_OldDirect3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
			g_OldDirect3DDevice9->SetSamplerState(0, D3DSAMP_SRGBTEXTURE, FALSE);

			// texture:
			g_OldDirect3DDevice9->SetTexture(0, texture);

			// Setup orthographic projection matrix
			{
				const float L = 0.5f + x, R = 0.5f + x + width, T = 0.5f + y, B = 0.5f + y + height;
				D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
				D3DMATRIX mat_projection =
				{
					2.0f / (R - L),   0.0f,         0.0f,  0.0f,
					0.0f,         2.0f / (T - B),   0.0f,  0.0f,
					0.0f,         0.0f,         0.5f,  0.0f,
					(L + R) / (L - R),  (T + B) / (B - T),  0.5f,  1.0f,
				};
				g_OldDirect3DDevice9->SetTransform(D3DTS_WORLD, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_VIEW, &mat_identity);
				g_OldDirect3DDevice9->SetTransform(D3DTS_PROJECTION, &mat_projection);
			}

			// Render:
			{
				AFXDRAWDEPTHVERTEX vertexData[4] = {
					{{0,(float)height,0}, {x0,y0}},
					{{0,0,0}, {x0,y1}},
					{{(float)width,(float)height,0}, {x1,y0}},
					{{(float)width,0,0}, {x1,y1}},
				};

				g_OldDirect3DDevice9->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWDEPTHVERTEX));
			}

			//

			AfxEndCleanState();
		}
	}


private:
#if 0
	bool GetAfxManagedChildDirect3DSurface9(IDirect3DSurface9 * surface, CAfxManagedChildDirect3DSurface9 ** pOut)
	{
		if (surface && SUCCEEDED(surface->QueryInterface(IID_CAfxManagedChildDirect3DSurface9, (void **)pOut)))
			return true;

		return false;
	}

	bool GetAfxManagedChildDirect3DSurface9Reverse(IDirect3DSurface9 * surface, CAfxManagedChildDirect3DSurface9 ** pOut)
	{
		DWORD size = sizeof(CAfxManagedChildDirect3DSurface9 *);
		if (surface && SUCCEEDED(surface->GetPrivateData(IID_CAfxManagedChildDirect3DSurface9, pOut, &size)))
			return true;

		return false;
	}

	bool GetAfxManagedOffscreenPlainSurface(IDirect3DSurface9 * surface, CAfxManagedOffscreenPlainSurface ** pOut)
	{
		if (surface && SUCCEEDED(surface->QueryInterface(IID_CAfxManagedOffscreenPlainSurface, (void **)pOut)))
			return true;

		return false;
	}

	bool GetAfxManagedOffscreenPlainSurfaceReverse(IDirect3DSurface9 * surface, CAfxManagedOffscreenPlainSurface ** pOut)
	{
		DWORD size = sizeof(*pOut);
		if (pOut && SUCCEEDED(surface->GetPrivateData(IID_CAfxManagedOffscreenPlainSurface, pOut, &size)))
			return true;

		return false;
	}	
#endif

	IDirect3DSurface9 * UnwrapSurface(IDirect3DSurface9 * surface)
	{
#if 0 && AFX_INTEROP
		if (AfxInterop::Enabled() && surface)
		{
			{
				CAfxManagedChildDirect3DSurface9 * afxWrapper;
				if (GetAfxManagedChildDirect3DSurface9(surface, &afxWrapper))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
			{
				CAfxManagedOffscreenPlainSurface * afxWrapper;
				if (GetAfxManagedOffscreenPlainSurface(surface, &afxWrapper))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
		}
#endif

		return CAfxTrackedSurface::Replacement(surface);
	}


	IDirect3DSurface9 * UnwrapSurfaceReverse(IDirect3DSurface9 * surface, bool handleRef)
	{
#if 0 && AFX_INTEROP
		if (AfxInterop::Enabled() && surface)
		{
			{
				CAfxManagedChildDirect3DSurface9 * afxWrapper;

				if (GetAfxManagedChildDirect3DSurface9Reverse(surface, &afxWrapper))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						surface->Release();
					}

					return afxWrapper;
				}
			}
			{
				CAfxManagedOffscreenPlainSurface * afxWrapper;

				if (GetAfxManagedOffscreenPlainSurfaceReverse(surface, &afxWrapper))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						surface->Release();
					}

					return afxWrapper;
				}
			}
		}
#endif

		return CAfxTrackedSurface::Original(surface);
	}
#if 0
	IDirect3DBaseTexture9 * UnwrapTextureReverse(IDirect3DBaseTexture9 * pTexture, bool handleRef)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && pTexture)
		{
			{
				CAfxManagedDirect3DTexture9 * afxWrapper;
				DWORD afxWrapperSize = sizeof(afxWrapper);
				if (SUCCEEDED(pTexture->GetPrivateData(IID_CAfxManagedDirect3DTexture9, &afxWrapper, &afxWrapperSize)))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						pTexture->Release();
					}

					return afxWrapper;
				}
			}
			{
				CAfxManagedDirect3DVolumeTexture9 * afxWrapper;
				DWORD afxWrapperSize = sizeof(afxWrapper);
				if (SUCCEEDED(pTexture->GetPrivateData(IID_CAfxManagedDirect3DVolumeTexture9, &afxWrapper, &afxWrapperSize)))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						pTexture->Release();
					}

					return afxWrapper;
				}
			}
			{
				CAfxManagedDirect3DCubeTexture9 * afxWrapper;
				DWORD afxWrapperSize = sizeof(afxWrapper);
				if (SUCCEEDED(pTexture->GetPrivateData(IID_CAfxManagedDirect3DCubeTexture9, &afxWrapper, &afxWrapperSize)))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						pTexture->Release();
					}

					return afxWrapper;
				}
			}
		}
#endif
		return pTexture;
	}

	IDirect3DBaseTexture9 * UnwrapTexture(IDirect3DBaseTexture9 * pTexture)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && pTexture)
		{
			{
				CAfxManagedDirect3DTexture9 * afxWrapper;

				if (SUCCEEDED(pTexture->QueryInterface(IID_CAfxManagedDirect3DTexture9, (void **)&afxWrapper)))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
			{
				CAfxManagedDirect3DVolumeTexture9 * afxWrapper;

				if (SUCCEEDED(pTexture->QueryInterface(IID_CAfxManagedDirect3DVolumeTexture9, (void **)&afxWrapper)))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
			{
				CAfxManagedDirect3DCubeTexture9 * afxWrapper;

				if (SUCCEEDED(pTexture->QueryInterface(IID_CAfxManagedDirect3DCubeTexture9, (void **)&afxWrapper)))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
		}
#endif
		return pTexture;
	}

	IDirect3DVertexBuffer9 * UnwrapVertexBuffer(IDirect3DVertexBuffer9 * buffer)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && buffer)
		{
			{
				CAfxManagedDirect3DVertexBuffer9 * afxWrapper;

				if (SUCCEEDED(buffer->QueryInterface(IID_CAfxManagedDirect3DVertexBuffer9, (void **)&afxWrapper)))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
		}
#endif
		return buffer;
	}

	IDirect3DVertexBuffer9 * UnwrapVertexBufferReverse(IDirect3DVertexBuffer9 * buffer, bool handleRef)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && buffer)
		{
			{
				IDirect3DVertexBuffer9 * afxWrapper;
				DWORD afxWrapperSize = sizeof(afxWrapper);
				if (SUCCEEDED(buffer->GetPrivateData(IID_CAfxManagedDirect3DVertexBuffer9, &afxWrapper, &afxWrapperSize)))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						buffer->Release();
					}

					return afxWrapper;
				}
			}
		}
#endif
		return buffer;
	}

	IDirect3DIndexBuffer9 * UnwrapIndexBuffer(IDirect3DIndexBuffer9 * buffer)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && buffer)
		{
			{
				CAfxManagedDirect3DIndexBuffer9 * afxWrapper;

				if (SUCCEEDED(buffer->QueryInterface(IID_CAfxManagedDirect3DIndexBuffer9, (void **)&afxWrapper)))
				{
					return afxWrapper->AfxGetOrCreateUnmanaged();
				}
			}
		}
#endif
		return buffer;
	}

	IDirect3DIndexBuffer9 * UnwrapIndexBufferReverse(IDirect3DIndexBuffer9 * buffer, bool handleRef)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && buffer)
		{
			{
				IDirect3DIndexBuffer9 * afxWrapper;
				DWORD afxWrapperSize = sizeof(afxWrapper);
				if (SUCCEEDED(buffer->GetPrivateData(IID_CAfxManagedDirect3DIndexBuffer9, &afxWrapper, &afxWrapperSize)))
				{
					if (handleRef)
					{
						afxWrapper->AddRef();
						buffer->Release();
					}

					return afxWrapper;
				}
			}
		}
#endif
		return buffer;
	}
#endif

private:
	bool m_Block_Present = false;
	bool m_Block_Clear = false;

	class CAfxOverride
	{
	public:
		bool m_Override_D3DRS_BLENDOP;
		DWORD m_OverrideValue_D3DRS_BLENDOP;

		bool m_Override_D3DRS_SRCBLEND;
		DWORD m_OverrideValue_D3DRS_SRCBLEND;

		bool m_Override_D3DRS_DESTBLEND;
		DWORD m_OverrideValue_D3DRS_DESTBLEND;

		bool m_Override_D3DRS_SRGBWRITEENABLE;
		DWORD m_OverrideValue_D3DRS_SRGBWRITEENABLE;

		bool m_Override_D3DRS_COLORWRITEENABLE;
		DWORD m_OverrideValue_D3DRS_COLORWRITEENABLE;

		bool m_Override_D3DRS_ZWRITEENABLE;
		DWORD m_OverrideValue_D3DRS_ZWRITEENABLE;

		bool m_Override_D3DRS_ALPHABLENDENABLE;
		DWORD m_OverrideValue_D3DRS_ALPHABLENDENABLE;

		bool m_Override_ps_c0;
		float m_OverrideValue_ps_c0[4];

		bool m_Override_ps_c5;
		float m_OverrideValue_ps_c5[4];

		bool m_Override_ps_c12_y;
		float m_OverrideValue_ps_c12_y;

		bool m_Override_ps_c29_w;
		float m_OverrideValue_ps_c29_w;

		bool m_Override_ps_c31;
		float m_OverrideValue_ps_c31[4];

		ID3d9HooksFloat4ParamOverride*  m_Override_ps_c1;
		float m_OverrideValue_ps_c1[4];

		ID3d9HooksFloat4ParamOverride* m_Override_ps_c30;
		float m_OverrideValue_ps_c30[4];

		bool m_Override_VertexShader;
		IDirect3DVertexShader9 * m_OverrideValue_VertexShader;

		bool m_Override_PixelShader;
		IDirect3DPixelShader9 * m_OverrideValue_PixelShader;

		CAfxOverride(NewDirect3DDevice9 & dev)
			: m_Dev(dev)
			, m_Override_D3DRS_BLENDOP(false)
			, m_Override_D3DRS_SRCBLEND(false)
			, m_Override_D3DRS_DESTBLEND(false)
			, m_Override_D3DRS_SRGBWRITEENABLE(false)
			, m_Override_D3DRS_COLORWRITEENABLE(false)
			, m_Override_D3DRS_ZWRITEENABLE(false)
			, m_Override_D3DRS_ALPHABLENDENABLE(false)
			, m_Override_ps_c0(false)
			, m_Override_ps_c5(false)
			, m_Override_ps_c12_y(false)
			, m_Override_ps_c29_w(false)
			, m_Override_ps_c31(false)
			, m_Override_ps_c1(nullptr)
			, m_Override_ps_c30(nullptr)
			, m_Override_VertexShader(false)
			, m_Override_PixelShader(false)
		{
		}

		CAfxOverride(const CAfxOverride & x)
			: m_Dev(x.m_Dev)
			, m_Override_D3DRS_BLENDOP(x.m_Override_D3DRS_BLENDOP)
			, m_OverrideValue_D3DRS_BLENDOP(x.m_OverrideValue_D3DRS_BLENDOP)
			, m_Override_D3DRS_SRCBLEND(x.m_Override_D3DRS_SRCBLEND)
			, m_OverrideValue_D3DRS_SRCBLEND(x.m_OverrideValue_D3DRS_SRCBLEND)
			, m_Override_D3DRS_DESTBLEND(x.m_Override_D3DRS_DESTBLEND)
			, m_OverrideValue_D3DRS_DESTBLEND(x.m_OverrideValue_D3DRS_DESTBLEND)
			, m_Override_D3DRS_SRGBWRITEENABLE(x.m_Override_D3DRS_SRGBWRITEENABLE)
			, m_OverrideValue_D3DRS_SRGBWRITEENABLE(x.m_OverrideValue_D3DRS_SRGBWRITEENABLE)
			, m_Override_D3DRS_COLORWRITEENABLE(x.m_Override_D3DRS_COLORWRITEENABLE)
			, m_OverrideValue_D3DRS_COLORWRITEENABLE(x.m_OverrideValue_D3DRS_COLORWRITEENABLE)
			, m_Override_D3DRS_ZWRITEENABLE(x.m_Override_D3DRS_ZWRITEENABLE)
			, m_OverrideValue_D3DRS_ZWRITEENABLE(x.m_OverrideValue_D3DRS_ZWRITEENABLE)
			, m_Override_D3DRS_ALPHABLENDENABLE(x.m_Override_D3DRS_ALPHABLENDENABLE)
			, m_OverrideValue_D3DRS_ALPHABLENDENABLE(x.m_OverrideValue_D3DRS_ALPHABLENDENABLE)
			, m_Override_ps_c0(x.m_Override_ps_c0)
			, m_Override_ps_c5(x.m_Override_ps_c5)
			, m_Override_ps_c12_y(x.m_Override_ps_c12_y)
			, m_OverrideValue_ps_c12_y(x.m_OverrideValue_ps_c12_y)
			, m_Override_ps_c29_w(x.m_Override_ps_c29_w)
			, m_OverrideValue_ps_c29_w(x.m_OverrideValue_ps_c29_w)
			, m_Override_ps_c31(x.m_Override_ps_c31)
			, m_Override_ps_c1(x.m_Override_ps_c1)
			, m_Override_ps_c30(x.m_Override_ps_c30)
			, m_Override_VertexShader(x.m_Override_VertexShader)
			, m_OverrideValue_VertexShader(NULL)
			, m_Override_PixelShader(x.m_Override_PixelShader)
			, m_OverrideValue_PixelShader(NULL)
		{
			std::copy(std::begin(x.m_OverrideValue_ps_c0), std::end(x.m_OverrideValue_ps_c0), std::begin(m_OverrideValue_ps_c0));
			std::copy(std::begin(x.m_OverrideValue_ps_c5), std::end(x.m_OverrideValue_ps_c5), std::begin(m_OverrideValue_ps_c5));
			std::copy(std::begin(x.m_OverrideValue_ps_c31), std::end(x.m_OverrideValue_ps_c31), std::begin(m_OverrideValue_ps_c31));
			std::copy(std::begin(x.m_OverrideValue_ps_c1), std::end(x.m_OverrideValue_ps_c1), std::begin(m_OverrideValue_ps_c1));
			std::copy(std::begin(x.m_OverrideValue_ps_c30), std::end(x.m_OverrideValue_ps_c30), std::begin(m_OverrideValue_ps_c30));

			if (m_Override_VertexShader)
			{
				if (x.m_OverrideValue_VertexShader)
				{
					x.m_OverrideValue_VertexShader->AddRef();
					m_OverrideValue_VertexShader = x.m_OverrideValue_VertexShader;
				}
			}

			if (m_Override_PixelShader) {
				if (x.m_Override_PixelShader)
				{
					x.m_OverrideValue_PixelShader->AddRef();
					m_OverrideValue_PixelShader = x.m_OverrideValue_PixelShader;
				}
			}
		}

		void Redo(void)
		{
			if (m_Override_D3DRS_BLENDOP) g_OldDirect3DDevice9->SetRenderState(D3DRS_BLENDOP, m_OverrideValue_D3DRS_BLENDOP);
			if (m_Override_D3DRS_SRCBLEND) g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, m_OverrideValue_D3DRS_SRCBLEND);
			if (m_Override_D3DRS_DESTBLEND) g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, m_OverrideValue_D3DRS_DESTBLEND);
			if (m_Override_D3DRS_SRGBWRITEENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, m_OverrideValue_D3DRS_SRGBWRITEENABLE);
			if (m_Override_D3DRS_COLORWRITEENABLE)g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, m_OverrideValue_D3DRS_COLORWRITEENABLE);
			if (m_Override_D3DRS_ZWRITEENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, m_OverrideValue_D3DRS_ZWRITEENABLE);
			if (m_Override_D3DRS_ALPHABLENDENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, m_OverrideValue_D3DRS_ALPHABLENDENABLE);
			if (m_Override_VertexShader) g_OldDirect3DDevice9->SetVertexShader(m_OverrideValue_VertexShader);
			if (m_Override_PixelShader) g_OldDirect3DDevice9->SetPixelShader(m_OverrideValue_PixelShader);
			if (m_Override_ps_c0) g_OldDirect3DDevice9->SetPixelShaderConstantF(0, m_OverrideValue_ps_c0, 1);
			if (m_Override_ps_c5) g_OldDirect3DDevice9->SetPixelShaderConstantF(5, m_OverrideValue_ps_c5, 1);
			if (m_Override_ps_c12_y) {
				float tmp[4] = { m_Dev.m_OriginalValue_ps_c12[0], m_OverrideValue_ps_c12_y, m_Dev.m_OriginalValue_ps_c12[2],  m_Dev.m_OriginalValue_ps_c12[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(12, tmp, 1);
			}
			if (m_Override_ps_c29_w) {
				float tmp[4] = { m_Dev.m_OriginalValue_ps_c29[0] ,m_Dev.m_OriginalValue_ps_c29[1],m_Dev.m_OriginalValue_ps_c29[2], m_OverrideValue_ps_c29_w };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(29, tmp, 1);
			}
			if (m_Override_ps_c31) g_OldDirect3DDevice9->SetPixelShaderConstantF(29, m_OverrideValue_ps_c31, 1);
			if (m_Override_ps_c1) {
				float tmp[4] = { m_OverrideValue_ps_c1[0], m_OverrideValue_ps_c1[1], m_OverrideValue_ps_c1[2], m_OverrideValue_ps_c1[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
			}
			if (m_Override_ps_c30) {
				float tmp[4] = { m_OverrideValue_ps_c30[0], m_OverrideValue_ps_c30[1], m_OverrideValue_ps_c30[2], m_OverrideValue_ps_c30[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
			}
		}

		void Undo(void)
		{
			if (m_Override_D3DRS_BLENDOP) g_OldDirect3DDevice9->SetRenderState(D3DRS_BLENDOP, m_Dev.m_D3DRS_BLENDOP);
			if (m_Override_D3DRS_SRCBLEND) g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, m_Dev.m_D3DRS_SRCBLEND);
			if (m_Override_D3DRS_DESTBLEND) g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, m_Dev.m_D3DRS_DESTBLEND);
			if (m_Override_D3DRS_SRGBWRITEENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, m_Dev.m_D3DRS_SRGBWRITEENABLE);
			if (m_Override_D3DRS_COLORWRITEENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, m_Dev.m_D3DRS_COLORWRITEENABLE);
			if (m_Override_D3DRS_ZWRITEENABLE)g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, m_Dev.m_D3DRS_ZWRITEENABLE);
			if (m_Override_D3DRS_ALPHABLENDENABLE) g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, m_Dev.m_D3DRS_ALPHABLENDENABLE);
			if (m_Override_VertexShader) g_OldDirect3DDevice9->SetVertexShader(m_Dev.m_Original_VertexShader);
			if (m_Override_PixelShader) g_OldDirect3DDevice9->SetPixelShader(m_Dev.m_Original_PixelShader);
			if (m_Override_ps_c0) g_OldDirect3DDevice9->SetPixelShaderConstantF(0, m_Dev.m_OriginalValue_ps_c0, 1);
			if (m_Override_ps_c5) g_OldDirect3DDevice9->SetPixelShaderConstantF(5, m_Dev.m_OriginalValue_ps_c5, 1);
			if (m_Override_ps_c12_y) g_OldDirect3DDevice9->SetPixelShaderConstantF(12, m_Dev.m_OriginalValue_ps_c12, 1);
			if (m_Override_ps_c29_w) g_OldDirect3DDevice9->SetPixelShaderConstantF(29, m_Dev.m_OriginalValue_ps_c29, 1);
			if (m_Override_ps_c31) g_OldDirect3DDevice9->SetPixelShaderConstantF(31, m_Dev.m_OriginalValue_ps_c31, 1);
			if (m_Override_ps_c1) {
				float tmp[4] = { m_Dev.m_OriginalValue_ps_c1[0], m_Dev.m_OriginalValue_ps_c1[1], m_Dev.m_OriginalValue_ps_c1[2], m_Dev.m_OriginalValue_ps_c1[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
			}
			if (m_Override_ps_c30) {
				float tmp[4] = { m_Dev.m_OriginalValue_ps_c30[0], m_Dev.m_OriginalValue_ps_c30[1], m_Dev.m_OriginalValue_ps_c30[2], m_Dev.m_OriginalValue_ps_c30[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
			}
		}

	private:
		NewDirect3DDevice9 & m_Dev;

	};

	std::stack<CAfxOverride> m_OverrideStack;

public:
	NewDirect3DDevice9()
	{
		m_OverrideStack.emplace(*this);
	}

	void OverrideBegin_D3DRS_BLENDOP(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_BLENDOP = true;
		curOverride.m_OverrideValue_D3DRS_BLENDOP = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_BLENDOP, value);
	}

	void OverrideEnd_D3DRS_BLENDOP(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_D3DRS_BLENDOP)
		{
			curOverride.m_Override_D3DRS_BLENDOP = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_BLENDOP, m_D3DRS_BLENDOP);
		}
	}

	void OverrideBegin_D3DRS_SRCBLEND(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_SRCBLEND = true;
		curOverride.m_OverrideValue_D3DRS_SRCBLEND = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, value);
	}

	void OverrideEnd_D3DRS_SRCBLEND(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_D3DRS_SRCBLEND)
		{
			curOverride.m_Override_D3DRS_SRCBLEND = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, m_D3DRS_SRCBLEND);
		}
	}

	void OverrideBegin_D3DRS_DESTBLEND(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_DESTBLEND = true;
		curOverride.m_OverrideValue_D3DRS_DESTBLEND = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, value);
	}

	void OverrideEnd_D3DRS_DESTBLEND(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_D3DRS_DESTBLEND)
		{
			curOverride.m_Override_D3DRS_DESTBLEND = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, m_D3DRS_DESTBLEND);
		}
	}

	void OverrideBegin_D3DRS_SRGBWRITEENABLE(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_SRGBWRITEENABLE = true;
		curOverride.m_OverrideValue_D3DRS_SRGBWRITEENABLE = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, value);
	}

	void OverrideEnd_D3DRS_SRGBWRITEENABLE(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_D3DRS_SRGBWRITEENABLE)
		{
			curOverride.m_Override_D3DRS_SRGBWRITEENABLE = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, m_D3DRS_SRGBWRITEENABLE);
		}
	}

	void OverrideBegin_D3DRS_COLORWRITEENABLE(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_COLORWRITEENABLE = true;
		curOverride.m_OverrideValue_D3DRS_COLORWRITEENABLE = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, value);
	}

	void OverrideEnd_D3DRS_COLORWRITEENABLE(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_D3DRS_COLORWRITEENABLE)
		{
			curOverride.m_Override_D3DRS_COLORWRITEENABLE = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, m_D3DRS_COLORWRITEENABLE);
		}
	}

	void OverrideBegin_D3DRS_ZWRITEENABLE(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_ZWRITEENABLE = true;
		curOverride.m_OverrideValue_D3DRS_ZWRITEENABLE = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, value);
	}

	void OverrideEnd_D3DRS_ZWRITEENABLE(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_D3DRS_ZWRITEENABLE)
		{
			curOverride.m_Override_D3DRS_ZWRITEENABLE = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, m_D3DRS_ZWRITEENABLE);
		}
	}

	void OverrideBegin_D3DRS_ALPHABLENDENABLE(DWORD value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_D3DRS_ALPHABLENDENABLE = true;
		curOverride.m_OverrideValue_D3DRS_ALPHABLENDENABLE = value;

		g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, value);
	}

	void OverrideEnd_D3DRS_ALPHABLENDENABLE(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_D3DRS_ALPHABLENDENABLE)
		{
			curOverride.m_Override_D3DRS_ALPHABLENDENABLE = false;

			g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, m_D3DRS_ALPHABLENDENABLE);
		}
	}

	void OverrideBegin_SetVertexShader(IDirect3DVertexShader9 * override_VertexShader)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_VertexShader = true;
		curOverride.m_OverrideValue_VertexShader = override_VertexShader;
		if(curOverride.m_OverrideValue_VertexShader) curOverride.m_OverrideValue_VertexShader->AddRef();

		g_OldDirect3DDevice9->SetVertexShader(override_VertexShader);
	}

	void OverrideEnd_SetVertexShader()
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_VertexShader)
		{
			curOverride.m_Override_VertexShader = false;

			g_OldDirect3DDevice9->SetVertexShader(m_Original_VertexShader);

			if(curOverride.m_OverrideValue_VertexShader) curOverride.m_OverrideValue_VertexShader->Release();
		}
	}

	void OverrideBegin_SetPixelShader(IDirect3DPixelShader9 * override_PixelShader)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_PixelShader = true;
		curOverride.m_OverrideValue_PixelShader = override_PixelShader;
		if(curOverride.m_OverrideValue_PixelShader) curOverride.m_OverrideValue_PixelShader->AddRef();

		g_OldDirect3DDevice9->SetPixelShader(override_PixelShader);
	}

	void OverrideEnd_SetPixelShader()
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_PixelShader)
		{
			curOverride.m_Override_PixelShader = false;

			g_OldDirect3DDevice9->SetPixelShader(m_Original_PixelShader);

			if(curOverride.m_OverrideValue_PixelShader) curOverride.m_OverrideValue_PixelShader->Release();
		}
	}

	void OverrideBegin_ps_c0(float const values[4])
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_ps_c0 = true;
		curOverride.m_OverrideValue_ps_c0[0] = values[0];
		curOverride.m_OverrideValue_ps_c0[1] = values[1];
		curOverride.m_OverrideValue_ps_c0[2] = values[2];
		curOverride.m_OverrideValue_ps_c0[3] = values[3];

		g_OldDirect3DDevice9->SetPixelShaderConstantF(0, curOverride.m_OverrideValue_ps_c0, 1);
	}

	void OverrideEnd_ps_c0(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_ps_c0)
		{
			curOverride.m_Override_ps_c0 = false;

			g_OldDirect3DDevice9->SetPixelShaderConstantF(0, m_OriginalValue_ps_c0, 1);
		}
	}

	void OverrideBegin_ps_c5(float const values[4])
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_ps_c5 = true;
		curOverride.m_OverrideValue_ps_c5[0] = values[0];
		curOverride.m_OverrideValue_ps_c5[1] = values[1];
		curOverride.m_OverrideValue_ps_c5[2] = values[2];
		curOverride.m_OverrideValue_ps_c5[3] = values[3];

		g_OldDirect3DDevice9->SetPixelShaderConstantF(5, curOverride.m_OverrideValue_ps_c5, 1);
	}

	void OverrideEnd_ps_c5(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_ps_c5)
		{
			curOverride.m_Override_ps_c5 = false;

			g_OldDirect3DDevice9->SetPixelShaderConstantF(5, m_OriginalValue_ps_c5, 1);
		}
	}

	void OverrideBegin_ps_c12_y(float value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_ps_c12_y = true;
		curOverride.m_OverrideValue_ps_c12_y = value;

		float tmp[4] = { m_OriginalValue_ps_c12[0], value, m_OriginalValue_ps_c12[2], m_OriginalValue_ps_c12[3] };
		g_OldDirect3DDevice9->SetPixelShaderConstantF(12, tmp, 1);
	}

	void OverrideEnd_ps_c12_y(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_ps_c12_y)
		{
			curOverride.m_Override_ps_c12_y = false;

			g_OldDirect3DDevice9->SetPixelShaderConstantF(12, m_OriginalValue_ps_c12, 1);
		}
	}

	void OverrideBegin_ps_c29_w(float value)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_ps_c29_w = true;
		curOverride.m_OverrideValue_ps_c29_w = value;

		float tmp[4] = { m_OriginalValue_ps_c29[0], m_OriginalValue_ps_c29[1], m_OriginalValue_ps_c29[2], value };
		g_OldDirect3DDevice9->SetPixelShaderConstantF(29, tmp, 1);
	}

	void OverrideEnd_ps_c29_w(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_ps_c29_w)
		{
			curOverride.m_Override_ps_c29_w = false;

			g_OldDirect3DDevice9->SetPixelShaderConstantF(29, m_OriginalValue_ps_c29, 1);
		}
	}

	void OverrideBegin_ps_c31(float const values[4])
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		curOverride.m_Override_ps_c31 = true;

		curOverride.m_OverrideValue_ps_c31[0] = values[0];
		curOverride.m_OverrideValue_ps_c31[1] = values[1];
		curOverride.m_OverrideValue_ps_c31[2] = values[2];
		curOverride.m_OverrideValue_ps_c31[3] = values[3];

		g_OldDirect3DDevice9->SetPixelShaderConstantF(31, curOverride.m_OverrideValue_ps_c31, 1);
	}

	void OverrideEnd_ps_c31(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_ps_c31)
		{
			curOverride.m_Override_ps_c31 = false;

			g_OldDirect3DDevice9->SetPixelShaderConstantF(31, m_OriginalValue_ps_c31, 1);
		}
	}

	void OverrideBegin_ps_c1(ID3d9HooksFloat4ParamOverride* overrideFn)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_ps_c1 = overrideFn)
		{
			float value[4] = { m_OriginalValue_ps_c1[0], m_OriginalValue_ps_c1[1], m_OriginalValue_ps_c1[2],   m_OriginalValue_ps_c1[3] };

			curOverride.m_Override_ps_c1->D3d9HooksFloat4ParamOverride(value);

			curOverride.m_OverrideValue_ps_c1[0] = value[0];
			curOverride.m_OverrideValue_ps_c1[1] = value[1];
			curOverride.m_OverrideValue_ps_c1[2] = value[2];
			curOverride.m_OverrideValue_ps_c1[3] = value[3];

			float tmp[4] = { value[0], value[1], value[2], value[3] };
			g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
		}
	}

	void OverrideEnd_ps_c1(void)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_ps_c1)
		{
			curOverride.m_Override_ps_c1 = nullptr;

			float tmp[4] = { m_OriginalValue_ps_c1[0], m_OriginalValue_ps_c1[1], m_OriginalValue_ps_c1[2], m_OriginalValue_ps_c1[3] };
			g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
		}
	}

	void OverrideBegin_ps_c30(ID3d9HooksFloat4ParamOverride* overrideFn)
	{
		CAfxOverride& curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_ps_c30 = overrideFn)
		{
			float value[4] = { m_OriginalValue_ps_c30[0], m_OriginalValue_ps_c30[1], m_OriginalValue_ps_c30[2],   m_OriginalValue_ps_c30[3] };

			curOverride.m_Override_ps_c30->D3d9HooksFloat4ParamOverride(value);

			curOverride.m_OverrideValue_ps_c30[0] = value[0];
			curOverride.m_OverrideValue_ps_c30[1] = value[1];
			curOverride.m_OverrideValue_ps_c30[2] = value[2];
			curOverride.m_OverrideValue_ps_c30[3] = value[3];

			float tmp[4] = { value[0], value[1], value[2], value[3] };
			g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
		}
	}

	void OverrideEnd_ps_c30(void)
	{
		CAfxOverride& curOverride = m_OverrideStack.top();

		if (curOverride.m_Override_ps_c30)
		{
			curOverride.m_Override_ps_c30 = nullptr;

			float tmp[4] = { m_OriginalValue_ps_c30[0], m_OriginalValue_ps_c30[1], m_OriginalValue_ps_c30[2], m_OriginalValue_ps_c30[3] };
			g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
		}
	}
	   
	void Block_Present(bool block)
	{
		m_Block_Present = block;
	}

	void Block_Clear(bool block)
	{
		m_Block_Clear = block;
	}

	void OnBefore_AfxHookDirect3DStateBlock9_Capture()
	{
		m_OverrideStack.top().Undo();
	}

	void OnAfter_AfxHookDirect3DStateBlock9_Capture()
	{
		m_OverrideStack.top().Redo();
	}

	void On_AfxHookDirect3DStateBlock9_Applied(const AfxDirtyTrack & dirtyTrack)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if (dirtyTrack.m_D3DRS_BLENDOP_Dirty)
		{
			m_DirtyTrack.m_D3DRS_BLENDOP_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_BLENDOP, &m_D3DRS_BLENDOP);
			if (curOverride.m_Override_D3DRS_BLENDOP)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_BLENDOP, curOverride.m_OverrideValue_D3DRS_BLENDOP);
		}

		if (dirtyTrack.m_D3DRS_SRCBLEND_Dirty)
		{
			m_DirtyTrack.m_D3DRS_SRCBLEND_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_SRCBLEND, &m_D3DRS_SRCBLEND);
			if (curOverride.m_Override_D3DRS_SRCBLEND)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_SRCBLEND, curOverride.m_OverrideValue_D3DRS_SRCBLEND);
		}

		if (dirtyTrack.m_D3DRS_DESTBLEND_Dirty)
		{
			m_DirtyTrack.m_D3DRS_DESTBLEND_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_DESTBLEND, &m_D3DRS_DESTBLEND);
			if (curOverride.m_Override_D3DRS_DESTBLEND)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_DESTBLEND, curOverride.m_OverrideValue_D3DRS_DESTBLEND);
		}

		if (dirtyTrack.m_D3DRS_SRGBWRITEENABLE_Dirty)
		{
			m_DirtyTrack.m_D3DRS_SRGBWRITEENABLE_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_SRGBWRITEENABLE, &m_D3DRS_SRGBWRITEENABLE);
			if (curOverride.m_Override_D3DRS_SRGBWRITEENABLE)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_SRGBWRITEENABLE, curOverride.m_OverrideValue_D3DRS_SRGBWRITEENABLE);
		}

		if (dirtyTrack.m_D3DRS_COLORWRITEENABLE_Dirty)
		{
			m_DirtyTrack.m_D3DRS_COLORWRITEENABLE_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_COLORWRITEENABLE, &m_D3DRS_COLORWRITEENABLE);
			if (curOverride.m_Override_D3DRS_COLORWRITEENABLE)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_COLORWRITEENABLE, curOverride.m_OverrideValue_D3DRS_COLORWRITEENABLE);
		}

		if (dirtyTrack.m_D3DRS_ZWRITEENABLE_Dirty)
		{
			m_DirtyTrack.m_D3DRS_ZWRITEENABLE_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_ZWRITEENABLE, &m_D3DRS_ZWRITEENABLE);
			if (curOverride.m_Override_D3DRS_ZWRITEENABLE)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, curOverride.m_OverrideValue_D3DRS_ZWRITEENABLE);
		}

		if (dirtyTrack.m_D3DRS_ALPHABLENDENABLE_Dirty)
		{
			m_DirtyTrack.m_D3DRS_ALPHABLENDENABLE_Dirty = true;
			g_OldDirect3DDevice9->GetRenderState(D3DRS_ALPHABLENDENABLE, &m_D3DRS_ALPHABLENDENABLE);
			if (curOverride.m_Override_D3DRS_ALPHABLENDENABLE)
				g_OldDirect3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, curOverride.m_OverrideValue_D3DRS_ALPHABLENDENABLE);
		}

		if (dirtyTrack.m_OriginalValue_ps_c0_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c0_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(0, m_OriginalValue_ps_c0, 1);
			if (curOverride.m_Override_ps_c0)
			{
				g_OldDirect3DDevice9->SetPixelShaderConstantF(0, curOverride.m_OverrideValue_ps_c0, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c5_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c5_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(5, m_OriginalValue_ps_c5, 1);
			if (curOverride.m_Override_ps_c5)
			{
				g_OldDirect3DDevice9->SetPixelShaderConstantF(5, curOverride.m_OverrideValue_ps_c5, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c12_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c12_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(12, m_OriginalValue_ps_c12, 1);
			if (curOverride.m_Override_ps_c12_y)
			{
				float tmp[4] = { m_OriginalValue_ps_c12[0], curOverride.m_OverrideValue_ps_c12_y, m_OriginalValue_ps_c12[2], m_OriginalValue_ps_c12[3] };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(12, tmp, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c29_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c29_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(29, m_OriginalValue_ps_c29, 1);
			if (curOverride.m_Override_ps_c29_w)
			{
				float tmp[4] = { m_OriginalValue_ps_c29[0], m_OriginalValue_ps_c29[1], m_OriginalValue_ps_c29[2], curOverride.m_OverrideValue_ps_c29_w };
				g_OldDirect3DDevice9->SetPixelShaderConstantF(29, tmp, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c31_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c31_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(31, m_OriginalValue_ps_c31, 1);
			if (curOverride.m_Override_ps_c31)
			{
				g_OldDirect3DDevice9->SetPixelShaderConstantF(31, curOverride.m_OverrideValue_ps_c31, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c1_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c1_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(1, m_OriginalValue_ps_c1, 1);
			if (curOverride.m_Override_ps_c1)
			{
				float tmp[4] = { m_OriginalValue_ps_c1[0], m_OriginalValue_ps_c1[1],m_OriginalValue_ps_c1[2], m_OriginalValue_ps_c1[3] };
				
				if (curOverride.m_Override_ps_c1)
				{
					curOverride.m_Override_ps_c1->D3d9HooksFloat4ParamOverride(tmp);
				}

				g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
			}
		}

		if (dirtyTrack.m_OriginalValue_ps_c30_Dirty)
		{
			m_DirtyTrack.m_OriginalValue_ps_c30_Dirty = true;
			g_OldDirect3DDevice9->GetPixelShaderConstantF(30, m_OriginalValue_ps_c30, 1);
			if (curOverride.m_Override_ps_c30)
			{
				float tmp[4] = { m_OriginalValue_ps_c30[0], m_OriginalValue_ps_c30[1],m_OriginalValue_ps_c30[2], m_OriginalValue_ps_c30[3] };

				if (curOverride.m_Override_ps_c30)
				{
					curOverride.m_Override_ps_c30->D3d9HooksFloat4ParamOverride(tmp);
				}

				g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
			}
		}

		if(dirtyTrack.m_Original_VertexShader_Dirty)
		{
			m_DirtyTrack.m_Original_VertexShader_Dirty = true;
			IDirect3DVertexShader9 * pShader = 0;
			g_OldDirect3DDevice9->GetVertexShader(&pShader);
			if (curOverride.m_Override_VertexShader)
			{
				if (pShader != curOverride.m_OverrideValue_VertexShader)
				{
					if (m_Original_VertexShader) m_Original_VertexShader->Release();
					m_Original_VertexShader = pShader;
					if (m_Original_VertexShader) m_Original_VertexShader->AddRef();

					g_OldDirect3DDevice9->SetVertexShader(curOverride.m_OverrideValue_VertexShader);
				}
			}
			else
			{
				if (m_Original_VertexShader) m_Original_VertexShader->Release();
				m_Original_VertexShader = pShader;
				if (m_Original_VertexShader) m_Original_VertexShader->AddRef();
			}
		}

		if(dirtyTrack.m_Original_PixelShader_Dirty)
		{
			m_DirtyTrack.m_Original_PixelShader_Dirty = true;
			IDirect3DPixelShader9 * pShader = 0;
			g_OldDirect3DDevice9->GetPixelShader(&pShader);
			if (curOverride.m_Override_PixelShader)
			{
				if (pShader != curOverride.m_OverrideValue_PixelShader)
				{
					if (m_Original_PixelShader) m_Original_PixelShader->Release();
					m_Original_PixelShader = pShader;
					if (m_Original_PixelShader) m_Original_PixelShader->AddRef();

					g_OldDirect3DDevice9->SetPixelShader(curOverride.m_OverrideValue_PixelShader);
				}
			}
			else
			{
				if (m_Original_PixelShader) m_Original_PixelShader->Release();
				m_Original_PixelShader = pShader;
				if (m_Original_PixelShader) m_Original_PixelShader->AddRef();
			}
		}

	}

	void AfxPushOverrideState(bool clean)
	{
		m_OverrideStack.top().Undo();

		if (clean)
			m_OverrideStack.emplace(*this);
		else
			m_OverrideStack.push(m_OverrideStack.top()); // Copy top state and push it onto stack.

		m_OverrideStack.top().Redo();
	}

	void AfxPopOverrideState(void)
	{
		m_OverrideStack.top().Undo();

		m_OverrideStack.pop();

		m_OverrideStack.top().Redo();
	}


    /*** IUnknown methods ***/

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) {

		if (riid == __uuidof(IDirect3DDevice9Ex))
		{
			if (ppvObj) ppvObj = NULL;
			return E_NOINTERFACE; // If we shoved in D3D9Ex, make sure CS:GO does not notice it.
		}

		return g_OldDirect3DDevice9->QueryInterface(riid, ppvObj);
	}


	STDMETHOD_(ULONG,AddRef)(THIS)
	{
		ULONG result = g_OldDirect3DDevice9->AddRef();

		++g_NewDirect3DDevice9_RefCount;

		return result;
	}

    STDMETHOD_(ULONG,Release)(THIS)
	{
		--g_NewDirect3DDevice9_RefCount;

		if(0 == g_NewDirect3DDevice9_RefCount)
		{
			Shared_Direct3DDevice9_Shutdown();

			if (NULL != m_CurrentState)
			{
				m_CurrentState->Release();
				m_CurrentState = NULL;
			}

			if (NULL != m_InitialState)
			{
				m_InitialState->Release();
				m_InitialState = NULL;
			}

			if(m_Original_VertexShader)
			{
				m_Original_VertexShader->Release();
				m_Original_VertexShader = 0;
			}

			if(m_Original_PixelShader)
			{
				m_Original_PixelShader->Release();
				m_Original_PixelShader = 0;
			}
		}

		return g_OldDirect3DDevice9->Release();
	}


    /*** IDirect3DDevice9 methods ***/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, TestCooperativeLevel);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetAvailableTextureMem);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, EvictManagedResources);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetDirect3D);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetDeviceCaps);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetDisplayMode);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetCreationParameters);
    
	STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot, UINT YHotSpot, IDirect3DSurface9* pCursorBitmap)
	{
		return g_OldDirect3DDevice9->SetCursorProperties(XHotSpot, YHotSpot, UnwrapSurface(pCursorBitmap));
	}

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetCursorPosition);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, ShowCursor);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateAdditionalSwapChain);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetSwapChain);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetNumberOfSwapChains);

	void Afx_Reset_Before(D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX *pFullscreenDisplayMode)
	{
		if (pPresentationParameters)
		{
			FixPresentationParementers(pPresentationParameters);
		}

#ifdef AFX_MIRV_PGL
		MirvPgl::D3D9_Reset();
#endif

		AfxHookSource::Gui::On_Direct3DDevice9_Reset_Before();

		g_CampathDrawer.Reset();

		if (NULL != m_CurrentState)
		{
			m_CurrentState->Release();
			m_CurrentState = NULL;
		}

		if (NULL != m_InitialState)
		{
			m_InitialState->Release();
			m_InitialState = NULL;
		}

		if (r32fRenderTarget) {
			r32fRenderTarget->Release();
			r32fRenderTarget = nullptr;
		}

		if (trackedRenderTarget)
		{
#ifdef AFX_INTEROP
			if (AfxInterop::MainEnabled())
			{
				AfxInterop::OnReleaseSurface(trackedRenderTarget);
			}
#endif

			trackedRenderTarget->Release();
			trackedRenderTarget = nullptr;
		}

		if (trackedDepthStencil)
		{
			trackedDepthStencil->Release();
			trackedDepthStencil = nullptr;
		}

#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			AfxInterop::DrawingThread_DeviceLost();

			ReleaseQueries();

			/*
			CAfxManagedChildDirect3DSurface9::AfxDeviceLost();
			CAfxManagedDirect3DTexture9::AfxDeviceLost();
			CAfxManagedDirect3DVolumeTexture9::AfxDeviceLost();
			CAfxManagedDirect3DCubeTexture9::AfxDeviceLost();
			CAfxManagedOffscreenPlainSurface::AfxDeviceLost();
			CAfxManagedDirect3DVertexBuffer9::AfxDeviceLost();
			CAfxManagedDirect3DIndexBuffer9::AfxDeviceLost();
			*/
		}
#endif
	}

	void Afx_Reset_After(HRESULT hResult, D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX *pFullscreenDisplayMode)
	{
		if (SUCCEEDED(hResult))
		{
#if AFX_INTEROP
			if (AfxInterop::Enabled())
			{
				CreateQueries();

				AfxInterop::DrawingThread_DeviceRestored();
			}
#endif
			HookInitialBuffers();

			if (NULL != m_InitialState)
			{
				m_InitialState->Release();
				m_InitialState = NULL;
			}
			g_OldDirect3DDevice9->CreateStateBlock(D3DSBT_ALL, &m_InitialState);
			if (m_InitialState) m_InitialState->Capture();
		}

		AfxHookSource::Gui::On_Direct3DDevice9_Reset_After();
	}

	void AfxBeginCleanState()
	{
		if (NULL == m_CurrentState)
		{
			g_OldDirect3DDevice9->CreateStateBlock(D3DSBT_ALL, &m_CurrentState);
			if (m_CurrentState) m_CurrentState->Capture();
		}

		if (m_InitialState) m_InitialState->Apply();
	}

	void AfxEndCleanState()
	{
		if (m_CurrentState)
		{
			m_CurrentState->Apply();
			m_CurrentState->Release();
			m_CurrentState = NULL;
		}
	}
    
	STDMETHOD(Reset)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters)
	{
		Afx_Reset_Before(pPresentationParameters, NULL);

		HRESULT hResult = g_OldDirect3DDevice9->Reset(pPresentationParameters);

		Afx_Reset_After(hResult, pPresentationParameters, NULL);

		return hResult;
	}

	void Afx_Present_Before(CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion, DWORD dwFlags)
	{
#if AFX_INTEROP
		if (AfxInterop::MainEnabled())
		{
			if (CAfxTrackedSurface * afxTrackedSurface = trackedRenderTarget)
			{
				if (IDirect3DSurface9 * sharedSurface = afxTrackedSurface->AfxGetReplacement())
				{
					// TODO: This might mess up state:
					g_OldDirect3DDevice9->StretchRect(sharedSurface, pSourceRect, afxTrackedSurface->AfxGetSurface(), pDestRect, D3DTEXF_NONE);
				}
			}
		}
#endif
	}

	void Afx_Present_After(HRESULT hResult)
	{
		AfxHookSource::Gui::On_Direct3DDevice9_Present(hResult == D3DERR_DEVICELOST);

#ifdef AFX_MIRV_PGL
		MirvPgl::DrawingThread_UnleashData();
#endif
	}

    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion)
	{
		if (m_Block_Present)
			return D3D_OK;

		if (g_ReShadeAdvancedfx.IsConnected() && !g_ReShadeAdvancedfx.HasRendered()) {
			g_ReShadeAdvancedfx.AdvancedfxRenderEffects(nullptr, nullptr);
		}

		Afx_Present_Before(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, 0);

		HRESULT result = g_OldDirect3DDevice9->Present(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion);

		Afx_Present_After(result);

		g_ReShadeAdvancedfx.ResetHasRendered();

		return result;
	}

	STDMETHOD(GetBackBuffer)(THIS_ UINT iSwapChain, UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface9** ppBackBuffer)
	{
		HRESULT result = g_OldDirect3DDevice9->GetBackBuffer(iSwapChain, iBackBuffer, Type, ppBackBuffer);

		if (SUCCEEDED(result) && ppBackBuffer) *ppBackBuffer = UnwrapSurfaceReverse(*ppBackBuffer, true);

		return result;
	}

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetRasterStatus);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetDialogBoxMode);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetGammaRamp);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetGammaRamp);

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateTexture);
/*/
	STDMETHOD(CreateTexture)(THIS_ UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture9** ppTexture, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DTexture9 * pSystemMemPoolTexture;
				HRESULT result = g_OldDirect3DDevice9->CreateTexture(Width, Height, Levels, Usage, Format, D3DPOOL_SYSTEMMEM, &pSystemMemPoolTexture, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedDirect3DTexture9 * texture = new CAfxManagedDirect3DTexture9(Width, Height, Levels, Usage, Format, pSystemMemPoolTexture);
					
					if (FAILED(pSystemMemPoolTexture->SetPrivateData(IID_CAfxManagedDirect3DTexture9, &texture, sizeof(texture), 0)))
					{
						texture->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppTexture = texture;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture, pSharedHandle);
	}
*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateVolumeTexture);
	/*
	STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture9** ppVolumeTexture, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DVolumeTexture9 * pSystemMemPoolTexture;
				HRESULT result = g_OldDirect3DDevice9->CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, D3DPOOL_SYSTEMMEM, &pSystemMemPoolTexture, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedDirect3DVolumeTexture9 * texture = new CAfxManagedDirect3DVolumeTexture9(Width, Height, Depth, Levels, Usage, Format, pSystemMemPoolTexture);
					
					if (FAILED(pSystemMemPoolTexture->SetPrivateData(IID_CAfxManagedDirect3DVolumeTexture9, &texture, sizeof(texture), 0)))
					{
						texture->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppVolumeTexture = texture;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture, pSharedHandle);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateCubeTexture);
	/*
	STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture9** ppCubeTexture, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DCubeTexture9 * pSystemMemPoolTexture;
				HRESULT result = g_OldDirect3DDevice9->CreateCubeTexture(EdgeLength, Levels, Usage, Format, D3DPOOL_SYSTEMMEM, &pSystemMemPoolTexture, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedDirect3DCubeTexture9 * texture = new CAfxManagedDirect3DCubeTexture9(EdgeLength, Levels, Usage, Format, pSystemMemPoolTexture);

					if (FAILED(pSystemMemPoolTexture->SetPrivateData(IID_CAfxManagedDirect3DCubeTexture9, &texture, sizeof(texture), 0)))
					{
						texture->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppCubeTexture = texture;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture, pSharedHandle);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateVertexBuffer);
	/*
	STDMETHOD(CreateVertexBuffer)(THIS_ UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer9** ppVertexBuffer, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DVertexBuffer9 * pSystemMemPool;
				HRESULT result = g_OldDirect3DDevice9->CreateVertexBuffer(Length, Usage, FVF, D3DPOOL_SYSTEMMEM, &pSystemMemPool, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedDirect3DVertexBuffer9 * buffer = new CAfxManagedDirect3DVertexBuffer9(Length, Usage, FVF, pSystemMemPool);

					if (FAILED(pSystemMemPool->SetPrivateData(IID_CAfxManagedDirect3DVertexBuffer9, &buffer, sizeof(buffer), 0)))
					{
						buffer->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppVertexBuffer = buffer;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer, pSharedHandle);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateIndexBuffer);
	/*
	STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer9** ppIndexBuffer, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DIndexBuffer9 * pSystemMemPool;
				HRESULT result = g_OldDirect3DDevice9->CreateIndexBuffer(Length, Usage, Format, D3DPOOL_SYSTEMMEM, &pSystemMemPool, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedDirect3DIndexBuffer9 * buffer = new CAfxManagedDirect3DIndexBuffer9(Length, Usage, Format, pSystemMemPool);

					if (FAILED(pSystemMemPool->SetPrivateData(IID_CAfxManagedDirect3DIndexBuffer9, &buffer, sizeof(buffer), 0)))
					{
						buffer->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppIndexBuffer = buffer;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer, pSharedHandle);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateRenderTarget);
	/*
	STDMETHOD(CreateRenderTarget)(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
	{

		return g_OldDirect3DDevice9->CreateRenderTarget(Width, Height, Format, MultiSample, MultisampleQuality, Lockable, ppSurface, pSharedHandle);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateDepthStencilSurface);
	/*
	STDMETHOD(CreateDepthStencilSurface)(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Discard, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
	{

		return g_OldDirect3DDevice9->CreateDepthStencilSurface(Width, Height, Format, MultiSample, MultisampleQuality, Discard, ppSurface, pSharedHandle);
	}
	*/

	STDMETHOD(UpdateSurface)(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestinationSurface, CONST POINT* pDestPoint)
	{
		return g_OldDirect3DDevice9->UpdateSurface(UnwrapSurface(pSourceSurface), pSourceRect, UnwrapSurface(pDestinationSurface), pDestPoint);
	}

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, UpdateTexture);
	/*
	STDMETHOD(UpdateTexture)(THIS_ IDirect3DBaseTexture9* pSourceTexture, IDirect3DBaseTexture9* pDestinationTexture)
	{
		return g_OldDirect3DDevice9->UpdateTexture(UnwrapTexture(pSourceTexture), UnwrapTexture(pDestinationTexture));
	}
	*/

	STDMETHOD(GetRenderTargetData)(THIS_ IDirect3DSurface9* pRenderTarget, IDirect3DSurface9* pDestSurface)
	{
		return g_OldDirect3DDevice9->GetRenderTargetData(UnwrapSurface(pRenderTarget), UnwrapSurface(pDestSurface));
	}

	STDMETHOD(GetFrontBufferData)(THIS_ UINT iSwapChain, IDirect3DSurface9* pDestSurface)
	{
		return g_OldDirect3DDevice9->GetFrontBufferData(iSwapChain, UnwrapSurface(pDestSurface));
	}

	STDMETHOD(StretchRect)(THIS_ IDirect3DSurface9* pSourceSurface, CONST RECT* pSourceRect, IDirect3DSurface9* pDestSurface, CONST RECT* pDestRect, D3DTEXTUREFILTERTYPE Filter)
	{
		return g_OldDirect3DDevice9->StretchRect(UnwrapSurface(pSourceSurface), pSourceRect, UnwrapSurface(pDestSurface), pDestRect, Filter);
	}

	STDMETHOD(ColorFill)(THIS_ IDirect3DSurface9* pSurface, CONST RECT* pRect, D3DCOLOR color)
	{
		return g_OldDirect3DDevice9->ColorFill(UnwrapSurface(pSurface), pRect, color);
	}

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateOffscreenPlainSurface);
	/*
	STDMETHOD(CreateOffscreenPlainSurface)(THIS_ UINT Width, UINT Height, D3DFORMAT Format, D3DPOOL Pool, IDirect3DSurface9** ppSurface, HANDLE* pSharedHandle)
	{
#if AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			if (Pool == D3DPOOL_MANAGED)
			{
				IDirect3DSurface9 * pSystemMemPool;
				HRESULT result = g_OldDirect3DDevice9->CreateOffscreenPlainSurface(Width, Height, Format, Pool, &pSystemMemPool, pSharedHandle);

				if (SUCCEEDED(result))
				{
					CAfxManagedOffscreenPlainSurface * surface = new CAfxManagedOffscreenPlainSurface(Width, Height, 0, Format, Pool, D3DMULTISAMPLE_NONE, 0, pSystemMemPool);

					if (FAILED(pSystemMemPool->SetPrivateData(IID_CAfxManagedOffscreenPlainSurface, &surface, sizeof(surface), 0)))
					{
						surface->Release();
						return D3DERR_NOTAVAILABLE;
					}

					*ppSurface = surface;
				}

				return result;
			}
		}
#endif

		return g_OldDirect3DDevice9->CreateOffscreenPlainSurface(Width, Height, Format, Pool, ppSurface, pSharedHandle);
	}
	*/

	STDMETHOD(SetRenderTarget)(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9* pRenderTarget)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::MainEnabled())
		{
			if (CAfxTrackedSurface * afxTrackedSurface = CAfxTrackedSurface::Get(pRenderTarget))
			{
				AfxInterop::OnSetRenderTarget(RenderTargetIndex, afxTrackedSurface);
			}
			else
			{
				AfxInterop::OnSetRenderTarget(RenderTargetIndex, nullptr);
			}
		}
#endif

		return g_OldDirect3DDevice9->SetRenderTarget(RenderTargetIndex, UnwrapSurface(pRenderTarget));
	}

	STDMETHOD(GetRenderTarget)(THIS_ DWORD RenderTargetIndex, IDirect3DSurface9** ppRenderTarget)
	{
		HRESULT result = g_OldDirect3DDevice9->GetRenderTarget(RenderTargetIndex, ppRenderTarget);

		if (SUCCEEDED(result && ppRenderTarget))
		{
			*ppRenderTarget = UnwrapSurfaceReverse(*ppRenderTarget, true);
		}

		return result;
	}

	STDMETHOD(SetDepthStencilSurface)(THIS_ IDirect3DSurface9* pNewZStencil)
	{
		return g_OldDirect3DDevice9->SetDepthStencilSurface(UnwrapSurface(pNewZStencil));
	}

	STDMETHOD(GetDepthStencilSurface)(THIS_ IDirect3DSurface9** ppZStencilSurface)
	{
		HRESULT result = g_OldDirect3DDevice9->GetDepthStencilSurface(ppZStencilSurface);

		if (SUCCEEDED(result) && ppZStencilSurface)
		{
			*ppZStencilSurface = UnwrapSurfaceReverse(*ppZStencilSurface, true);
		}

		return result;
	}

	STDMETHOD(BeginScene)(THIS)
	{
		return g_OldDirect3DDevice9->BeginScene();
	}

    STDMETHOD(EndScene)(THIS)
	{
		Shared_Direct3DDevice9_EndScene();
		
		g_bD3D9DebugPrint = false;

		return g_OldDirect3DDevice9->EndScene();
	}

    STDMETHOD(Clear)(THIS_ DWORD Count,CONST D3DRECT* pRects,DWORD Flags,D3DCOLOR Color,float Z,DWORD Stencil)
	{
		if(g_bD3D9DebugPrint)
		{
			Tier0_Msg("Clear:");
			Tier0_Msg(" Flags=");
			if(Flags & D3DCLEAR_STENCIL) Tier0_Msg("|D3DCLEAR_STENCIL");
			if(Flags & D3DCLEAR_TARGET) Tier0_Msg("|D3DCLEAR_TARGET");
			if(Flags & D3DCLEAR_ZBUFFER) Tier0_Msg("|D3DCLEAR_ZBUFFER");
			Tier0_Msg(" Color=0x%08x", Color);
			Tier0_Msg(" Z=%f",Z);
			Tier0_Msg("\n");
		}

		if (m_Block_Clear)
			return D3D_OK;

		return g_OldDirect3DDevice9->Clear(Count, pRects, Flags, Color, Z, Stencil);
	}

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetTransform);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetTransform);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, MultiplyTransform);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetViewport);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetViewport);
    
	STDMETHOD(SetMaterial)(THIS_ CONST D3DMATERIAL9* pMaterial)
	{
		return g_OldDirect3DDevice9->SetMaterial(pMaterial);
	}

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetMaterial);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetLight);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetLight);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, LightEnable);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetLightEnable);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetClipPlane);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetClipPlane);
    
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD Value)
	{
		if(g_bD3D9DebugPrint)
		{
			Tier0_Msg("SetRenderState: ");

			switch(State)
			{
			case D3DRS_ZWRITEENABLE:
				Tier0_Msg("D3DRS_ZWRITEENABLE: %s",
					Value & TRUE  ? "TRUE" : "false"
					);
				break;
			case D3DRS_ZFUNC:
				Tier0_Msg("D3DRS_ZFUNC: ");
				switch(Value)
				{
				case D3DCMP_NEVER:
					Tier0_Msg("D3DCMP_NEVER");
					break;
				case D3DCMP_LESS:
					Tier0_Msg("D3DCMP_LESS");
					break;
				case D3DCMP_EQUAL:
					Tier0_Msg("D3DCMP_EQUAL");
					break;
				case D3DCMP_LESSEQUAL:
					Tier0_Msg("D3DCMP_LESSEQUAL");
					break;
				case D3DCMP_GREATER:
					Tier0_Msg("D3DCMP_GREATER");
					break;
				case D3DCMP_NOTEQUAL:
					Tier0_Msg("D3DCMP_NOTEQUAL");
					break;
				case D3DCMP_GREATEREQUAL:
					Tier0_Msg("D3DCMP_GREATEREQUAL");
					break;
				case D3DCMP_ALWAYS:
					Tier0_Msg("D3DCMP_ALWAYS");
					break;
				default:
					Tier0_Msg("other");
				}
				break;
			case D3DRS_COLORWRITEENABLE:
				Tier0_Msg("D3DRS_COLORWRITEENABLE: R:%s G:%s B:%s A:%s",
					Value & D3DCOLORWRITEENABLE_RED ? "ON" : "off",
					Value & D3DCOLORWRITEENABLE_GREEN ? "ON" : "off",
					Value & D3DCOLORWRITEENABLE_BLUE ? "ON" : "off",
					Value & D3DCOLORWRITEENABLE_ALPHA ? "ON" : "off"
					);
				break;
			case D3DRS_MULTISAMPLEANTIALIAS:
				Tier0_Msg("D3DRS_MULTISAMPLEANTIALIAS: %s",Value & TRUE  ? "TRUE" : "false");
				break;
			case D3DRS_ANTIALIASEDLINEENABLE:
				Tier0_Msg("D3DRS_ANTIALIASEDLINEENABLE: %s",Value & TRUE  ? "TRUE" : "false");
				break;
			case D3DRS_POINTSIZE:
				Tier0_Msg("D3DRS_POINTSIZE: %f",*(float *)&Value);
				break;
			case D3DRS_POINTSIZE_MIN:
				Tier0_Msg("D3DRS_POINTSIZE_MIN: %f",*(float *)&Value);
				break;
			case D3DRS_POINTSIZE_MAX:
				Tier0_Msg("D3DRS_POINTSIZE_MAX: %f",*(float *)&Value);
				break;
			case D3DRS_SEPARATEALPHABLENDENABLE:
				Tier0_Msg("D3DRS_SEPARATEALPHABLENDENABLE: %i",Value);
				break;
			default:
				Tier0_Msg("other: %i: %i",State,Value);
			}

			Tier0_Msg("\n");

		}

		CAfxOverride & curOverride = m_OverrideStack.top();

		switch(State)
		{
		case D3DRS_BLENDOP:
			m_DirtyTrack.m_D3DRS_BLENDOP_Dirty = true;
			m_D3DRS_BLENDOP = Value;
			if (curOverride.m_Override_D3DRS_BLENDOP)
				return D3D_OK;
			break;
		case D3DRS_SRCBLEND:
			m_DirtyTrack.m_D3DRS_SRCBLEND_Dirty = true;
			m_D3DRS_SRCBLEND = Value;
			if(curOverride.m_Override_D3DRS_SRCBLEND)
				return D3D_OK;
			break;
		case D3DRS_DESTBLEND:
			m_DirtyTrack.m_D3DRS_DESTBLEND_Dirty = true;
			m_D3DRS_DESTBLEND = Value;
			if(curOverride.m_Override_D3DRS_DESTBLEND)
				return D3D_OK;
			break;
		case D3DRS_SRGBWRITEENABLE:
			m_DirtyTrack.m_D3DRS_SRGBWRITEENABLE_Dirty = true;
			m_D3DRS_SRGBWRITEENABLE = Value;
			if(curOverride.m_Override_D3DRS_SRGBWRITEENABLE)
				return D3D_OK;
			break;
		case D3DRS_COLORWRITEENABLE:
			m_DirtyTrack.m_D3DRS_COLORWRITEENABLE_Dirty = true;
			m_D3DRS_COLORWRITEENABLE = Value;
			if (curOverride.m_Override_D3DRS_COLORWRITEENABLE)
				return D3D_OK;
			break;
		case D3DRS_ZWRITEENABLE:
			m_DirtyTrack.m_D3DRS_ZWRITEENABLE_Dirty = true;
			m_D3DRS_ZWRITEENABLE = Value;
			if(curOverride.m_Override_D3DRS_ZWRITEENABLE)
				return D3D_OK;
			break;
		case D3DRS_ALPHABLENDENABLE:
			m_DirtyTrack.m_D3DRS_ALPHABLENDENABLE_Dirty = true;
			m_D3DRS_ALPHABLENDENABLE = Value;
			if(curOverride.m_Override_D3DRS_ALPHABLENDENABLE)
				return D3D_OK;
			break;
		}

		return g_OldDirect3DDevice9->SetRenderState(State, Value);
	}

    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD* pValue)
	{
		if(pValue)
		{
			CAfxOverride & curOverride = m_OverrideStack.top();

			switch(State)
			{
			case D3DRS_BLENDOP:
				if (curOverride.m_Override_D3DRS_BLENDOP)
				{
					*pValue = m_D3DRS_BLENDOP;
					return D3D_OK;
				}
				break;
			case D3DRS_SRCBLEND:
				if(curOverride.m_Override_D3DRS_SRCBLEND)
				{
					*pValue = m_D3DRS_SRCBLEND;
					return D3D_OK;
				}
				break;
			case D3DRS_DESTBLEND:
				if(curOverride.m_Override_D3DRS_DESTBLEND)
				{
					*pValue = m_D3DRS_DESTBLEND;
					return D3D_OK;
				}
				break;
			case D3DRS_SRGBWRITEENABLE:
				if(curOverride.m_Override_D3DRS_SRGBWRITEENABLE)
				{
					*pValue = m_D3DRS_SRGBWRITEENABLE;
					return D3D_OK;
				}
				break;
			case D3DRS_COLORWRITEENABLE:
				if (curOverride.m_Override_D3DRS_COLORWRITEENABLE)
				{
					*pValue = m_D3DRS_COLORWRITEENABLE;
					return D3D_OK;
				}
				break;
			case D3DRS_ZWRITEENABLE:
				if(curOverride.m_Override_D3DRS_ZWRITEENABLE)
				{
					*pValue = m_D3DRS_ZWRITEENABLE;
					return D3D_OK;
				}
				break;
			case D3DRS_ALPHABLENDENABLE:
				{
					if(curOverride.m_Override_D3DRS_ALPHABLENDENABLE)
					{
						*pValue = m_D3DRS_ALPHABLENDENABLE;
						return D3D_OK;
					}
				}
				break;
			}
		}
			
		return g_OldDirect3DDevice9->GetRenderState(State, pValue);
	}

	STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type,IDirect3DStateBlock9** ppSB)
	{
		m_OverrideStack.top().Undo();

		HRESULT hResult = g_OldDirect3DDevice9->CreateStateBlock(Type, ppSB);

		m_OverrideStack.top().Redo();

		if(SUCCEEDED(hResult) && ppSB && *ppSB)
		{
			m_DirtyTrack.m_D3DRS_BLENDOP_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_SRCBLEND_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_DESTBLEND_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_SRGBWRITEENABLE_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_COLORWRITEENABLE_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_ZWRITEENABLE_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_D3DRS_ALPHABLENDENABLE_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c0_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c5_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c12_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c29_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c31_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c1_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_OriginalValue_ps_c30_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;
			m_DirtyTrack.m_Original_VertexShader_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_VERTEXSTATE;
			m_DirtyTrack.m_Original_PixelShader_Dirty = Type == D3DSBT_ALL || Type == D3DSBT_PIXELSTATE;

			*ppSB = new CAfxHookDirect3DStateBlock9(*ppSB, m_DirtyTrack);
		}

		return hResult;
	}

	STDMETHOD(BeginStateBlock)(THIS) {
		m_DirtyTrack.m_D3DRS_BLENDOP_Dirty = false;
		m_DirtyTrack.m_D3DRS_SRCBLEND_Dirty = false;
		m_DirtyTrack.m_D3DRS_DESTBLEND_Dirty = false;
		m_DirtyTrack.m_D3DRS_SRGBWRITEENABLE_Dirty = false;
		m_DirtyTrack.m_D3DRS_COLORWRITEENABLE_Dirty = false;
		m_DirtyTrack.m_D3DRS_ZWRITEENABLE_Dirty = false;
		m_DirtyTrack.m_D3DRS_ALPHABLENDENABLE_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c0_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c5_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c12_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c29_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c31_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c1_Dirty = false;
		m_DirtyTrack.m_OriginalValue_ps_c30_Dirty = false;
		m_DirtyTrack.m_Original_VertexShader_Dirty = false;
		m_DirtyTrack.m_Original_PixelShader_Dirty = false;

		return g_OldDirect3DDevice9->BeginStateBlock();
	}

    
	STDMETHOD(EndStateBlock)(THIS_ IDirect3DStateBlock9** ppSB)
	{
		HRESULT hResult = g_OldDirect3DDevice9->EndStateBlock(ppSB);

		if(SUCCEEDED(hResult) && ppSB && *ppSB)
		{
			*ppSB = new CAfxHookDirect3DStateBlock9(*ppSB, m_DirtyTrack);
		}

		return hResult;
	}

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetClipStatus);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetClipStatus);
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetTexture);
	/*
	STDMETHOD(GetTexture)(THIS_ DWORD Stage, IDirect3DBaseTexture9** ppTexture)
	{
		HRESULT result = g_OldDirect3DDevice9->GetTexture(Stage, ppTexture);

		if (SUCCEEDED(result) && ppTexture)
		{
			*ppTexture = UnwrapTextureReverse(*ppTexture, true);
		}

		return result;
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetTexture);
	/*
	STDMETHOD(SetTexture)(THIS_ DWORD Stage, IDirect3DBaseTexture9* pTexture)
	{
#ifdef AFX_INTEROP
		if (AfxInterop::Enabled() && pTexture)
		{
			pTexture = UnwrapTexture(pTexture);
		}
#endif

		return g_OldDirect3DDevice9->SetTexture(Stage, pTexture);
	}
	*/

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetTextureStageState);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetTextureStageState);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetSamplerState);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetSamplerState);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, ValidateDevice);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetPaletteEntries);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetPaletteEntries);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetCurrentTexturePalette);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetCurrentTexturePalette);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetScissorRect);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetScissorRect);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetSoftwareVertexProcessing);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetSoftwareVertexProcessing);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetNPatchMode);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetNPatchMode);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawPrimitive);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawIndexedPrimitive);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawPrimitiveUP);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawIndexedPrimitiveUP);
	

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, ProcessVertices);
	/*
	STDMETHOD(ProcessVertices)(THIS_ UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer9* pDestBuffer, IDirect3DVertexDeclaration9* pVertexDecl, DWORD Flags)
	{
		return g_OldDirect3DDevice9->ProcessVertices(SrcStartIndex, DestIndex, VertexCount, UnwrapVertexBuffer(pDestBuffer), pVertexDecl, Flags);
	}
	*/

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateVertexDeclaration);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetVertexDeclaration);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetVertexDeclaration);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetFVF);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetFVF);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateVertexShader);  
    
    STDMETHOD(SetVertexShader)(THIS_ IDirect3DVertexShader9* pShader)
	{
		m_DirtyTrack.m_Original_VertexShader_Dirty = true;

		CAfxOverride & curOverride = m_OverrideStack.top();

		if(g_bD3D9DumpVertexShader)
		{
			g_bD3D9DumpVertexShader = false;

			if(pShader)
			{
				UINT size;
				if(SUCCEEDED(pShader->GetFunction(0, &size)))
				{
					void * pData = malloc(size);

					if(pData && SUCCEEDED(pShader->GetFunction(pData,&size)))
					{
						FILE * f1 = fopen("AfxVertexShaderDump.fxo","wb");
						if(f1)
						{
							fwrite(pData,size,1,f1);
							fclose(f1);
						}
					}

					free(pData);
				}
			}
		}
		
		if(m_Original_VertexShader) m_Original_VertexShader->Release();
		m_Original_VertexShader = pShader;
		if(pShader) pShader->AddRef();

		return !curOverride.m_Override_VertexShader ? g_OldDirect3DDevice9->SetVertexShader(pShader) : D3D_OK;
	}

    STDMETHOD(GetVertexShader)(THIS_ IDirect3DVertexShader9** ppShader)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_VertexShader && ppShader)
		{
			*ppShader = m_Original_VertexShader;
			return D3D_OK;
		}

		return g_OldDirect3DDevice9->GetVertexShader(ppShader);
	}
	
    STDMETHOD(SetVertexShaderConstantF)(THIS_ UINT StartRegister,CONST float* pConstantData,UINT Vector4fCount)
	{
		if(g_bD3D9DebugPrint)
		{
			int lo = StartRegister;
			int hi = StartRegister+Vector4fCount;
			bool inRange = lo <= 8 && 8 < hi || lo <= 9 && 9 < hi || lo <= 10 && 10 < hi || lo <= 11 && 11 < hi;

			if(inRange)
			{
				int min = lo;
				if(8>min) min = 8;

				int maxC = hi;
				if(12<maxC) maxC = 12;

				Tier0_Msg("SetVertexShaderConstantF:\n");
				for(int i=min; i<maxC; i++)
				{
					int idx = i - StartRegister;
					Tier0_Msg("\t%i: %f %f %f %f\n", i, pConstantData[4*idx+0], pConstantData[4*idx+1], pConstantData[4*idx+2], pConstantData[4*idx+3]);
				}
			}
		}

		return g_OldDirect3DDevice9->SetVertexShaderConstantF(StartRegister, pConstantData, Vector4fCount);
	}
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetVertexShaderConstantF);
	
    STDMETHOD(SetVertexShaderConstantI)(THIS_ UINT StartRegister,CONST int* pConstantData,UINT Vector4iCount)
	{
		return g_OldDirect3DDevice9->SetVertexShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	}
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetVertexShaderConstantI);
	
    STDMETHOD(SetVertexShaderConstantB)(THIS_ UINT StartRegister,CONST BOOL* pConstantData,UINT  BoolCount)
	{
		return g_OldDirect3DDevice9->SetVertexShaderConstantB(StartRegister, pConstantData, BoolCount);
	}
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetVertexShaderConstantB);
    
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetStreamSource);
	/*
	STDMETHOD(SetStreamSource)(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9* pStreamData, UINT OffsetInBytes, UINT Stride)
	{
		return g_OldDirect3DDevice9->SetStreamSource(StreamNumber, UnwrapVertexBuffer(pStreamData), OffsetInBytes, Stride);
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetStreamSource);
	/*
	STDMETHOD(GetStreamSource)(THIS_ UINT StreamNumber, IDirect3DVertexBuffer9** ppStreamData, UINT* pOffsetInBytes, UINT* pStride)
	{
		HRESULT result = g_OldDirect3DDevice9->GetStreamSource(StreamNumber, ppStreamData, pOffsetInBytes, pStride);

		if (ppStreamData) *ppStreamData = UnwrapVertexBufferReverse(*ppStreamData, true);

		return result;
	}
	*/

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetStreamSourceFreq);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetStreamSourceFreq);
    

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, SetIndices);
	/*
	STDMETHOD(SetIndices)(THIS_ IDirect3DIndexBuffer9* pIndexData)
	{
		return g_OldDirect3DDevice9->SetIndices(UnwrapIndexBuffer(pIndexData));
	}
	*/

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetIndices);
	/*
	STDMETHOD(GetIndices)(THIS_ IDirect3DIndexBuffer9** ppIndexData)
	{
		HRESULT result = g_OldDirect3DDevice9->GetIndices(ppIndexData);

		if (ppIndexData) *ppIndexData = UnwrapIndexBufferReverse(*ppIndexData, true);

		return result;
	}
	*/

    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreatePixelShader);
    
    STDMETHOD(SetPixelShader)(THIS_ IDirect3DPixelShader9* pShader)
	{
		m_DirtyTrack.m_Original_PixelShader_Dirty = true;

		CAfxOverride & curOverride = m_OverrideStack.top();

		if(g_bD3D9DumpPixelShader)
		{
			g_bD3D9DumpPixelShader = false;

			if(pShader)
			{
				UINT size;
				if(SUCCEEDED(pShader->GetFunction(0, &size)))
				{
					void * pData = malloc(size);

					if(pData && SUCCEEDED(pShader->GetFunction(pData,&size)))
					{
						FILE * f1 = fopen("AfxPixelShaderDump.fxo","wb");
						if(f1)
						{
							fwrite(pData,size,1,f1);
							fclose(f1);
						}
					}

					free(pData);
				}
			}
		}

		if(m_Original_PixelShader) m_Original_PixelShader->Release();
		m_Original_PixelShader = pShader;
		if(pShader) pShader->AddRef();

		return !curOverride.m_Override_PixelShader ? g_OldDirect3DDevice9->SetPixelShader(pShader) : D3D_OK;
	}
    
    STDMETHOD(GetPixelShader)(THIS_ IDirect3DPixelShader9** ppShader)
	{
		CAfxOverride & curOverride = m_OverrideStack.top();

		if(curOverride.m_Override_PixelShader && ppShader)
		{
			*ppShader = m_Original_PixelShader;
			return D3D_OK;
		}

		return g_OldDirect3DDevice9->GetPixelShader(ppShader);
	}
	
    STDMETHOD(SetPixelShaderConstantF)(THIS_ UINT StartRegister,CONST float* pConstantData,UINT Vector4fCount)
	{
		HRESULT result = g_OldDirect3DDevice9->SetPixelShaderConstantF(StartRegister, pConstantData, Vector4fCount);

		if(pConstantData)
		{
			CAfxOverride & curOverride = m_OverrideStack.top();

			if(StartRegister <= 0 && 0 < StartRegister+Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c0_Dirty = true;
				m_OriginalValue_ps_c0[0] = pConstantData[4*(0 -StartRegister)+0];
				m_OriginalValue_ps_c0[1] = pConstantData[4*(0 -StartRegister)+1];
				m_OriginalValue_ps_c0[2] = pConstantData[4*(0 -StartRegister)+2];
				m_OriginalValue_ps_c0[3] = pConstantData[4*(0 -StartRegister)+3];

				if(curOverride.m_Override_ps_c0)
					g_OldDirect3DDevice9->SetPixelShaderConstantF(0, curOverride.m_OverrideValue_ps_c0, 1);
			}

			if(StartRegister <= 5 && 5 < StartRegister+Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c5_Dirty = true;
				m_OriginalValue_ps_c5[0] = pConstantData[4*(5 -StartRegister)+0];
				m_OriginalValue_ps_c5[1] = pConstantData[4*(5 -StartRegister)+1];
				m_OriginalValue_ps_c5[2] = pConstantData[4*(5 -StartRegister)+2];
				m_OriginalValue_ps_c5[3] = pConstantData[4*(5 -StartRegister)+3];

				if(curOverride.m_Override_ps_c5)
					g_OldDirect3DDevice9->SetPixelShaderConstantF(5, curOverride.m_OverrideValue_ps_c5, 1);
			}

			if(StartRegister <= 12 && 12 < StartRegister+Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c12_Dirty = true;
				m_OriginalValue_ps_c12[0] = pConstantData[4*(12 -StartRegister)+0];
				m_OriginalValue_ps_c12[1] = pConstantData[4*(12 -StartRegister)+1];
				m_OriginalValue_ps_c12[2] = pConstantData[4*(12 -StartRegister)+2];
				m_OriginalValue_ps_c12[3] = pConstantData[4*(12 -StartRegister)+3];

				if(curOverride.m_Override_ps_c12_y)
				{
					float tmp[4] = { m_OriginalValue_ps_c12[0], curOverride.m_OverrideValue_ps_c12_y, m_OriginalValue_ps_c12[2], m_OriginalValue_ps_c12[3] };
					g_OldDirect3DDevice9->SetPixelShaderConstantF(12, tmp, 1);
				}
			}

			if(StartRegister <= 29 && 29 < StartRegister+Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c29_Dirty = true;
				m_OriginalValue_ps_c29[0] = pConstantData[4*(29 -StartRegister)+0];
				m_OriginalValue_ps_c29[1] = pConstantData[4*(29 -StartRegister)+1];
				m_OriginalValue_ps_c29[2] = pConstantData[4*(29 -StartRegister)+2];
				m_OriginalValue_ps_c29[3] = pConstantData[4*(29 -StartRegister)+3];

				if(curOverride.m_Override_ps_c29_w)
				{
					float tmp[4] = { m_OriginalValue_ps_c29[0], m_OriginalValue_ps_c29[1], m_OriginalValue_ps_c29[2], curOverride.m_OverrideValue_ps_c29_w };
					g_OldDirect3DDevice9->SetPixelShaderConstantF(29, tmp, 1);
				}
			}

			if(StartRegister <= 31 && 31 < StartRegister+Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c31_Dirty = true;
				m_OriginalValue_ps_c31[0] = pConstantData[4*(31 -StartRegister)+0];
				m_OriginalValue_ps_c31[1] = pConstantData[4*(31 -StartRegister)+1];
				m_OriginalValue_ps_c31[2] = pConstantData[4*(31 -StartRegister)+2];
				m_OriginalValue_ps_c31[3] = pConstantData[4*(31 -StartRegister)+3];

				if(curOverride.m_Override_ps_c31)
					g_OldDirect3DDevice9->SetPixelShaderConstantF(31, curOverride.m_OverrideValue_ps_c31, 1);
			}

			if (StartRegister <= 1 && 1 < StartRegister + Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c1_Dirty = true;
				m_OriginalValue_ps_c1[0] = pConstantData[4 * (1 - StartRegister) + 0];
				m_OriginalValue_ps_c1[1] = pConstantData[4 * (1 - StartRegister) + 1];
				m_OriginalValue_ps_c1[2] = pConstantData[4 * (1 - StartRegister) + 2];
				m_OriginalValue_ps_c1[3] = pConstantData[4 * (1 - StartRegister) + 3];

				if (curOverride.m_Override_ps_c1)
				{
					float tmp[4] = {  m_OriginalValue_ps_c1[0], m_OriginalValue_ps_c1[1], m_OriginalValue_ps_c1[2], m_OriginalValue_ps_c1[3] };

					if (curOverride.m_Override_ps_c1)
					{
						curOverride.m_Override_ps_c1->D3d9HooksFloat4ParamOverride(tmp);
					}

					g_OldDirect3DDevice9->SetPixelShaderConstantF(1, tmp, 1);
				}
			}

			if (StartRegister <= 30 && 30 < StartRegister + Vector4fCount)
			{
				m_DirtyTrack.m_OriginalValue_ps_c30_Dirty = true;
				m_OriginalValue_ps_c30[0] = pConstantData[4 * (30 - StartRegister) + 0];
				m_OriginalValue_ps_c30[1] = pConstantData[4 * (30 - StartRegister) + 1];
				m_OriginalValue_ps_c30[2] = pConstantData[4 * (30 - StartRegister) + 2];
				m_OriginalValue_ps_c30[3] = pConstantData[4 * (30 - StartRegister) + 3];

				if (curOverride.m_Override_ps_c30)
				{
					float tmp[4] = { m_OriginalValue_ps_c30[0], m_OriginalValue_ps_c30[1], m_OriginalValue_ps_c30[2], m_OriginalValue_ps_c30[3] };

					if (curOverride.m_Override_ps_c30)
					{
						curOverride.m_Override_ps_c30->D3d9HooksFloat4ParamOverride(tmp);
					}

					g_OldDirect3DDevice9->SetPixelShaderConstantF(30, tmp, 1);
				}
			}
		}

		return result;
	}

    STDMETHOD(GetPixelShaderConstantF)(THIS_ UINT StartRegister,float* pConstantData,UINT Vector4fCount)
	{
		HRESULT result = g_OldDirect3DDevice9->GetPixelShaderConstantF(StartRegister, pConstantData, Vector4fCount);

		if(pConstantData)
		{
			if(StartRegister <= 0 && 0 < StartRegister+Vector4fCount)
			{
				pConstantData[4*(0 -StartRegister)+0] = m_OriginalValue_ps_c0[0];
				pConstantData[4*(0 -StartRegister)+1] = m_OriginalValue_ps_c0[1];
				pConstantData[4*(0 -StartRegister)+2] = m_OriginalValue_ps_c0[2];
				pConstantData[4*(0 -StartRegister)+3] = m_OriginalValue_ps_c0[3];
			}

			if(StartRegister <= 5 && 5 < StartRegister+Vector4fCount)
			{
				pConstantData[4*(5 -StartRegister)+0] = m_OriginalValue_ps_c5[0];
				pConstantData[4*(5 -StartRegister)+1] = m_OriginalValue_ps_c5[1];
				pConstantData[4*(5 -StartRegister)+2] = m_OriginalValue_ps_c5[2];
				pConstantData[4*(5 -StartRegister)+3] = m_OriginalValue_ps_c5[3];
			}

			if(StartRegister <= 12 && 12 < StartRegister+Vector4fCount)
			{
				pConstantData[4*(12 -StartRegister)+0] = m_OriginalValue_ps_c12[0];
				pConstantData[4*(12 -StartRegister)+1] = m_OriginalValue_ps_c12[1];
				pConstantData[4*(12 -StartRegister)+2] = m_OriginalValue_ps_c12[2];
				pConstantData[4*(12 -StartRegister)+3] = m_OriginalValue_ps_c12[3];
			}

			if(StartRegister <= 29 && 29 < StartRegister+Vector4fCount)
			{
				pConstantData[4*(29 -StartRegister)+0] = m_OriginalValue_ps_c29[0];
				pConstantData[4*(29 -StartRegister)+1] = m_OriginalValue_ps_c29[1];
				pConstantData[4*(29 -StartRegister)+2] = m_OriginalValue_ps_c29[2];
				pConstantData[4*(29 -StartRegister)+3] = m_OriginalValue_ps_c29[3];
			}

			if (StartRegister <= 31 && 31 < StartRegister + Vector4fCount)
			{
				pConstantData[4 * (31 - StartRegister) + 0] = m_OriginalValue_ps_c31[0];
				pConstantData[4 * (31 - StartRegister) + 1] = m_OriginalValue_ps_c31[1];
				pConstantData[4 * (31 - StartRegister) + 2] = m_OriginalValue_ps_c31[2];
				pConstantData[4 * (31 - StartRegister) + 3] = m_OriginalValue_ps_c31[3];
			}

			if (StartRegister <= 1 && 1 < StartRegister + Vector4fCount)
			{
				pConstantData[4 * (1 - StartRegister) + 0] = m_OriginalValue_ps_c1[0];
				pConstantData[4 * (1 - StartRegister) + 1] = m_OriginalValue_ps_c1[1];
				pConstantData[4 * (1 - StartRegister) + 2] = m_OriginalValue_ps_c1[2];
				pConstantData[4 * (1 - StartRegister) + 3] = m_OriginalValue_ps_c1[3];
			}

			if (StartRegister <= 30 && 30 < StartRegister + Vector4fCount)
			{
				pConstantData[4 * (30 - StartRegister) + 0] = m_OriginalValue_ps_c30[0];
				pConstantData[4 * (30 - StartRegister) + 1] = m_OriginalValue_ps_c30[1];
				pConstantData[4 * (30 - StartRegister) + 2] = m_OriginalValue_ps_c30[2];
				pConstantData[4 * (30 - StartRegister) + 3] = m_OriginalValue_ps_c30[3];
			}
		}
		
		return result;
	}

    STDMETHOD(SetPixelShaderConstantI)(THIS_ UINT StartRegister,CONST int* pConstantData,UINT Vector4iCount)
	{
		return g_OldDirect3DDevice9->SetPixelShaderConstantI(StartRegister, pConstantData, Vector4iCount);
	}
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetPixelShaderConstantI);
	
    STDMETHOD(SetPixelShaderConstantB)(THIS_ UINT StartRegister,CONST BOOL* pConstantData,UINT  BoolCount)
	{
		return g_OldDirect3DDevice9->SetPixelShaderConstantB(StartRegister, pConstantData, BoolCount);
	}
	
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, GetPixelShaderConstantB);
    
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawRectPatch);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DrawTriPatch);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, DeletePatch);
    IFACE_PASSTHROUGH_DECL(IDirect3DDevice9, CreateQuery);


	/*** IDirect3DDevice9Ex methods ***/
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, SetConvolutionMonoKernel);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, ComposeRects);

	STDMETHOD(PresentEx)(THIS_ CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion, DWORD dwFlags)
	{
		Afx_Present_Before(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, dwFlags);

		HRESULT hResult = g_OldDirect3DDevice9Ex->PresentEx(pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion, dwFlags);

		Afx_Present_After(hResult);

		return hResult;
	}

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, GetGPUThreadPriority);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, SetGPUThreadPriority);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, WaitForVBlank);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, CheckResourceResidency);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, SetMaximumFrameLatency);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, GetMaximumFrameLatency);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, CheckDeviceState);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, CreateRenderTargetEx);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, CreateOffscreenPlainSurfaceEx);
	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, CreateDepthStencilSurfaceEx);

	STDMETHOD(ResetEx)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX *pFullscreenDisplayMode)
	{
		Afx_Reset_Before(pPresentationParameters, NULL);

		HRESULT hResult = g_OldDirect3DDevice9Ex->ResetEx(pPresentationParameters, pFullscreenDisplayMode);

		Afx_Reset_After(hResult, pPresentationParameters, NULL);

		return hResult;
	}

	IFACE_PASSTHROUGH_DECL(IDirect3DDevice9Ex, GetDisplayModeEx);
} g_NewDirect3DDevice9;

IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, TestCooperativeLevel, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetAvailableTextureMem, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, EvictManagedResources, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetDirect3D, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetDeviceCaps, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetDisplayMode, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetCreationParameters, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetCursorPosition, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, ShowCursor, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateAdditionalSwapChain, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetSwapChain, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetNumberOfSwapChains, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetRasterStatus, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetDialogBoxMode, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetGammaRamp, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetGammaRamp, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateVolumeTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateCubeTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateVertexBuffer, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateIndexBuffer, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateRenderTarget, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateDepthStencilSurface, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, UpdateTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateOffscreenPlainSurface, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetTransform, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetTransform, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, MultiplyTransform, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetViewport, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetViewport, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetMaterial, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetLight, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetLight, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, LightEnable, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetLightEnable, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetClipPlane, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetClipPlane, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetClipStatus, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetClipStatus, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetTexture, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetTextureStageState, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetTextureStageState, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetSamplerState, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetSamplerState, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, ValidateDevice, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetPaletteEntries, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetPaletteEntries, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetCurrentTexturePalette, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetCurrentTexturePalette, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetScissorRect, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetScissorRect, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetSoftwareVertexProcessing, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetSoftwareVertexProcessing, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetNPatchMode, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetNPatchMode, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawPrimitive, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawIndexedPrimitive, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawPrimitiveUP, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawIndexedPrimitiveUP, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, ProcessVertices, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateVertexDeclaration, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetVertexDeclaration, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetVertexDeclaration, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetFVF, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetFVF, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateVertexShader, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetVertexShaderConstantF, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetVertexShaderConstantI, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetVertexShaderConstantB, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetStreamSource, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetStreamSource, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetStreamSourceFreq, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetStreamSourceFreq, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, SetIndices, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetIndices, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreatePixelShader, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetPixelShaderConstantI, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, GetPixelShaderConstantB, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawRectPatch, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DrawTriPatch, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, DeletePatch, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9, CreateQuery, NewDirect3DDevice9, g_OldDirect3DDevice9);

IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, SetConvolutionMonoKernel, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, ComposeRects, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, GetGPUThreadPriority, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, SetGPUThreadPriority, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, WaitForVBlank, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, CheckResourceResidency, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, SetMaximumFrameLatency, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, GetMaximumFrameLatency, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, CheckDeviceState, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, CreateRenderTargetEx, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, CreateOffscreenPlainSurfaceEx, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, CreateDepthStencilSurfaceEx, NewDirect3DDevice9, g_OldDirect3DDevice9);
IFACE_PASSTHROUGH_DEF(IDirect3DDevice9Ex, GetDisplayModeEx, NewDirect3DDevice9, g_OldDirect3DDevice9);



COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CAfxHookDirect3DStateBlock9::Capture(THIS)
{
	g_NewDirect3DDevice9.OnBefore_AfxHookDirect3DStateBlock9_Capture();
	
	HRESULT hResult = m_Parent->Capture();
	
	g_NewDirect3DDevice9.OnAfter_AfxHookDirect3DStateBlock9_Capture();

	return hResult;
}

COM_DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CAfxHookDirect3DStateBlock9::Apply(THIS)
{
	HRESULT hResult = m_Parent->Apply();

	g_NewDirect3DDevice9.On_AfxHookDirect3DStateBlock9_Applied(m_DirtyTrack);

	return hResult;
}

IDirect3D9 * g_OldDirect3D9 = nullptr;
IDirect3D9Ex * g_OldDirect3D9Ex = nullptr;

struct NewDirect3D9
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) {

		if (riid == __uuidof(IDirect3D9Ex))
		{
			if (ppvObj) ppvObj = NULL;
			return E_NOINTERFACE; // If we shoved in D3D9Ex, make sure CS:GO does not notice it.
		}

		return g_OldDirect3D9->QueryInterface(riid, ppvObj);
	}

	IFACE_PASSTHROUGH_DECL(IDirect3D9, AddRef);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, Release);

    /*** IDirect3D9 methods ***/
	IFACE_PASSTHROUGH_DECL(IDirect3D9, RegisterSoftwareDevice);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetAdapterCount);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetAdapterIdentifier);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetAdapterModeCount);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, EnumAdapterModes);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetAdapterDisplayMode);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, CheckDeviceType);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, CheckDeviceFormat);
	
	STDMETHOD(CheckDeviceMultiSampleType)(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD* pQualityLevels)
	{
#if AFX_INTEROP
		if (AfxInterop::MainEnabled())
		{
			pQualityLevels = 0;

			if (D3DMULTISAMPLE_NONE != MultiSampleType)
				return D3DERR_NOTAVAILABLE;
		}
#endif

		return g_OldDirect3D9->CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType, pQualityLevels);
	}

	IFACE_PASSTHROUGH_DECL(IDirect3D9, CheckDepthStencilMatch);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, CheckDeviceFormatConversion);
	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetDeviceCaps);

	IFACE_PASSTHROUGH_DECL(IDirect3D9, GetAdapterMonitor);

	STDMETHOD(CreateDevice)(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface)
	{
		if (D3DCREATE_ADAPTERGROUP_DEVICE & BehaviorFlags) return D3DERR_NOTAVAILABLE; //TODO: Support this code path?

		BehaviorFlags = BehaviorFlags & ~(DWORD)D3DCREATE_PUREDEVICE; // We want state tracking actually.

		HRESULT hRet = D3DERR_NOTAVAILABLE;

		D3DDISPLAYMODE displayMode;

		if (pPresentationParameters) FixPresentationParementers(pPresentationParameters);

		g_bSupportsIntz = pPresentationParameters
			&& SUCCEEDED(g_OldDirect3D9->GetAdapterDisplayMode(Adapter, &displayMode))
			&& SUCCEEDED(g_OldDirect3D9->CheckDeviceFormat(Adapter, DeviceType, displayMode.Format, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE, FOURCC_INTZ));

#if AFX_INTEROP
		if (AfxInterop::Enabled() && g_OldDirect3D9Ex && pPresentationParameters)
		{
			D3DDISPLAYMODEEX displayModeEx;
			bool fullscreen = false;

			DeviceType = D3DDEVTYPE_HAL;
			BehaviorFlags = (BehaviorFlags & ~(DWORD)(D3DCREATE_MIXED_VERTEXPROCESSING | D3DCREATE_SOFTWARE_VERTEXPROCESSING)) | D3DCREATE_HARDWARE_VERTEXPROCESSING;

			if (!(pPresentationParameters->Windowed))
			{
				fullscreen = true;

				displayModeEx.Size = sizeof(displayModeEx);
				displayModeEx.Format = pPresentationParameters->BackBufferFormat;
				displayModeEx.Width = pPresentationParameters->BackBufferWidth;
				displayModeEx.Height = pPresentationParameters->BackBufferHeight;
				displayModeEx.RefreshRate = pPresentationParameters->FullScreen_RefreshRateInHz;
				displayModeEx.ScanLineOrdering = D3DSCANLINEORDERING_PROGRESSIVE; //TODO: Support interlaced?
			}

			hRet = g_OldDirect3D9Ex->CreateDeviceEx(Adapter, DeviceType, hFocusWindow, BehaviorFlags, pPresentationParameters, fullscreen ? &displayModeEx : nullptr, ppReturnedDeviceInterface != nullptr ? &g_OldDirect3DDevice9Ex : nullptr);

			if (SUCCEEDED(hRet) && ppReturnedDeviceInterface)
			{
				g_OldDirect3DDevice9 = g_OldDirect3DDevice9Ex;

				*ppReturnedDeviceInterface = reinterpret_cast<IDirect3DDevice9 *>(&g_NewDirect3DDevice9);

				g_NewDirect3DDevice9.Init(pPresentationParameters);

				Shared_Direct3DDevice9_Init(Adapter, pPresentationParameters->hDeviceWindow, g_OldDirect3DDevice9);
			}
			else
				return D3DERR_NOTAVAILABLE;
		}
		else
		{
#endif
			hRet = g_OldDirect3D9->CreateDevice(Adapter, DeviceType, hFocusWindow, BehaviorFlags, pPresentationParameters ? pPresentationParameters : pPresentationParameters, ppReturnedDeviceInterface);

			if (SUCCEEDED(hRet) && pPresentationParameters && ppReturnedDeviceInterface)
			{
				g_OldDirect3DDevice9 = *ppReturnedDeviceInterface;

				*ppReturnedDeviceInterface = reinterpret_cast<IDirect3DDevice9 *>(&g_NewDirect3DDevice9);

				g_NewDirect3DDevice9.Init(pPresentationParameters);

				Shared_Direct3DDevice9_Init(Adapter, pPresentationParameters->hDeviceWindow, g_OldDirect3DDevice9);
			}
#if AFX_INTEROP
		}
#endif

		return hRet;
	}

	/*** IDirect3D9Ex methods ***/
	IFACE_PASSTHROUGH_DECL(IDirect3D9Ex, GetAdapterModeCountEx);
	IFACE_PASSTHROUGH_DECL(IDirect3D9Ex, EnumAdapterModesEx);
	IFACE_PASSTHROUGH_DECL(IDirect3D9Ex, GetAdapterDisplayModeEx);

	STDMETHOD(CreateDeviceEx)(THIS_ UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, D3DDISPLAYMODEEX* pFullscreenDisplayMode, IDirect3DDevice9Ex** ppReturnedDeviceInterface)
	{
		HRESULT hRet = D3DERR_NOTAVAILABLE;

		D3DDISPLAYMODE displayMode;

		BehaviorFlags = BehaviorFlags & ~(DWORD)D3DCREATE_PUREDEVICE; // We want state tracking actually.

		if (pPresentationParameters) FixPresentationParementers(pPresentationParameters);

		g_bSupportsIntz = pPresentationParameters
			&& SUCCEEDED(g_OldDirect3D9->GetAdapterDisplayMode(Adapter, &displayMode))
			&& SUCCEEDED(g_OldDirect3D9->CheckDeviceFormat(Adapter, DeviceType, displayMode.Format, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE, FOURCC_INTZ));

#ifdef AFX_INTEROP
		if (AfxInterop::MainEnabled() && pPresentationParameters)
		{
			DeviceType = D3DDEVTYPE_HAL;
			BehaviorFlags = (BehaviorFlags & ~(DWORD)(D3DCREATE_MIXED_VERTEXPROCESSING | D3DCREATE_SOFTWARE_VERTEXPROCESSING)) | D3DCREATE_HARDWARE_VERTEXPROCESSING;

			hRet = g_OldDirect3D9Ex->CreateDeviceEx(Adapter, DeviceType, hFocusWindow, BehaviorFlags, pPresentationParameters, pFullscreenDisplayMode, ppReturnedDeviceInterface);

			if (SUCCEEDED(hRet) && ppReturnedDeviceInterface)
			{
				g_OldDirect3DDevice9Ex = *ppReturnedDeviceInterface;
				g_OldDirect3DDevice9 = *ppReturnedDeviceInterface;

				*ppReturnedDeviceInterface = reinterpret_cast<IDirect3DDevice9Ex *>(&g_NewDirect3DDevice9);

				g_NewDirect3DDevice9.Init(pPresentationParameters);

				Shared_Direct3DDevice9_Init(Adapter, pPresentationParameters->hDeviceWindow, g_OldDirect3DDevice9);
			}
			else
				return D3DERR_NOTAVAILABLE;
		}
		else
		{
#endif
			hRet = g_OldDirect3D9Ex->CreateDeviceEx(Adapter, DeviceType, hFocusWindow, BehaviorFlags, pPresentationParameters, pFullscreenDisplayMode, ppReturnedDeviceInterface);

			if (SUCCEEDED(hRet) && pPresentationParameters && ppReturnedDeviceInterface)
			{
				g_OldDirect3DDevice9Ex = *ppReturnedDeviceInterface;
				g_OldDirect3DDevice9 = *ppReturnedDeviceInterface;

				*ppReturnedDeviceInterface = reinterpret_cast<IDirect3DDevice9Ex *>(&g_NewDirect3DDevice9);

				g_NewDirect3DDevice9.Init(pPresentationParameters);

				Shared_Direct3DDevice9_Init(Adapter, pPresentationParameters->hDeviceWindow, g_OldDirect3DDevice9);
			}
			else
				return D3DERR_NOTAVAILABLE;
#ifdef AFX_INTEROP
		}
#endif

		return hRet;
	}

	IFACE_PASSTHROUGH_DECL(IDirect3D9Ex, GetAdapterLUID);

} g_NewDirect3D9;

IFACE_PASSTHROUGH_DEF(IDirect3D9, AddRef, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, Release, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, RegisterSoftwareDevice, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetAdapterCount, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetAdapterIdentifier, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetAdapterModeCount, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, EnumAdapterModes, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetAdapterDisplayMode, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, CheckDeviceType, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, CheckDeviceFormat, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, CheckDepthStencilMatch, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, CheckDeviceFormatConversion, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetDeviceCaps, NewDirect3D9, g_OldDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9, GetAdapterMonitor, NewDirect3D9, g_OldDirect3D9);

IFACE_PASSTHROUGH_DEF(IDirect3D9Ex, GetAdapterModeCountEx, NewDirect3D9, g_NewDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9Ex, EnumAdapterModesEx, NewDirect3D9, g_NewDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9Ex, GetAdapterDisplayModeEx, NewDirect3D9, g_NewDirect3D9);
IFACE_PASSTHROUGH_DEF(IDirect3D9Ex, GetAdapterLUID, NewDirect3D9, g_NewDirect3D9);

Direct3DCreate9_t old_Direct3DCreate9 = 0;
Direct3DCreate9Ex_t old_Direct3DCreate9Ex = 0;

IDirect3D9 * WINAPI new_Direct3DCreate9(UINT SDKVersion)
{
	if(D3D_SDK_VERSION == SDKVersion)
	{
#if 0 && AFX_INTEROP
		if (AfxInterop::Enabled())
		{
			IDirect3D9Ex * device = NULL;

			if (!old_Direct3DCreate9Ex)
			{
				HMODULE hD3D9Dll = GetModuleHandle("d3d9.dll");
				old_Direct3DCreate9Ex = (Direct3DCreate9Ex_t)GetProcAddress(hD3D9Dll, "Direct3DCreate9Ex");
			}

			old_Direct3DCreate9Ex(SDKVersion, &device);
			g_OldDirect3D9Ex = device;
			g_OldDirect3D9 = g_OldDirect3D9Ex;
		}
		else
		{
			g_OldDirect3D9 = old_Direct3DCreate9(SDKVersion);
		}
#else
		g_OldDirect3D9 = old_Direct3DCreate9(SDKVersion);
#endif

		return reinterpret_cast<IDirect3D9 *>(&g_NewDirect3D9);
	}

	return old_Direct3DCreate9(SDKVersion);
}

HRESULT WINAPI new_Direct3DCreate9Ex(UINT SDKVersion, IDirect3D9Ex** ppD3DDevice)
{
	if(D3D_SDK_VERSION == SDKVersion)
	{
		HRESULT hResult = old_Direct3DCreate9Ex(SDKVersion, &g_OldDirect3D9Ex);

		g_OldDirect3D9 = g_OldDirect3D9Ex;

		if(ppD3DDevice) *ppD3DDevice = 0 != g_OldDirect3D9Ex ? reinterpret_cast<IDirect3D9Ex *>(&g_NewDirect3D9) : 0;

		return hResult;
	}

	return old_Direct3DCreate9Ex(SDKVersion, ppD3DDevice);
}

bool AfxD3D9_Check_Supports_R32F_With_Blending(void)
{
	if(g_OldDirect3D9 && g_OldDirect3DDevice9)
	{
		if(SUCCEEDED(g_OldDirect3D9->CheckDeviceFormat(
			g_Adapter,
			D3DDEVTYPE_HAL,
			D3DFMT_R8G8B8,
			D3DUSAGE_RENDERTARGET | D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING,
			D3DRTYPE_SURFACE,
			D3DFMT_R32F
		)))
			return true;
	}

	return false;
}

bool AfxD3D9_Check_Supports_R32F(void)
{
	if (g_OldDirect3D9)
	{
		if (SUCCEEDED(g_OldDirect3D9->CheckDeviceFormat(
			g_Adapter,
			D3DDEVTYPE_HAL,
			D3DFMT_R8G8B8,
			D3DUSAGE_RENDERTARGET,
			D3DRTYPE_TEXTURE,
			D3DFMT_R32F
		)))
			return true;
	}

	return false;
}


void AfxD3D9BeginCleanState()
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.AfxBeginCleanState();
}

void AfxD3D9EndCleanState()
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.AfxEndCleanState();
}

void AfxD3D9PushOverrideState(bool clean)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.AfxPushOverrideState(clean);

}

void AfxD3D9PopOverrideState(void)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.AfxPopOverrideState();
}

void AfxD3D9OverrideBegin_ModulationColorBlend(ID3d9HooksFloat4ParamOverride* overrideFn)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c1(overrideFn);
}

void AfxD3D9OverrideEnd_ModulationColorBlend(void)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c1();
}

void AfxD3D9OverrideBegin_LightScale(ID3d9HooksFloat4ParamOverride* overrideFn)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c30(overrideFn);
}

void AfxD3D9OverrideEnd_LightScale(void)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c30();
}



void AfxD3D9OverrideBegin_D3DRS_BLENDOP(DWORD value)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_BLENDOP(value);
}

void AfxD3D9OverrideEnd_D3DRS_BLENDOP(void)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_BLENDOP();
}

void AfxD3D9OverrideBegin_D3DRS_SRCBLEND(DWORD value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_SRCBLEND(value);
}

void AfxD3D9OverrideEnd_D3DRS_SRCBLEND(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_SRCBLEND();
}

void AfxD3D9OverrideBegin_D3DRS_DESTBLEND(DWORD value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_DESTBLEND(value);
}

void AfxD3D9OverrideEnd_D3DRS_DESTBLEND(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_DESTBLEND();
}

void AfxD3D9OverrideBegin_D3DRS_SRGBWRITEENABLE(DWORD value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_SRGBWRITEENABLE(value);
}

void AfxD3D9OverrideEnd_D3DRS_SRGBWRITEENABLE(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_SRGBWRITEENABLE();
}

void AfxD3D9OverrideBegin_D3DRS_COLORWRITEENABLE(DWORD value)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_COLORWRITEENABLE(value);
}

void AfxD3D9OverrideEnd_D3DRS_COLORWRITEENABLE(void)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_COLORWRITEENABLE();
}

void AfxD3D9OverrideBegin_D3DRS_ZWRITEENABLE(DWORD value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_ZWRITEENABLE(value);
}

void AfxD3D9OverrideEnd_D3DRS_ZWRITEENABLE(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_ZWRITEENABLE();
}

void AfxD3D9OverrideBegin_D3DRS_ALPHABLENDENABLE(DWORD value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_D3DRS_ALPHABLENDENABLE(value);
}

void AfxD3D9OverrideEnd_D3DRS_ALPHABLENDENABLE(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_D3DRS_ALPHABLENDENABLE();
}

void AfxD3D9_OverrideBegin_ps_c0(float const values[4])
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c0(values);
}

void AfxD3D9_OverrideEnd_ps_c0(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c0();
}

void AfxD3D9_OverrideBegin_ps_c5(float const values[4])
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c5(values);
}

void AfxD3D9_OverrideEnd_ps_c5(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c5();
}

void AfxD3D9_OverrideBegin_ps_c12_y(float value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c12_y(value);
}

void AfxD3D9_OverrideEnd_ps_c12_y(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c12_y();
}

void AfxD3D9_OverrideBegin_ps_c29_w(float value)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c29_w(value);
}

void AfxD3D9_OverrideEnd_ps_c29_w(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c29_w();
}

void AfxD3D9_OverrideBegin_ps_c31(float const values[4])
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_ps_c31(values);
}

void AfxD3D9_OverrideEnd_ps_c31(void)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_ps_c31();
}

void AfxD3D9_OverrideBegin_SetVertexShader(IDirect3DVertexShader9 * overrideShader)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_SetVertexShader(overrideShader);
}

void AfxD3D9_OverrideEnd_SetVertexShader()
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_SetVertexShader();
}

void AfxD3D9_OverrideBegin_SetPixelShader(IDirect3DPixelShader9 * overrideShader)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideBegin_SetPixelShader(overrideShader);
}

void AfxD3D9_OverrideEnd_SetPixelShader()
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.OverrideEnd_SetPixelShader();
}

void AfxD3D9_Block_Present(bool block)
{
	if(!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.Block_Present(block);
}

void AfxD3D9_Block_Clear(bool block)
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.Block_Clear(block);
}

IDirect3DStateBlock9* oldState = NULL;

bool AfxD3D9_BeginOwnRender()
{
	if (!g_OldDirect3DDevice9) return false;

	// Backup the DX9 state
	IDirect3DStateBlock9* oldState = NULL;
	
	if (FAILED(g_NewDirect3DDevice9.CreateStateBlock(D3DSBT_ALL, &oldState)))
		return false;
	
	g_NewDirect3DDevice9.EndScene();
}

void AfxD3D9_EndOwnRender()
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.BeginScene();

	if (oldState)
	{
		oldState->Apply();
		oldState->Release();
		oldState = NULL;
	}
}

#ifdef AFX_INTEROP
void AfxD3D_WaitForGPU()
{
	if (!g_OldDirect3DDevice9) return;

	g_NewDirect3DDevice9.AfxWaitForGPU();
}
#endif

bool AfxD3d9_DrawDepthSupported(void)
{
#ifdef AFX_INTEROP
	if (AfxInterop::MainEnabled())
		return false;
#endif

	return g_OldDirect3DDevice9 && g_bSupportsIntz;
}


void AfxIntzOverrideBegin(bool bNoReplacement)
{
	if (g_OldDirect3DDevice9) g_NewDirect3DDevice9.AfxOverrideDefaultBuffersWithIntz(true, bNoReplacement);
}

void AfxIntzOverrideEnd(bool bNoReplacement)
{
	if (g_OldDirect3DDevice9) g_NewDirect3DDevice9.AfxOverrideDefaultBuffersWithIntz(false, bNoReplacement);
}

void AfxDrawDepth(AfxDrawDepthEncode encode, AfxDrawDepthMode mode, bool clip, float depthVal, float depthValMax, int x, int y, int width, int height, float zNear, float zFar, bool drawToScreen, float projectionMatrix[4][4])
{
	if (!g_bSupportsIntz) return;

	g_NewDirect3DDevice9.AfxDrawDepth(encode, mode, clip, depthVal, depthValMax, x, y, width, height, zNear, zFar, drawToScreen, projectionMatrix);
}

void AfxDrawGuides(int x, int y, int width, int height, bool phiGrid, bool ruleOfThirds)
{
	g_NewDirect3DDevice9.AfxDrawGuides(x, y, width, height, phiGrid, ruleOfThirds);
}

void AfxDrawRect(IDirect3DTexture9* texture, int x, int y, int width, int height, float x0, float y0, float x1, float y1)
{
	g_NewDirect3DDevice9.AfxDrawRect(texture, x, y, width, height, x0, y0, x1, y1);
}

IDirect3DDevice9* AfxGetDirect3DDevice9()
{
	return g_OldDirect3DDevice9;
}

IDirect3DDevice9Ex* AfxGetDirect3DDevice9Ex()
{
	return g_OldDirect3DDevice9Ex;
}

IDirect3DSurface9* AfxGetRenderTargetSurface()
{
	return g_NewDirect3DDevice9.AfxGetRenderTargetSurface();
}


IDirect3DSurface9* AfxSetRenderTargetR32FDepthTexture() {
	return g_NewDirect3DDevice9.AfxSetRenderTargetR32FDepthTexture();
}

void AfxSetRenderTargetR32FDepthTexture_Restore(IDirect3DSurface9* renderTarget) {
	g_NewDirect3DDevice9.AfxSetRenderTargetR32FDepthTexture_Restore(renderTarget);
}

IDirect3DTexture9* AfxGetR32FDepthTexture() {
	return g_NewDirect3DDevice9.AfxGetR32FDepthTexture();
}